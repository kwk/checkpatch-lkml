WARNING:COMMIT_LOG_LONG_LINE: Possible unwrapped commit description (prefer a maximum 75 chars per line)
#44: 
  - Very low fragmentation: In all tests, xvMalloc memory usage is within 12%

ERROR:EXECUTE_PERMISSIONS: do not set execute permissions for source files
#80: FILE: include/linux/xvmalloc.h

There is no reason for source files to be executable.  The executable
bit can be removed safely.

WARNING:FILE_PATH_CHANGES: added, moved or deleted file(s), does MAINTAINERS need updating?
#80: 
new file mode 100755

Whenever files are added, moved, or deleted, the MAINTAINERS file
patterns can be out of sync or outdated.

So MAINTAINERS might need updating in these cases.

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#85: FILE: include/linux/xvmalloc.h:1:
+/*

The source file is missing or has an improper SPDX identifier tag.
The Linux kernel requires the precise SPDX identifier in all source files,
and it is thoroughly documented in the kernel docs.

See: https://www.kernel.org/doc/html/latest/process/license-rules.html

CHECK:CAMELCASE: Avoid CamelCase: <Pool>
#103: FILE: include/linux/xvmalloc.h:19:
+struct Pool;

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

CHECK:CAMELCASE: Avoid CamelCase: <xvCreateMemPool>
#105: FILE: include/linux/xvmalloc.h:21:
+struct Pool *xvCreateMemPool(void);

CHECK:CAMELCASE: Avoid CamelCase: <xvDestroyMemPool>
#106: FILE: include/linux/xvmalloc.h:22:
+void xvDestroyMemPool(struct Pool *pool);

CHECK:CAMELCASE: Avoid CamelCase: <xvMalloc>
#108: FILE: include/linux/xvmalloc.h:24:
+int xvMalloc(struct Pool *pool, u32 size, u32 *pageNum, u32 *offset);

CHECK:CAMELCASE: Avoid CamelCase: <pageNum>
#108: FILE: include/linux/xvmalloc.h:24:
+int xvMalloc(struct Pool *pool, u32 size, u32 *pageNum, u32 *offset);

CHECK:CAMELCASE: Avoid CamelCase: <xvFree>
#109: FILE: include/linux/xvmalloc.h:25:
+void xvFree(struct Pool *pool, u32 pageNum, u32 offset);

CHECK:CAMELCASE: Avoid CamelCase: <xvGetObjectSize>
#111: FILE: include/linux/xvmalloc.h:27:
+u32 xvGetObjectSize(void *obj);

CHECK:CAMELCASE: Avoid CamelCase: <xvGetTotalSizeBytes>
#112: FILE: include/linux/xvmalloc.h:28:
+u64 xvGetTotalSizeBytes(struct Pool *pool);

WARNING:CONFIG_DESCRIPTION: please write a help paragraph that fully describes the config symbol
#123: FILE: init/Kconfig:933:
+config XVMALLOC
+	tristate "xvMalloc memory allocator"
+	help
+	   This is a simple, low fragmentation, O(1) allocator.
+	   Details: http://code.google.com/p/compcache/wiki/xvMalloc
+

Kconfig symbols should have a help text which fully describes
it.

WARNING:CONFIG_DESCRIPTION: please write a help paragraph that fully describes the config symbol
#129: FILE: init/Kconfig:939:
+config XVMALLOC_STATS
+	depends on XVMALLOC
+	bool "Collect statistics"
+	default y
+	help
+	  Collect basic allocator statistics with minimal overhead.
+	  In unsure, say Y.
+

ERROR:EXECUTE_PERMISSIONS: do not set execute permissions for source files
#153: FILE: mm/xvmalloc.c

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#158: FILE: mm/xvmalloc.c:1:
+/*

CHECK:CAMELCASE: Avoid CamelCase: <statInc>
#183: FILE: mm/xvmalloc.c:26:
+static void statInc(u64 *value)

CHECK:CAMELCASE: Avoid CamelCase: <statDec>
#188: FILE: mm/xvmalloc.c:31:
+static void statDec(u64 *value)

CHECK:CAMELCASE: Avoid CamelCase: <SetBit>
#197: FILE: mm/xvmalloc.c:40:
+static void SetBit(u32 *value, u32 bitIdx)

CHECK:CAMELCASE: Avoid CamelCase: <bitIdx>
#197: FILE: mm/xvmalloc.c:40:
+static void SetBit(u32 *value, u32 bitIdx)

CHECK:CAMELCASE: Avoid CamelCase: <ClearBit>
#202: FILE: mm/xvmalloc.c:45:
+static void ClearBit(u32 *value, u32 bitIdx)

CHECK:CAMELCASE: Avoid CamelCase: <IsBlockFree>
#207: FILE: mm/xvmalloc.c:50:
+static u32 IsBlockFree(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <BlockHeader>
#207: FILE: mm/xvmalloc.c:50:
+static u32 IsBlockFree(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <IsPrevBlockFree>
#212: FILE: mm/xvmalloc.c:55:
+static u32 IsPrevBlockFree(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <SetBlockFree>
#217: FILE: mm/xvmalloc.c:60:
+static void SetBlockFree(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <SetBlockPrevFree>
#222: FILE: mm/xvmalloc.c:65:
+static void SetBlockPrevFree(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <SetBlockUsed>
#227: FILE: mm/xvmalloc.c:70:
+static void SetBlockUsed(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <SetBlockPrevUsed>
#232: FILE: mm/xvmalloc.c:75:
+static void SetBlockPrevUsed(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <GetBlockPrev>
#237: FILE: mm/xvmalloc.c:80:
+static u16 GetBlockPrev(struct BlockHeader *block)

CHECK:CAMELCASE: Avoid CamelCase: <SetBlockPrev>
#242: FILE: mm/xvmalloc.c:85:
+static void SetBlockPrev(struct BlockHeader *block, u16 newOffset)

CHECK:CAMELCASE: Avoid CamelCase: <newOffset>
#242: FILE: mm/xvmalloc.c:85:
+static void SetBlockPrev(struct BlockHeader *block, u16 newOffset)

CHECK:CAMELCASE: Avoid CamelCase: <GetIndexForInsert>
#251: FILE: mm/xvmalloc.c:94:
+static u32 GetIndexForInsert(u32 size)

CHECK:CAMELCASE: Avoid CamelCase: <GetIndex>
#262: FILE: mm/xvmalloc.c:105:
+static u32 GetIndex(u32 size)

WARNING:TYPO_SPELLING: 'derefrencable' may be misspelled - perhaps 'dereferenceable'?
#269: FILE: mm/xvmalloc.c:112:
+ * Given <pageNum, offset> pair, provide a derefrencable pointer.
                                            ^^^^^^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

CHECK:CAMELCASE: Avoid CamelCase: <GetPtrAtomic>
#272: FILE: mm/xvmalloc.c:115:
+static void *GetPtrAtomic(u32 pageNum, u16 offset, enum km_type type)

CHECK:CAMELCASE: Avoid CamelCase: <pagePtr>
#274: FILE: mm/xvmalloc.c:117:
+	unsigned char *pagePtr;

CHECK:CAMELCASE: Avoid CamelCase: <PutPtrAtomic>
#280: FILE: mm/xvmalloc.c:123:
+static void PutPtrAtomic(void *ptr, enum km_type type)

CHECK:CAMELCASE: Avoid CamelCase: <AllocPage>
#288: FILE: mm/xvmalloc.c:131:
+static u32 AllocPage(void)

CHECK:CAMELCASE: Avoid CamelCase: <FreePage>
#303: FILE: mm/xvmalloc.c:146:
+static void FreePage(u32 pageNum)

CHECK:CAMELCASE: Avoid CamelCase: <FindBlock>
#321: FILE: mm/xvmalloc.c:164:
+static u32 FindBlock(struct Pool *pool, u32 size, u32 *pageNum, u32 *offset)

CHECK:CAMELCASE: Avoid CamelCase: <flBitmap>
#323: FILE: mm/xvmalloc.c:166:
+	u32 flBitmap, slBitmap;

CHECK:CAMELCASE: Avoid CamelCase: <slBitmap>
#323: FILE: mm/xvmalloc.c:166:
+	u32 flBitmap, slBitmap;

CHECK:CAMELCASE: Avoid CamelCase: <flIndex>
#324: FILE: mm/xvmalloc.c:167:
+	u32 flIndex, slIndex, slBitStart;

CHECK:CAMELCASE: Avoid CamelCase: <slIndex>
#324: FILE: mm/xvmalloc.c:167:
+	u32 flIndex, slIndex, slBitStart;

CHECK:CAMELCASE: Avoid CamelCase: <slBitStart>
#324: FILE: mm/xvmalloc.c:167:
+	u32 flIndex, slIndex, slBitStart;

WARNING:TYPO_SPELLING: 'correspoding' may be misspelled - perhaps 'corresponding'?
#333: FILE: mm/xvmalloc.c:176:
+	/* Get FreeList index correspoding to this size */
 	                      ^^^^^^^^^^^^

CHECK:CAMELCASE: Avoid CamelCase: <FreeList>
#343: FILE: mm/xvmalloc.c:186:
+		*pageNum = pool->FreeList[slIndex].pageNum;

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'slBitStart != BITMAP_BITS'
#358: FILE: mm/xvmalloc.c:201:
+	if ((slBitStart != BITMAP_BITS) && slBitmap) {

Parentheses are not required in the following cases:

  1. Function pointer uses::

      (foo->bar)();

    could be::

      foo->bar();

  2. Comparisons in if::

      if ((foo->bar) && (foo->baz))
      if ((foo == bar))

    could be::

      if (foo->bar && foo->baz)
      if (foo == bar)

  3. addressof/dereference single Lvalues::

      &(foo->bar)
      *(foo->bar)

    could be::

      &foo->bar
      *foo->bar

CHECK:CAMELCASE: Avoid CamelCase: <InsertBlock>
#385: FILE: mm/xvmalloc.c:228:
+static void InsertBlock(struct Pool *pool, u32 pageNum, u32 offset,

CHECK:CAMELCASE: Avoid CamelCase: <nextBlock>
#389: FILE: mm/xvmalloc.c:232:
+	struct BlockHeader *nextBlock;

CHECK:CAMELCASE: Avoid CamelCase: <prevPageNum>
#394: FILE: mm/xvmalloc.c:237:
+	block->link.prevPageNum = INVALID_PGNUM;

CHECK:CAMELCASE: Avoid CamelCase: <prevOffset>
#395: FILE: mm/xvmalloc.c:238:
+	block->link.prevOffset = 0;

CHECK:CAMELCASE: Avoid CamelCase: <nextPageNum>
#396: FILE: mm/xvmalloc.c:239:
+	block->link.nextPageNum = pool->FreeList[slIndex].pageNum;

CHECK:CAMELCASE: Avoid CamelCase: <nextOffset>
#397: FILE: mm/xvmalloc.c:240:
+	block->link.nextOffset = pool->FreeList[slIndex].offset;

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#402: FILE: mm/xvmalloc.c:245:
+		nextBlock = (struct BlockHeader *)GetPtrAtomic(

CHECK:CAMELCASE: Avoid CamelCase: <RemoveBlockHead>
#418: FILE: mm/xvmalloc.c:261:
+static void RemoveBlockHead(struct Pool *pool, struct BlockHeader *block,

CHECK:CAMELCASE: Avoid CamelCase: <tmpBlock>
#421: FILE: mm/xvmalloc.c:264:
+	struct BlockHeader *tmpBlock;

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#439: FILE: mm/xvmalloc.c:282:
+		tmpBlock = (struct BlockHeader *)GetPtrAtomic(

CHECK:CAMELCASE: Avoid CamelCase: <RemoveBlock>
#452: FILE: mm/xvmalloc.c:295:
+static void RemoveBlock(struct Pool *pool, u32 pageNum, u32 offset,

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#459: FILE: mm/xvmalloc.c:302:
+	if (pool->FreeList[slIndex].pageNum == pageNum
+	   && pool->FreeList[slIndex].offset == offset) {

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#467: FILE: mm/xvmalloc.c:310:
+		tmpBlock = (struct BlockHeader *)GetPtrAtomic(

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#477: FILE: mm/xvmalloc.c:320:
+		tmpBlock = (struct BlockHeader *)GetPtrAtomic(

WARNING:RETURN_VOID: void function return statements are not generally useful
#487: FILE: mm/xvmalloc.c:330:
+	return;
+}

CHECK:CAMELCASE: Avoid CamelCase: <GrowPool>
#492: FILE: mm/xvmalloc.c:335:
+static int GrowPool(struct Pool *pool)

CHECK:CAMELCASE: Avoid CamelCase: <totalPages>
#501: FILE: mm/xvmalloc.c:344:
+	statInc(&pool->totalPages);

CHECK:CAMELCASE: Avoid CamelCase: <ovhdMem>
#526: FILE: mm/xvmalloc.c:369:
+	void *ovhdMem;

CHECK:CAMELCASE: Avoid CamelCase: <poolOvhd>
#528: FILE: mm/xvmalloc.c:371:
+	u32 poolOvhd;

CHECK:CAMELCASE: Avoid CamelCase: <tmpSize>
#569: FILE: mm/xvmalloc.c:412:
+	u32 index, tmpSize, origSize, tmpOffset;

CHECK:CAMELCASE: Avoid CamelCase: <origSize>
#569: FILE: mm/xvmalloc.c:412:
+	u32 index, tmpSize, origSize, tmpOffset;

CHECK:CAMELCASE: Avoid CamelCase: <tmpOffset>
#569: FILE: mm/xvmalloc.c:412:
+	u32 index, tmpSize, origSize, tmpOffset;

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#603: FILE: mm/xvmalloc.c:446:
+	block = (struct BlockHeader *)GetPtrAtomic(

WARNING:RETURN_VOID: void function return statements are not generally useful
#722: FILE: mm/xvmalloc.c:565:
+	return;
+}

CHECK:CAMELCASE: Avoid CamelCase: <xvMallocInit>
#747: FILE: mm/xvmalloc.c:590:
+static int __init xvMallocInit(void)

CHECK:CAMELCASE: Avoid CamelCase: <xvMallocExit>
#752: FILE: mm/xvmalloc.c:595:
+static void __exit xvMallocExit(void)

WARNING:RETURN_VOID: void function return statements are not generally useful
#755: FILE: mm/xvmalloc.c:598:
+	return;
+}

ERROR:EXECUTE_PERMISSIONS: do not set execute permissions for source files
#764: FILE: mm/xvmalloc_int.h

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#769: FILE: mm/xvmalloc_int.h:1:
+/*

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'y' - possible side-effects?
#786: FILE: mm/xvmalloc_int.h:18:
+#define ROUNDUP(x, y)	(((x) + (y) - 1) / (y) * (y))

CHECK:BIT_MACRO: Prefer using the BIT macro
#800: FILE: mm/xvmalloc_int.h:32:
+#define XV_ALIGN	(1 << XV_ALIGN_SHIFT)

Defines like: 1 << <digit> could be BIT(digit).
The BIT() macro is defined via include/linux/bits.h::

  #define BIT(nr)         (1UL << (nr))

CHECK:BIT_MACRO: Prefer using the BIT macro
#805: FILE: mm/xvmalloc_int.h:37:
+#define FL_DELTA	(1 << FL_DELTA_SHIFT)

CHECK:CAMELCASE: Avoid CamelCase: <FreeListEntry>
#821: FILE: mm/xvmalloc_int.h:53:
+struct FreeListEntry {

CHECK:CAMELCASE: Avoid CamelCase: <LinkFree>
#827: FILE: mm/xvmalloc_int.h:59:
+struct LinkFree {

CHECK:UNCOMMENTED_DEFINITION: spinlock_t definition without comment
#849: FILE: mm/xvmalloc_int.h:81:
+	spinlock_t lock;

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000153543.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 3 errors, 12 warnings, 68 checks, 753 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000153543.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
