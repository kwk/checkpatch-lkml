WARNING:FILE_PATH_CHANGES: added, moved or deleted file(s), does MAINTAINERS need updating?
#47: 
new file mode 100644

Whenever files are added, moved, or deleted, the MAINTAINERS file
patterns can be out of sync or outdated.

So MAINTAINERS might need updating in these cases.

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#52: FILE: drivers/target/target_core_configfs.c:1:
+/*******************************************************************************

The source file is missing or has an improper SPDX identifier tag.
The Linux kernel requires the precise SPDX identifier in all source files,
and it is thoroughly documented in the kernel docs.

See: https://www.kernel.org/doc/html/latest/process/license-rules.html

ERROR:CORRUPTED_PATCH: patch seems to be corrupt (line wrapped?)
#56: FILE: drivers/target/target_core_configfs.c:4:
project.

The patch seems to be corrupted or lines are wrapped.
Please regenerate the patch file before sending it to the maintainer.

CHECK:LINE_SPACING: Please don't use multiple blank lines
#76: FILE: drivers/target/target_core_configfs.c:23:
+
+

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#119: FILE: drivers/target/target_core_configfs.c:66:
+static ssize_t target_core_attr_show(struct config_item *item,
+				      struct configfs_attribute *attr,

WARNING:SPLIT_STRING: quoted string split across lines
#123: FILE: drivers/target/target_core_configfs.c:70:
+	return sprintf(page, "Target Engine Core ConfigFS Infrastructure %s"
+		" on %s/%s on "UTS_RELEASE"\n", TARGET_CORE_CONFIGFS_VERSION,

Quoted strings that appear as messages in userspace and can be
grepped, should not be split across multiple lines.

See: https://lore.kernel.org/lkml/20120203052727.GA15035@leaf/

CHECK:CONCATENATED_STRING: Concatenated strings should use spaces between elements
#123: FILE: drivers/target/target_core_configfs.c:70:
+		" on %s/%s on "UTS_RELEASE"\n", TARGET_CORE_CONFIGFS_VERSION,

Concatenated elements should have a space in between.
Example::

  printk(KERN_INFO"bar");

should be::

  printk(KERN_INFO "bar");

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRUGO' are not preferred. Consider using octal permissions '0444'.
#134: FILE: drivers/target/target_core_configfs.c:81:
+	.ca_mode	= S_IRUGO,

Permission bits in the octal form are more readable and easier to
understand than their symbolic counterparts because many command-line
tools use this notation. Experienced kernel developers have been using
these traditional Unix permission bits for decades and so they find it
easier to understand the octal notation than the symbolic macros.
For example, it is harder to read S_IWUSR|S_IRUGO than 0644, which
obscures the developer's intent rather than clarifying it.

See: https://lore.kernel.org/lkml/CA+55aFw5v23T-zvDZp-MmD_EYxF8WbafwwB59934FV7g21uMGQ@mail.gmail.com/

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#137: FILE: drivers/target/target_core_configfs.c:84:
+static struct target_fabric_configfs *target_core_get_fabric(

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#161: FILE: drivers/target/target_core_configfs.c:108:
+static struct config_group *target_core_register_fabric(

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#170: FILE: drivers/target/target_core_configfs.c:117:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> group: %p name:"

WARNING:SPLIT_STRING: quoted string split across lines
#171: FILE: drivers/target/target_core_configfs.c:118:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> group: %p name:"
+			" %s\n", group, name);

CHECK:ALLOC_SIZEOF_STRUCT: Prefer kzalloc(sizeof(*fabric_cg)...) over kzalloc(sizeof(struct config_group)...)
#173: FILE: drivers/target/target_core_configfs.c:120:
+	fabric_cg = kzalloc(sizeof(struct config_group), GFP_KERNEL);

The allocation style is bad.  In general for family of
allocation functions using sizeof() to get memory size,
constructs like::

  p = alloc(sizeof(struct foo), ...)

should be::

  p = alloc(sizeof(*p), ...)

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#allocating-memory

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#183: FILE: drivers/target/target_core_configfs.c:130:
+			printk(KERN_ERR "request_module() failed for"

WARNING:SPLIT_STRING: quoted string split across lines
#184: FILE: drivers/target/target_core_configfs.c:131:
+			printk(KERN_ERR "request_module() failed for"
+				" iscsi_target_mod.ko: %d\n", ret);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#189: FILE: drivers/target/target_core_configfs.c:136:
+		printk(KERN_ERR "Unsupported configfs target fabric %s\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#190: FILE: drivers/target/target_core_configfs.c:137:
+		printk(KERN_ERR "Unsupported configfs target fabric %s\n",
+			name);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#197: FILE: drivers/target/target_core_configfs.c:144:
+		printk(KERN_ERR "target_core_get_fabric() failed for %s\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#198: FILE: drivers/target/target_core_configfs.c:145:
+		printk(KERN_ERR "target_core_get_fabric() failed for %s\n",
+			name);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#202: FILE: drivers/target/target_core_configfs.c:149:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> Located fabric:"

WARNING:SPLIT_STRING: quoted string split across lines
#203: FILE: drivers/target/target_core_configfs.c:150:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> Located fabric:"
+			" %s\n", tf->tf_name);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#208: FILE: drivers/target/target_core_configfs.c:155:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> %p\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#209: FILE: drivers/target/target_core_configfs.c:156:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> %p\n",
+			tf->tf_fabric_cit);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#211: FILE: drivers/target/target_core_configfs.c:158:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> Allocated Fabric:"

WARNING:SPLIT_STRING: quoted string split across lines
#212: FILE: drivers/target/target_core_configfs.c:159:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> Allocated Fabric:"
+			" %s\n", tf->tf_group.cg_item.ci_name);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#215: FILE: drivers/target/target_core_configfs.c:162:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> Set tf->tf_fabric"

WARNING:SPLIT_STRING: quoted string split across lines
#216: FILE: drivers/target/target_core_configfs.c:163:
+	printk(KERN_INFO "Target_Core_ConfigFS: REGISTER -> Set tf->tf_fabric"
+			" for %s\n", name);

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#224: FILE: drivers/target/target_core_configfs.c:171:
+static void target_core_deregister_fabric(

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#228: FILE: drivers/target/target_core_configfs.c:175:
+	struct target_fabric_configfs *tf = container_of(

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#231: FILE: drivers/target/target_core_configfs.c:178:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Looking up %s

WARNING:UNNECESSARY_MODIFIER: Integer promotion: Using 'h' in '%hu' is unnecessary
#231: FILE: drivers/target/target_core_configfs.c:178:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Looking up %s
in"
+		" tf list\n", config_item_name(item));
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> located fabric:"
+			" %s\n", tf->tf_name);
+	atomic_dec(&tf->tf_access_cnt);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing"
+			" tf->tf_fabric for %s\n", tf->tf_name);
+	tf->tf_fabric = NULL;
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing ci"
+			" %s\n", config_item_name(item));
+	config_item_put(item);
+}
+
+static struct configfs_group_operations target_core_group_ops = {
+	.make_group	= &target_core_register_fabric,
+	.drop_item	= &target_core_deregister_fabric,
+};
+
+/*
+ * All item attributes appearing in /sys/kernel/target/ appear here.
+ */
+static struct configfs_attribute *target_core_item_attrs[] = {
+	&target_core_item_attr_version,
+	NULL,
+};
+
+/*
+ * Provides Fabrics Groups and Item Attributes
for /sys/kernel/config/target/
+ */
+static struct config_item_type target_core_fabrics_item = {
+	.ct_item_ops	= &target_core_item_ops,
+	.ct_group_ops	= &target_core_group_ops,
+	.ct_attrs	= target_core_item_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct configfs_subsystem target_core_fabrics = {
+	.su_group = {
+		.cg_item = {
+			.ci_namebuf = "target",
+			.ci_type = &target_core_fabrics_item,
+		},
+	},
+};
+
+static struct configfs_subsystem *target_core_subsystem[] = {
+	&target_core_fabrics,
+	NULL,
+};
+
+/*##############################################################################
+// Start functions called by external Target Fabrics Modules
+//############################################################################*/
+
+/*
+ * First function called by fabric modules to:
+ *
+ * 1) Allocate a struct target_fabric_configfs and save the *fabric_cit
pointer.
+ * 2) Add struct target_fabric_configfs to g_tf_list
+ * 3) Return struct target_fabric_configfs to fabric module to be
passed
+ *    into target_fabric_configfs_register().
+ */
+struct target_fabric_configfs *target_fabric_configfs_init(
+	struct config_item_type *fabric_cit,
+	const char *name)
+{
+	struct target_fabric_configfs *tf;
+
+	if (!(fabric_cit)) {
+		printk(KERN_ERR "Missing struct config_item_type * pointer\n");
+		return NULL;
+	}
+	if (!(name)) {
+		printk(KERN_ERR "Unable to locate passed fabric name\n");
+		return NULL;
+	}
+	if (strlen(name) > TARGET_FABRIC_NAME_SIZE) {
+		printk(KERN_ERR "Passed name: %s exceeds TARGET_FABRIC"
+			"_NAME_SIZE\n", name);
+		return NULL;
+	}
+
+	tf = kzalloc(sizeof(struct target_fabric_configfs), GFP_KERNEL);
+	if (!(tf))
+		return ERR_PTR(-ENOMEM);
+
+	INIT_LIST_HEAD(&tf->tf_list);
+	atomic_set(&tf->tf_access_cnt, 0);
+	tf->tf_fabric_cit = fabric_cit;
+	tf->tf_subsys = target_core_subsystem[0];
+	snprintf(tf->tf_name, TARGET_FABRIC_NAME_SIZE, "%s", name);
+
+	mutex_lock(&g_tf_lock);
+	list_add_tail(&tf->tf_list, &g_tf_list);
+	mutex_unlock(&g_tf_lock);
+
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
+			">>>>>>>>>>>>>>\n");
+	printk(KERN_INFO "Initialized struct target_fabric_configfs: %p for"
+			" %s\n", tf, tf->tf_name);
+	return tf;
+}
+EXPORT_SYMBOL(target_fabric_configfs_init);
+
+/*
+ * Called by fabric plugins after FAILED
target_fabric_configfs_register() call.
+ */
+void target_fabric_configfs_free(
+	struct target_fabric_configfs *tf)
+{
+	mutex_lock(&g_tf_lock);
+	list_del(&tf->tf_list);
+	mutex_unlock(&g_tf_lock);
+
+	kfree(tf);
+}
+EXPORT_SYMBOL(target_fabric_configfs_free);
+
+/*
+ * Note that config_group_find_item() calls config_item_get() and grabs
the
+ * reference to the returned struct config_item *
+ * It will be released with config_put_item() in
+ * target_fabric_configfs_deregister()
+ */
+struct config_item *target_fabric_configfs_find_by_name(
+	struct configfs_subsystem *target_su,
+	const char *name)
+{
+	struct config_item *fabric;
+
+	mutex_lock(&target_su->su_mutex);
+	fabric = config_group_find_item(&target_su->su_group, name);
+	mutex_unlock(&target_su->su_mutex);
+
+	return fabric;
+}
+
+/*
+ * Called 2nd from fabric module with returned parameter of
+ * struct target_fabric_configfs * from target_fabric_configfs_init().
+ *
+ * Upon a successful registration, the new fabric's struct config_item
is
+ * return.  Also, a pointer to this struct is set in the passed
+ * struct target_fabric_configfs.
+ */
+int target_fabric_configfs_register(
+	struct target_fabric_configfs *tf)
+{
+	struct config_group *su_group;
+
+	if (!(tf)) {
+		printk(KERN_ERR "Unable to locate target_fabric_configfs"
+			" pointer\n");
+		return -EINVAL;
+	}
+	if (!(tf->tf_subsys)) {
+		printk(KERN_ERR "Unable to target struct config_subsystem"
+			" pointer\n");
+		return -EINVAL;
+	}
+	su_group = &tf->tf_subsys->su_group;
+	if (!(su_group)) {
+		printk(KERN_ERR "Unable to locate target struct config_group"
+			" pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
+		">>>>>>>>>>\n");
+	return 0;
+}
+EXPORT_SYMBOL(target_fabric_configfs_register);
+
+void target_fabric_configfs_deregister(
+	struct target_fabric_configfs *tf)
+{
+	struct config_group *su_group;
+	struct configfs_subsystem *su;
+
+	if (!(tf)) {
+		printk(KERN_ERR "Unable to locate passed target_fabric_"
+			"configfs\n");
+		return;
+	}
+	su = tf->tf_subsys;
+	if (!(su)) {
+		printk(KERN_ERR "Unable to locate passed tf->tf_subsys"
+			" pointer\n");
+		return;
+	}
+	su_group = &tf->tf_subsys->su_group;
+	if (!(su_group)) {
+		printk(KERN_ERR "Unable to locate target struct config_group"
+			" pointer\n");
+		return;
+	}
+
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
+			">>>>>>>>>>>>\n");
+	mutex_lock(&g_tf_lock);
+	if (atomic_read(&tf->tf_access_cnt)) {
+		mutex_unlock(&g_tf_lock);
+		printk(KERN_ERR "Non zero tf->tf_access_cnt for fabric %s\n",
+			tf->tf_name);
+		BUG();
+	}
+	list_del(&tf->tf_list);
+	mutex_unlock(&g_tf_lock);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing tf:"
+			" %s\n", tf->tf_name);
+	tf->tf_fabric_cit = NULL;
+	tf->tf_subsys = NULL;
+	kfree(tf);
+
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
+			">>>>>\n");
+	return;
+}
+EXPORT_SYMBOL(target_fabric_configfs_deregister);
+
+/*##############################################################################
+// Stop functions called by external Target Fabrics Modules
+//############################################################################*/
+
+/* Start functions for struct config_item_type
target_core_dev_attrib_cit */
+
+#define DEF_DEV_ATTRIB_SHOW(_name)					\
+static ssize_t target_core_dev_show_attr_##_name(			\
+	struct se_dev_attrib_s *da,					\
+	char *page)							\
+{									\
+	se_device_t *dev;						\
+	se_subsystem_dev_t *se_dev = da->da_sub_dev;			\
+	ssize_t rb;							\
+									\
+	spin_lock(&se_dev->se_dev_lock);				\
+	dev = se_dev->se_dev_ptr;					\
+	if (!(dev)) {							\
+		spin_unlock(&se_dev->se_dev_lock); 			\
+		return -ENODEV;						\
+	}								\
+	rb = snprintf(page, PAGE_SIZE, "%u\n", (u32)DEV_ATTRIB(dev)->_name); \
+	spin_unlock(&se_dev->se_dev_lock);				\
+									\
+	return rb;							\
+}
+
+#define DEF_DEV_ATTRIB_STORE(_name)					\
+static ssize_t target_core_dev_store_attr_##_name(			\
+	struct se_dev_attrib_s *da,					\
+	const char *page,						\
+	size_t count)							\
+{									\
+	se_device_t *dev;						\
+	se_subsystem_dev_t *se_dev = da->da_sub_dev;			\
+	unsigned long val;						\
+	int ret;							\
+									\
+	spin_lock(&se_dev->se_dev_lock);				\
+	dev = se_dev->se_dev_ptr;					\
+	if (!(dev)) {							\
+		spin_unlock(&se_dev->se_dev_lock);			\
+		return -ENODEV;						\
+	}								\
+	ret = strict_strtoul(page, 0, &val);				\
+	if (ret < 0) {							\
+		printk(KERN_ERR "strict_strtoul() failed with"		\
+			" ret: %d\n", ret);				\
+		return -EINVAL;						\
+	}								\
+	ret = se_dev_set_##_name(dev, (u32)val);			\
+	spin_unlock(&se_dev->se_dev_lock);				\
+									\
+	return (!ret) ? count : -EINVAL;				\
+}
+
+#define DEF_DEV_ATTRIB(_name)						\
+DEF_DEV_ATTRIB_SHOW(_name);						\
+DEF_DEV_ATTRIB_STORE(_name);
+
+#define DEF_DEV_ATTRIB_RO(_name)					\
+DEF_DEV_ATTRIB_SHOW(_name);
+
+CONFIGFS_EATTR_STRUCT(target_core_dev_attrib, se_dev_attrib_s);
+#define SE_DEV_ATTR(_name, _mode)					\
+static struct target_core_dev_attrib_attribute				\
+			target_core_dev_attrib_##_name =		\
+		__CONFIGFS_EATTR(_name, _mode,				\
+		target_core_dev_show_attr_##_name,			\
+		target_core_dev_store_attr_##_name);
+
+#define SE_DEV_ATTR_RO(_name);						\
+static struct target_core_dev_attrib_attribute				\
+			target_core_dev_attrib_##_name =		\
+		__CONFIGFS_EATTR_RO(_name,				\
+		target_core_dev_show_attr_##_name);
+
+DEF_DEV_ATTRIB(emulate_ua_intlck_ctrl);
+SE_DEV_ATTR(emulate_ua_intlck_ctrl, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB(emulate_tas);
+SE_DEV_ATTR(emulate_tas, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB_RO(hw_block_size);
+SE_DEV_ATTR_RO(hw_block_size);
+
+DEF_DEV_ATTRIB(block_size);
+SE_DEV_ATTR(block_size, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB_RO(hw_max_sectors);
+SE_DEV_ATTR_RO(hw_max_sectors);
+
+DEF_DEV_ATTRIB(max_sectors);
+SE_DEV_ATTR(max_sectors, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB_RO(hw_queue_depth);
+SE_DEV_ATTR_RO(hw_queue_depth);
+
+DEF_DEV_ATTRIB(queue_depth);
+SE_DEV_ATTR(queue_depth, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB(task_timeout);
+SE_DEV_ATTR(task_timeout, S_IRUGO | S_IWUSR);
+
+CONFIGFS_EATTR_OPS(target_core_dev_attrib, se_dev_attrib_s, da_group);
+
+static struct configfs_attribute *target_core_dev_attrib_attrs[] = {
+	&target_core_dev_attrib_emulate_ua_intlck_ctrl.attr,
+	&target_core_dev_attrib_emulate_tas.attr,
+	&target_core_dev_attrib_hw_block_size.attr,
+	&target_core_dev_attrib_block_size.attr,
+	&target_core_dev_attrib_hw_max_sectors.attr,
+	&target_core_dev_attrib_max_sectors.attr,
+	&target_core_dev_attrib_hw_queue_depth.attr,
+	&target_core_dev_attrib_queue_depth.attr,
+	&target_core_dev_attrib_task_timeout.attr,
+	NULL,
+};
+
+static struct configfs_item_operations target_core_dev_attrib_ops = {
+	.show_attribute		= target_core_dev_attrib_attr_show,
+	.store_attribute	= target_core_dev_attrib_attr_store,
+};
+
+static struct config_item_type target_core_dev_attrib_cit = {
+	.ct_item_ops		= &target_core_dev_attrib_ops,
+	.ct_attrs		= target_core_dev_attrib_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/* End functions for struct config_item_type target_core_dev_attrib_cit
*/
+
+/*  Start functions for struct config_item_type target_core_dev_wwn_cit
*/
+
+CONFIGFS_EATTR_STRUCT(target_core_dev_wwn, t10_wwn_s);
+#define SE_DEV_WWN_ATTR(_name, _mode)					\
+static struct target_core_dev_wwn_attribute target_core_dev_wwn_##_name
= \
+		__CONFIGFS_EATTR(_name, _mode,				\
+		target_core_dev_wwn_show_attr_##_name,			\
+		target_core_dev_wwn_store_attr_##_name);
+
+#define SE_DEV_WWN_ATTR_RO(_name);					\
+static struct target_core_dev_wwn_attribute target_core_dev_wwn_##_name
= \
+		__CONFIGFS_EATTR_RO(_name,				\
+		target_core_dev_wwn_show_attr_##_name);
+
+/*
+ * VPD page 0x80 Unit serial
+ */
+static ssize_t target_core_dev_wwn_show_attr_vpd_unit_serial(
+	struct t10_wwn_s *t10_wwn,
+	char *page)
+{
+	se_subsystem_dev_t *se_dev = t10_wwn->t10_sub_dev;
+	se_device_t *dev;
+
+	dev = se_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	return sprintf(page, "T10 VPD Unit Serial Number: %s\n",
+		&t10_wwn->unit_serial[0]);
+}
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_unit_serial(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	se_subsystem_dev_t *su_dev = t10_wwn->t10_sub_dev;
+	se_device_t *dev;
+	unsigned char buf[INQUIRY_VPD_SERIAL_LEN];
+
+	/*
+	 * If Linux/SCSI subsystem_api_t plugin got a VPD Unit Serial
+	 * from the struct scsi_device level firmware, do not allow
+	 * VPD Unit Serial to be emulated.
+	 *
+	 * Note this struct scsi_device could also be emulating VPD
+	 * information from its drivers/scsi LLD.  But for now we assume
+	 * it is doing 'the right thing' wrt a world wide unique
+	 * VPD Unit Serial Number that OS dependent multipath can depend on.
+	 */
+	if (su_dev->su_dev_flags & SDF_FIRMWARE_VPD_UNIT_SERIAL) {
+		printk(KERN_ERR "Underlying SCSI device firmware provided VPD"
+			" Unit Serial, ignoring request\n");
+		return -EOPNOTSUPP;
+	}
+
+	if ((strlen(page) + 1) > INQUIRY_VPD_SERIAL_LEN) {
+		printk(KERN_ERR "Emulated VPD Unit Serial exceeds"
+		" INQUIRY_VPD_SERIAL_LEN: %d\n", INQUIRY_VPD_SERIAL_LEN);
+		return -EOVERFLOW;
+	}
+	/*
+	 * Check to see if any active $FABRIC_MOD exports exist.  If they
+	 * do exist, fail here as changing this information on the fly
+	 * (underneath the initiator side OS dependent multipath code)
+	 * could cause negative effects.
+	 */
+	dev = su_dev->se_dev_ptr;
+	if ((dev)) {
+		if (DEV_OBJ_API(dev)->check_count(&dev->dev_export_obj)) {
+			printk(KERN_ERR "Unable to set VPD Unit Serial while"
+				" active %d $FABRIC_MOD exports exist\n",
+				DEV_OBJ_API(dev)->check_count(
+					&dev->dev_export_obj));
+			return -EINVAL;
+		}
+	}
+	/*
+	 * This currently assumes ASCII encoding for emulated VPD Unit Serial.
+	 *
+	 * Also, strip any newline added from the userspace
+	 * echo $UUID > $TARGET/$HBA/$STORAGE_OBJECT/wwn/vpd_unit_serial
+	 */
+	memset(buf, 0, INQUIRY_VPD_SERIAL_LEN);
+	snprintf(buf, INQUIRY_VPD_SERIAL_LEN, "%s", page);
+	snprintf(su_dev->t10_wwn.unit_serial, INQUIRY_VPD_SERIAL_LEN,
+			"%s", strstrip(buf));
+	su_dev->su_dev_flags |= SDF_EMULATED_VPD_UNIT_SERIAL;
+
+	printk(KERN_INFO "Target_Core_ConfigFS: Set emulated VPD Unit Serial:"
+			" %s\n", su_dev->t10_wwn.unit_serial);
+	return count;
+}
+
+SE_DEV_WWN_ATTR(vpd_unit_serial, S_IRUGO | S_IWUSR);
+
+/*
+ * VPD page 0x83 Protocol Identifier
+ */
+static ssize_t target_core_dev_wwn_show_attr_vpd_protocol_identifier(
+	struct t10_wwn_s *t10_wwn,
+	char *page)
+{
+	se_subsystem_dev_t *se_dev = t10_wwn->t10_sub_dev;
+	se_device_t *dev;
+	t10_vpd_t *vpd;
+	unsigned char buf[VPD_TMP_BUF_SIZE];
+	ssize_t len = 0;
+
+	dev = se_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	memset(buf, 0, VPD_TMP_BUF_SIZE);
+
+	spin_lock(&t10_wwn->t10_vpd_lock);
+	list_for_each_entry(vpd, &t10_wwn->t10_vpd_list, vpd_list) {
+		if (!(vpd->protocol_identifier_set))
+			continue;
+
+		transport_dump_vpd_proto_id(vpd, buf, VPD_TMP_BUF_SIZE);
+
+		if ((len + strlen(buf) > PAGE_SIZE))
+			break;
+
+		len += sprintf(page+len, "%s", buf);
+	}
+	spin_unlock(&t10_wwn->t10_vpd_lock);
+
+	return len;
+}
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_protocol_identifier(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_protocol_identifier, S_IRUGO | S_IWUSR);
+
+/*
+ * Generic wrapper for dumping VPD identifiers by association.
+ */
+#define DEF_DEV_WWN_ASSOC_SHOW(_name, _assoc)				\
+static ssize_t target_core_dev_wwn_show_attr_##_name(			\
+	struct t10_wwn_s *t10_wwn,					\
+	char *page)							\
+{									\
+	se_subsystem_dev_t *se_dev = t10_wwn->t10_sub_dev;		\
+	se_device_t *dev;						\
+	t10_vpd_t *vpd;							\
+	unsigned char buf[VPD_TMP_BUF_SIZE];				\
+	ssize_t len = 0;						\
+									\
+	dev = se_dev->se_dev_ptr;					\
+	if (!(dev))							\
+		return -ENODEV;						\
+									\
+	spin_lock(&t10_wwn->t10_vpd_lock);				\
+	list_for_each_entry(vpd, &t10_wwn->t10_vpd_list, vpd_list) {	\
+		if (vpd->association != _assoc)				\
+			continue;					\
+									\
+		memset(buf, 0, VPD_TMP_BUF_SIZE);			\
+		transport_dump_vpd_assoc(vpd, buf, VPD_TMP_BUF_SIZE);	\
+		if ((len + strlen(buf) > PAGE_SIZE))			\
+			break;						\
+		len += sprintf(page+len, "%s", buf);			\
+									\
+		memset(buf, 0, VPD_TMP_BUF_SIZE);			\
+		transport_dump_vpd_ident_type(vpd, buf, VPD_TMP_BUF_SIZE); \
+		if ((len + strlen(buf) > PAGE_SIZE))			\
+			break;						\
+		len += sprintf(page+len, "%s", buf);			\
+									\
+		memset(buf, 0, VPD_TMP_BUF_SIZE);			\
+		transport_dump_vpd_ident(vpd, buf, VPD_TMP_BUF_SIZE); \
+		if ((len + strlen(buf) > PAGE_SIZE))			\
+			break;						\
+		len += sprintf(page+len, "%s", buf);			\
+	}								\
+	spin_unlock(&t10_wwn->t10_vpd_lock);				\
+									\
+	return len;							\
+}
+
+/*
+ * VPD page 0x83 Assoication: Logical Unit
+ */
+DEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_logical_unit, 0x00);
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_assoc_logical_unit(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_assoc_logical_unit, S_IRUGO | S_IWUSR);
+
+/*
+ * VPD page 0x83 Association: Target Port
+ */
+DEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_target_port, 0x10);
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_assoc_target_port(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_assoc_target_port, S_IRUGO | S_IWUSR);
+
+/*
+ * VPD page 0x83 Association: SCSI Target Device
+ */
+DEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_scsi_target_device, 0x20);
+
+static ssize_t
target_core_dev_wwn_store_attr_vpd_assoc_scsi_target_device(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_assoc_scsi_target_device, S_IRUGO | S_IWUSR);
+
+CONFIGFS_EATTR_OPS(target_core_dev_wwn, t10_wwn_s, t10_wwn_group);
+
+static struct configfs_attribute *target_core_dev_wwn_attrs[] = {
+	&target_core_dev_wwn_vpd_unit_serial.attr,
+	&target_core_dev_wwn_vpd_protocol_identifier.attr,
+	&target_core_dev_wwn_vpd_assoc_logical_unit.attr,
+	&target_core_dev_wwn_vpd_assoc_target_port.attr,
+	&target_core_dev_wwn_vpd_assoc_scsi_target_device.attr,
+	NULL,
+};
+
+static struct configfs_item_operations target_core_dev_wwn_ops = {
+	.show_attribute		= target_core_dev_wwn_attr_show,
+	.store_attribute	= target_core_dev_wwn_attr_store,
+};
+
+static struct config_item_type target_core_dev_wwn_cit = {
+	.ct_item_ops		= &target_core_dev_wwn_ops,
+	.ct_attrs		= target_core_dev_wwn_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/*  End functions for struct config_item_type target_core_dev_wwn_cit
*/
+
+/*  Start functions for struct config_item_type target_core_dev_pr_cit
*/
+
+CONFIGFS_EATTR_STRUCT(target_core_dev_pr, se_subsystem_dev_s);
+#define SE_DEV_PR_ATTR(_name, _mode)					\
+static struct target_core_dev_pr_attribute target_core_dev_pr_##_name =
\
+	__CONFIGFS_EATTR(_name, _mode,					\
+	target_core_dev_wwn_show_attr_##_name,				\
+	target_core_dev_wwn_store_attr_##_name);
+
+#define SE_DEV_PR_ATTR_RO(_name);					\
+static struct target_core_dev_pr_attribute target_core_dev_pr_##_name =
\
+	__CONFIGFS_EATTR_RO(_name,					\
+	target_core_dev_pr_show_attr_##_name);				\
+
+/*
+ * res_holder
+ */
+static ssize_t target_core_dev_pr_show_spc3_res(
+	struct se_device_s *dev,
+	char *page,
+	ssize_t *len)
+{
+	se_node_acl_t *se_nacl;
+	t10_pr_registration_t *pr_reg;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		*len += sprintf(page + *len, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return *len;
+	}
+	se_nacl = pr_reg->pr_reg_nacl;
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",
+		TPG_TFO(se_nacl->se_tpg)->get_fabric_name(),
+		se_nacl->initiatorname);
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return *len;
+}
+
+static ssize_t target_core_dev_pr_show_spc2_res(
+	struct se_device_s *dev,
+	char *page,
+	ssize_t *len)
+{
+	se_node_acl_t *se_nacl;
+
+	spin_lock(&dev->dev_reservation_lock);
+	se_nacl = dev->dev_reserved_node_acl;
+	if (!(se_nacl)) {
+		*len += sprintf(page + *len, "No SPC-2 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return *len;
+	}
+	*len += sprintf(page + *len, "SPC-2 Reservation: %s Initiator: %s\n",
+		TPG_TFO(se_nacl->se_tpg)->get_fabric_name(),
+		se_nacl->initiatorname);
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return *len;
+}
+
+static ssize_t target_core_dev_pr_show_attr_res_holder(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	ssize_t len = 0;
+
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	switch (T10_RES(su_dev)->res_type) {
+	case SPC3_PERSISTENT_RESERVATIONS:
+		target_core_dev_pr_show_spc3_res(su_dev->se_dev_ptr,
+				page, &len);
+		break;
+	case SPC2_RESERVATIONS:
+		target_core_dev_pr_show_spc2_res(su_dev->se_dev_ptr,
+				page, &len);
+		break;
+	case SPC_PASSTHROUGH:
+		len += sprintf(page+len, "Passthrough\n");
+		break;
+	default:
+		len += sprintf(page+len, "Unknown\n");
+		break;
+	}
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_holder);
+
+/*
+ * res_pr_all_tgt_pts
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_all_tgt_pts(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	se_device_t *dev;
+	t10_pr_registration_t *pr_reg;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return len;
+	}
+	/*
+	 * See All Target Ports (ALL_TG_PT) bit in spcr17, section 6.14.3
+	 * Basic PERSISTENT RESERVER OUT parameter list, page 290
+	 */
+	if (pr_reg->pr_reg_all_tg_pt)
+		len = sprintf(page, "SPC-3 Reservation: All Target"
+			" Ports registration\n");
+	else
+		len = sprintf(page, "SPC-3 Reservation: Single"
+			" Target Port registration\n");
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_all_tgt_pts);
+
+/*
+ * res_pr_generation
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_generation(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return 0;
+
+	return sprintf(page, "0x%08x\n", T10_RES(su_dev)->pr_generation);
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_generation);
+
+/*
+ * res_pr_holder_tg_port
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_holder_tg_port(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	se_device_t *dev;
+	se_node_acl_t *se_nacl;
+	se_lun_t *lun;
+	se_portal_group_t *se_tpg;
+	t10_pr_registration_t *pr_reg;
+	struct target_core_fabric_ops *tfo;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return len;
+	}
+	se_nacl = pr_reg->pr_reg_nacl;
+	se_tpg = se_nacl->se_tpg;
+	lun = pr_reg->pr_reg_tg_pt_lun;
+	tfo = TPG_TFO(se_tpg);
+
+	len += sprintf(page+len, "SPC-3 Reservation: %s"
+		" Target Node Endpoint: %s\n", tfo->get_fabric_name(),
+		tfo->tpg_get_wwn(se_tpg));
+	len += sprintf(page+len, "SPC-3 Reservation: Relative Port"
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
+		" %s Logical Unit: %u\n", lun->lun_sep->sep_rtpi,
+		tfo->get_fabric_name(), tfo->tpg_get_tag(se_tpg),
+		tfo->get_fabric_name(), lun->unpacked_lun);
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_holder_tg_port);
+
+/*
+ * res_pr_registered_i_pts
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_registered_i_pts(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	struct target_core_fabric_ops *tfo;
+	t10_pr_registration_t *pr_reg;
+	unsigned char buf[384];
+	ssize_t len = 0;
+	int reg_count = 0;
+
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	len += sprintf(page+len, "SPC-3 PR Registrations:\n");
+
+	spin_lock(&T10_RES(su_dev)->registration_lock);
+	list_for_each_entry(pr_reg, &T10_RES(su_dev)->registration_list,
+			pr_reg_list) {
+
+		memset(buf, 0, 384);
+		tfo = pr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
+			tfo->get_fabric_name(),
+			pr_reg->pr_reg_nacl->initiatorname,
+			pr_reg->pr_res_key, pr_reg->pr_res_generation);
+
+		if ((len + strlen(buf) > PAGE_SIZE))
+			break;
+
+		len += sprintf(page+len, "%s", buf);
+		reg_count++;
+	}
+	spin_unlock(&T10_RES(su_dev)->registration_lock);
+
+	if (!(reg_count))
+		len += sprintf(page+len, "None\n");
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_registered_i_pts);
+
+/*
+ * res_pr_type
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_type(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	se_device_t *dev;
+	t10_pr_registration_t *pr_reg;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return len;
+	}
+	len = sprintf(page, "SPC-3 Reservation Type: %s\n",
+		core_scsi3_pr_dump_type(pr_reg->pr_res_type));
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_type);
+
+/*
+ * res_type
+ */
+static ssize_t target_core_dev_pr_show_attr_res_type(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	ssize_t len = 0;
+
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	switch (T10_RES(su_dev)->res_type) {
+	case SPC3_PERSISTENT_RESERVATIONS:
+		len = sprintf(page, "SPC3_PERSISTENT_RESERVATIONS\n");
+		break;
+	case SPC2_RESERVATIONS:
+		len = sprintf(page, "SPC2_RESERVATIONS\n");
+		break;
+	case SPC_PASSTHROUGH:
+		len = sprintf(page, "SPC_PASSTHROUGH\n");
+		break;
+	default:
+		len = sprintf(page, "UNKNOWN\n");
+		break;
+	}
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_type);
+
+CONFIGFS_EATTR_OPS(target_core_dev_pr, se_subsystem_dev_s,
se_dev_pr_group);
+
+static struct configfs_attribute *target_core_dev_pr_attrs[] = {
+	&target_core_dev_pr_res_holder.attr,
+	&target_core_dev_pr_res_pr_all_tgt_pts.attr,
+	&target_core_dev_pr_res_pr_generation.attr,
+	&target_core_dev_pr_res_pr_holder_tg_port.attr,
+	&target_core_dev_pr_res_pr_registered_i_pts.attr,
+	&target_core_dev_pr_res_pr_type.attr,
+	&target_core_dev_pr_res_type.attr,
+	NULL,
+};
+
+static struct configfs_item_operations target_core_dev_pr_ops = {
+	.show_attribute		= target_core_dev_pr_attr_show,
+	.store_attribute	= target_core_dev_pr_attr_store,
+};
+
+static struct config_item_type target_core_dev_pr_cit = {
+	.ct_item_ops		= &target_core_dev_pr_ops,
+	.ct_attrs		= target_core_dev_pr_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/*  End functions for struct config_item_type target_core_dev_pr_cit */
+
+/*  Start functions for struct config_item_type target_core_dev_cit */
+
+static ssize_t target_core_show_dev_info(void *p, char *page)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	int ret = 0, bl = 0;
+	ssize_t read_bytes = 0;
+
+	t = (se_subsystem_api_t *)plugin_get_obj(PLUGIN_TYPE_TRANSPORT,
+			hba->type, &ret);
+	if (!t || (ret != 0))
+		return 0;
+
+	if (se_dev->se_dev_ptr) {
+		transport_dump_dev_state(se_dev->se_dev_ptr, page, &bl);
+		read_bytes += bl;
+	}
+
+	read_bytes += t->show_configfs_dev_params(hba, se_dev, page
+read_bytes);
+	return read_bytes;
+}
+
+static struct target_core_configfs_attribute target_core_attr_dev_info
= {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "info",
+		    .ca_mode = S_IRUGO },
+	.show	= target_core_show_dev_info,
+	.store	= NULL,
+};
+
+static ssize_t target_core_store_dev_control(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	int ret = 0;
+
+	if (!(se_dev->se_dev_su_ptr)) {
+		printk(KERN_ERR "Unable to locate se_subsystem_dev_t>se"
+				"_dev_su_ptr\n");
+		return -EINVAL;
+	}
+
+	t = (se_subsystem_api_t *)plugin_get_obj(PLUGIN_TYPE_TRANSPORT,
+			hba->type, &ret);
+	if (!t || (ret != 0))
+		return -EINVAL;
+
+	return t->set_configfs_dev_params(hba, se_dev, page, count);
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_control = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "control",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_control,
+};
+
+static ssize_t target_core_store_dev_fd(void *p, const char *page,
size_t count)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_device_t *dev;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	int ret = 0;
+
+	if (se_dev->se_dev_ptr) {
+		printk(KERN_ERR "se_dev->se_dev_ptr already set, ignoring"
+			" fd request\n");
+		return -EEXIST;
+	}
+
+	t = (se_subsystem_api_t *)plugin_get_obj(PLUGIN_TYPE_TRANSPORT,
+			hba->type, &ret);
+	if (!t || (ret != 0))
+		return -EINVAL;
+
+	if (!(t->create_virtdevice_from_fd)) {
+		printk(KERN_ERR "se_subsystem_api_t->create_virtdevice_from"
+			"_fd() NULL for: %s\n", hba->transport->name);
+		return -EINVAL;
+	}
+	/*
+	 * The subsystem PLUGIN is responsible for calling target_core_mod
+	 * symbols to claim the underlying struct block_device for TYPE_DISK.
+	 */
+	dev = t->create_virtdevice_from_fd(se_dev, page);
+	if (!(dev) || IS_ERR(dev))
+		goto out;
+
+	se_dev->se_dev_ptr = dev;
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered %s se_dev->se_dev"
+		"_ptr: %p from fd\n", hba->transport->name, se_dev->se_dev_ptr);
+	return count;
+out:
+	return -EINVAL;
+}
+
+static struct target_core_configfs_attribute target_core_attr_dev_fd =
{
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "fd",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_fd,
+};
+
+static ssize_t target_core_store_dev_enable(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_device_t *dev;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	char *ptr;
+	int ret = 0;
+
+	ptr = strstr(page, "1");
+	if (!(ptr)) {
+		printk(KERN_ERR "For dev_enable ops, only valid value"
+				" is \"1\"\n");
+		return -EINVAL;
+	}

WARNING:UNNECESSARY_MODIFIER: Integer promotion: Using 'h' in '%hu' is unnecessary
#231: FILE: drivers/target/target_core_configfs.c:178:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Looking up %s
in"
+		" tf list\n", config_item_name(item));
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> located fabric:"
+			" %s\n", tf->tf_name);
+	atomic_dec(&tf->tf_access_cnt);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing"
+			" tf->tf_fabric for %s\n", tf->tf_name);
+	tf->tf_fabric = NULL;
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing ci"
+			" %s\n", config_item_name(item));
+	config_item_put(item);
+}
+
+static struct configfs_group_operations target_core_group_ops = {
+	.make_group	= &target_core_register_fabric,
+	.drop_item	= &target_core_deregister_fabric,
+};
+
+/*
+ * All item attributes appearing in /sys/kernel/target/ appear here.
+ */
+static struct configfs_attribute *target_core_item_attrs[] = {
+	&target_core_item_attr_version,
+	NULL,
+};
+
+/*
+ * Provides Fabrics Groups and Item Attributes
for /sys/kernel/config/target/
+ */
+static struct config_item_type target_core_fabrics_item = {
+	.ct_item_ops	= &target_core_item_ops,
+	.ct_group_ops	= &target_core_group_ops,
+	.ct_attrs	= target_core_item_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct configfs_subsystem target_core_fabrics = {
+	.su_group = {
+		.cg_item = {
+			.ci_namebuf = "target",
+			.ci_type = &target_core_fabrics_item,
+		},
+	},
+};
+
+static struct configfs_subsystem *target_core_subsystem[] = {
+	&target_core_fabrics,
+	NULL,
+};
+
+/*##############################################################################
+// Start functions called by external Target Fabrics Modules
+//############################################################################*/
+
+/*
+ * First function called by fabric modules to:
+ *
+ * 1) Allocate a struct target_fabric_configfs and save the *fabric_cit
pointer.
+ * 2) Add struct target_fabric_configfs to g_tf_list
+ * 3) Return struct target_fabric_configfs to fabric module to be
passed
+ *    into target_fabric_configfs_register().
+ */
+struct target_fabric_configfs *target_fabric_configfs_init(
+	struct config_item_type *fabric_cit,
+	const char *name)
+{
+	struct target_fabric_configfs *tf;
+
+	if (!(fabric_cit)) {
+		printk(KERN_ERR "Missing struct config_item_type * pointer\n");
+		return NULL;
+	}
+	if (!(name)) {
+		printk(KERN_ERR "Unable to locate passed fabric name\n");
+		return NULL;
+	}
+	if (strlen(name) > TARGET_FABRIC_NAME_SIZE) {
+		printk(KERN_ERR "Passed name: %s exceeds TARGET_FABRIC"
+			"_NAME_SIZE\n", name);
+		return NULL;
+	}
+
+	tf = kzalloc(sizeof(struct target_fabric_configfs), GFP_KERNEL);
+	if (!(tf))
+		return ERR_PTR(-ENOMEM);
+
+	INIT_LIST_HEAD(&tf->tf_list);
+	atomic_set(&tf->tf_access_cnt, 0);
+	tf->tf_fabric_cit = fabric_cit;
+	tf->tf_subsys = target_core_subsystem[0];
+	snprintf(tf->tf_name, TARGET_FABRIC_NAME_SIZE, "%s", name);
+
+	mutex_lock(&g_tf_lock);
+	list_add_tail(&tf->tf_list, &g_tf_list);
+	mutex_unlock(&g_tf_lock);
+
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
+			">>>>>>>>>>>>>>\n");
+	printk(KERN_INFO "Initialized struct target_fabric_configfs: %p for"
+			" %s\n", tf, tf->tf_name);
+	return tf;
+}
+EXPORT_SYMBOL(target_fabric_configfs_init);
+
+/*
+ * Called by fabric plugins after FAILED
target_fabric_configfs_register() call.
+ */
+void target_fabric_configfs_free(
+	struct target_fabric_configfs *tf)
+{
+	mutex_lock(&g_tf_lock);
+	list_del(&tf->tf_list);
+	mutex_unlock(&g_tf_lock);
+
+	kfree(tf);
+}
+EXPORT_SYMBOL(target_fabric_configfs_free);
+
+/*
+ * Note that config_group_find_item() calls config_item_get() and grabs
the
+ * reference to the returned struct config_item *
+ * It will be released with config_put_item() in
+ * target_fabric_configfs_deregister()
+ */
+struct config_item *target_fabric_configfs_find_by_name(
+	struct configfs_subsystem *target_su,
+	const char *name)
+{
+	struct config_item *fabric;
+
+	mutex_lock(&target_su->su_mutex);
+	fabric = config_group_find_item(&target_su->su_group, name);
+	mutex_unlock(&target_su->su_mutex);
+
+	return fabric;
+}
+
+/*
+ * Called 2nd from fabric module with returned parameter of
+ * struct target_fabric_configfs * from target_fabric_configfs_init().
+ *
+ * Upon a successful registration, the new fabric's struct config_item
is
+ * return.  Also, a pointer to this struct is set in the passed
+ * struct target_fabric_configfs.
+ */
+int target_fabric_configfs_register(
+	struct target_fabric_configfs *tf)
+{
+	struct config_group *su_group;
+
+	if (!(tf)) {
+		printk(KERN_ERR "Unable to locate target_fabric_configfs"
+			" pointer\n");
+		return -EINVAL;
+	}
+	if (!(tf->tf_subsys)) {
+		printk(KERN_ERR "Unable to target struct config_subsystem"
+			" pointer\n");
+		return -EINVAL;
+	}
+	su_group = &tf->tf_subsys->su_group;
+	if (!(su_group)) {
+		printk(KERN_ERR "Unable to locate target struct config_group"
+			" pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
+		">>>>>>>>>>\n");
+	return 0;
+}
+EXPORT_SYMBOL(target_fabric_configfs_register);
+
+void target_fabric_configfs_deregister(
+	struct target_fabric_configfs *tf)
+{
+	struct config_group *su_group;
+	struct configfs_subsystem *su;
+
+	if (!(tf)) {
+		printk(KERN_ERR "Unable to locate passed target_fabric_"
+			"configfs\n");
+		return;
+	}
+	su = tf->tf_subsys;
+	if (!(su)) {
+		printk(KERN_ERR "Unable to locate passed tf->tf_subsys"
+			" pointer\n");
+		return;
+	}
+	su_group = &tf->tf_subsys->su_group;
+	if (!(su_group)) {
+		printk(KERN_ERR "Unable to locate target struct config_group"
+			" pointer\n");
+		return;
+	}
+
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
+			">>>>>>>>>>>>\n");
+	mutex_lock(&g_tf_lock);
+	if (atomic_read(&tf->tf_access_cnt)) {
+		mutex_unlock(&g_tf_lock);
+		printk(KERN_ERR "Non zero tf->tf_access_cnt for fabric %s\n",
+			tf->tf_name);
+		BUG();
+	}
+	list_del(&tf->tf_list);
+	mutex_unlock(&g_tf_lock);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing tf:"
+			" %s\n", tf->tf_name);
+	tf->tf_fabric_cit = NULL;
+	tf->tf_subsys = NULL;
+	kfree(tf);
+
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
+			">>>>>\n");
+	return;
+}
+EXPORT_SYMBOL(target_fabric_configfs_deregister);
+
+/*##############################################################################
+// Stop functions called by external Target Fabrics Modules
+//############################################################################*/
+
+/* Start functions for struct config_item_type
target_core_dev_attrib_cit */
+
+#define DEF_DEV_ATTRIB_SHOW(_name)					\
+static ssize_t target_core_dev_show_attr_##_name(			\
+	struct se_dev_attrib_s *da,					\
+	char *page)							\
+{									\
+	se_device_t *dev;						\
+	se_subsystem_dev_t *se_dev = da->da_sub_dev;			\
+	ssize_t rb;							\
+									\
+	spin_lock(&se_dev->se_dev_lock);				\
+	dev = se_dev->se_dev_ptr;					\
+	if (!(dev)) {							\
+		spin_unlock(&se_dev->se_dev_lock); 			\
+		return -ENODEV;						\
+	}								\
+	rb = snprintf(page, PAGE_SIZE, "%u\n", (u32)DEV_ATTRIB(dev)->_name); \
+	spin_unlock(&se_dev->se_dev_lock);				\
+									\
+	return rb;							\
+}
+
+#define DEF_DEV_ATTRIB_STORE(_name)					\
+static ssize_t target_core_dev_store_attr_##_name(			\
+	struct se_dev_attrib_s *da,					\
+	const char *page,						\
+	size_t count)							\
+{									\
+	se_device_t *dev;						\
+	se_subsystem_dev_t *se_dev = da->da_sub_dev;			\
+	unsigned long val;						\
+	int ret;							\
+									\
+	spin_lock(&se_dev->se_dev_lock);				\
+	dev = se_dev->se_dev_ptr;					\
+	if (!(dev)) {							\
+		spin_unlock(&se_dev->se_dev_lock);			\
+		return -ENODEV;						\
+	}								\
+	ret = strict_strtoul(page, 0, &val);				\
+	if (ret < 0) {							\
+		printk(KERN_ERR "strict_strtoul() failed with"		\
+			" ret: %d\n", ret);				\
+		return -EINVAL;						\
+	}								\
+	ret = se_dev_set_##_name(dev, (u32)val);			\
+	spin_unlock(&se_dev->se_dev_lock);				\
+									\
+	return (!ret) ? count : -EINVAL;				\
+}
+
+#define DEF_DEV_ATTRIB(_name)						\
+DEF_DEV_ATTRIB_SHOW(_name);						\
+DEF_DEV_ATTRIB_STORE(_name);
+
+#define DEF_DEV_ATTRIB_RO(_name)					\
+DEF_DEV_ATTRIB_SHOW(_name);
+
+CONFIGFS_EATTR_STRUCT(target_core_dev_attrib, se_dev_attrib_s);
+#define SE_DEV_ATTR(_name, _mode)					\
+static struct target_core_dev_attrib_attribute				\
+			target_core_dev_attrib_##_name =		\
+		__CONFIGFS_EATTR(_name, _mode,				\
+		target_core_dev_show_attr_##_name,			\
+		target_core_dev_store_attr_##_name);
+
+#define SE_DEV_ATTR_RO(_name);						\
+static struct target_core_dev_attrib_attribute				\
+			target_core_dev_attrib_##_name =		\
+		__CONFIGFS_EATTR_RO(_name,				\
+		target_core_dev_show_attr_##_name);
+
+DEF_DEV_ATTRIB(emulate_ua_intlck_ctrl);
+SE_DEV_ATTR(emulate_ua_intlck_ctrl, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB(emulate_tas);
+SE_DEV_ATTR(emulate_tas, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB_RO(hw_block_size);
+SE_DEV_ATTR_RO(hw_block_size);
+
+DEF_DEV_ATTRIB(block_size);
+SE_DEV_ATTR(block_size, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB_RO(hw_max_sectors);
+SE_DEV_ATTR_RO(hw_max_sectors);
+
+DEF_DEV_ATTRIB(max_sectors);
+SE_DEV_ATTR(max_sectors, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB_RO(hw_queue_depth);
+SE_DEV_ATTR_RO(hw_queue_depth);
+
+DEF_DEV_ATTRIB(queue_depth);
+SE_DEV_ATTR(queue_depth, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB(task_timeout);
+SE_DEV_ATTR(task_timeout, S_IRUGO | S_IWUSR);
+
+CONFIGFS_EATTR_OPS(target_core_dev_attrib, se_dev_attrib_s, da_group);
+
+static struct configfs_attribute *target_core_dev_attrib_attrs[] = {
+	&target_core_dev_attrib_emulate_ua_intlck_ctrl.attr,
+	&target_core_dev_attrib_emulate_tas.attr,
+	&target_core_dev_attrib_hw_block_size.attr,
+	&target_core_dev_attrib_block_size.attr,
+	&target_core_dev_attrib_hw_max_sectors.attr,
+	&target_core_dev_attrib_max_sectors.attr,
+	&target_core_dev_attrib_hw_queue_depth.attr,
+	&target_core_dev_attrib_queue_depth.attr,
+	&target_core_dev_attrib_task_timeout.attr,
+	NULL,
+};
+
+static struct configfs_item_operations target_core_dev_attrib_ops = {
+	.show_attribute		= target_core_dev_attrib_attr_show,
+	.store_attribute	= target_core_dev_attrib_attr_store,
+};
+
+static struct config_item_type target_core_dev_attrib_cit = {
+	.ct_item_ops		= &target_core_dev_attrib_ops,
+	.ct_attrs		= target_core_dev_attrib_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/* End functions for struct config_item_type target_core_dev_attrib_cit
*/
+
+/*  Start functions for struct config_item_type target_core_dev_wwn_cit
*/
+
+CONFIGFS_EATTR_STRUCT(target_core_dev_wwn, t10_wwn_s);
+#define SE_DEV_WWN_ATTR(_name, _mode)					\
+static struct target_core_dev_wwn_attribute target_core_dev_wwn_##_name
= \
+		__CONFIGFS_EATTR(_name, _mode,				\
+		target_core_dev_wwn_show_attr_##_name,			\
+		target_core_dev_wwn_store_attr_##_name);
+
+#define SE_DEV_WWN_ATTR_RO(_name);					\
+static struct target_core_dev_wwn_attribute target_core_dev_wwn_##_name
= \
+		__CONFIGFS_EATTR_RO(_name,				\
+		target_core_dev_wwn_show_attr_##_name);
+
+/*
+ * VPD page 0x80 Unit serial
+ */
+static ssize_t target_core_dev_wwn_show_attr_vpd_unit_serial(
+	struct t10_wwn_s *t10_wwn,
+	char *page)
+{
+	se_subsystem_dev_t *se_dev = t10_wwn->t10_sub_dev;
+	se_device_t *dev;
+
+	dev = se_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	return sprintf(page, "T10 VPD Unit Serial Number: %s\n",
+		&t10_wwn->unit_serial[0]);
+}
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_unit_serial(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	se_subsystem_dev_t *su_dev = t10_wwn->t10_sub_dev;
+	se_device_t *dev;
+	unsigned char buf[INQUIRY_VPD_SERIAL_LEN];
+
+	/*
+	 * If Linux/SCSI subsystem_api_t plugin got a VPD Unit Serial
+	 * from the struct scsi_device level firmware, do not allow
+	 * VPD Unit Serial to be emulated.
+	 *
+	 * Note this struct scsi_device could also be emulating VPD
+	 * information from its drivers/scsi LLD.  But for now we assume
+	 * it is doing 'the right thing' wrt a world wide unique
+	 * VPD Unit Serial Number that OS dependent multipath can depend on.
+	 */
+	if (su_dev->su_dev_flags & SDF_FIRMWARE_VPD_UNIT_SERIAL) {
+		printk(KERN_ERR "Underlying SCSI device firmware provided VPD"
+			" Unit Serial, ignoring request\n");
+		return -EOPNOTSUPP;
+	}
+
+	if ((strlen(page) + 1) > INQUIRY_VPD_SERIAL_LEN) {
+		printk(KERN_ERR "Emulated VPD Unit Serial exceeds"
+		" INQUIRY_VPD_SERIAL_LEN: %d\n", INQUIRY_VPD_SERIAL_LEN);
+		return -EOVERFLOW;
+	}
+	/*
+	 * Check to see if any active $FABRIC_MOD exports exist.  If they
+	 * do exist, fail here as changing this information on the fly
+	 * (underneath the initiator side OS dependent multipath code)
+	 * could cause negative effects.
+	 */
+	dev = su_dev->se_dev_ptr;
+	if ((dev)) {
+		if (DEV_OBJ_API(dev)->check_count(&dev->dev_export_obj)) {
+			printk(KERN_ERR "Unable to set VPD Unit Serial while"
+				" active %d $FABRIC_MOD exports exist\n",
+				DEV_OBJ_API(dev)->check_count(
+					&dev->dev_export_obj));
+			return -EINVAL;
+		}
+	}
+	/*
+	 * This currently assumes ASCII encoding for emulated VPD Unit Serial.
+	 *
+	 * Also, strip any newline added from the userspace
+	 * echo $UUID > $TARGET/$HBA/$STORAGE_OBJECT/wwn/vpd_unit_serial
+	 */
+	memset(buf, 0, INQUIRY_VPD_SERIAL_LEN);
+	snprintf(buf, INQUIRY_VPD_SERIAL_LEN, "%s", page);
+	snprintf(su_dev->t10_wwn.unit_serial, INQUIRY_VPD_SERIAL_LEN,
+			"%s", strstrip(buf));
+	su_dev->su_dev_flags |= SDF_EMULATED_VPD_UNIT_SERIAL;
+
+	printk(KERN_INFO "Target_Core_ConfigFS: Set emulated VPD Unit Serial:"
+			" %s\n", su_dev->t10_wwn.unit_serial);
+	return count;
+}
+
+SE_DEV_WWN_ATTR(vpd_unit_serial, S_IRUGO | S_IWUSR);
+
+/*
+ * VPD page 0x83 Protocol Identifier
+ */
+static ssize_t target_core_dev_wwn_show_attr_vpd_protocol_identifier(
+	struct t10_wwn_s *t10_wwn,
+	char *page)
+{
+	se_subsystem_dev_t *se_dev = t10_wwn->t10_sub_dev;
+	se_device_t *dev;
+	t10_vpd_t *vpd;
+	unsigned char buf[VPD_TMP_BUF_SIZE];
+	ssize_t len = 0;
+
+	dev = se_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	memset(buf, 0, VPD_TMP_BUF_SIZE);
+
+	spin_lock(&t10_wwn->t10_vpd_lock);
+	list_for_each_entry(vpd, &t10_wwn->t10_vpd_list, vpd_list) {
+		if (!(vpd->protocol_identifier_set))
+			continue;
+
+		transport_dump_vpd_proto_id(vpd, buf, VPD_TMP_BUF_SIZE);
+
+		if ((len + strlen(buf) > PAGE_SIZE))
+			break;
+
+		len += sprintf(page+len, "%s", buf);
+	}
+	spin_unlock(&t10_wwn->t10_vpd_lock);
+
+	return len;
+}
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_protocol_identifier(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_protocol_identifier, S_IRUGO | S_IWUSR);
+
+/*
+ * Generic wrapper for dumping VPD identifiers by association.
+ */
+#define DEF_DEV_WWN_ASSOC_SHOW(_name, _assoc)				\
+static ssize_t target_core_dev_wwn_show_attr_##_name(			\
+	struct t10_wwn_s *t10_wwn,					\
+	char *page)							\
+{									\
+	se_subsystem_dev_t *se_dev = t10_wwn->t10_sub_dev;		\
+	se_device_t *dev;						\
+	t10_vpd_t *vpd;							\
+	unsigned char buf[VPD_TMP_BUF_SIZE];				\
+	ssize_t len = 0;						\
+									\
+	dev = se_dev->se_dev_ptr;					\
+	if (!(dev))							\
+		return -ENODEV;						\
+									\
+	spin_lock(&t10_wwn->t10_vpd_lock);				\
+	list_for_each_entry(vpd, &t10_wwn->t10_vpd_list, vpd_list) {	\
+		if (vpd->association != _assoc)				\
+			continue;					\
+									\
+		memset(buf, 0, VPD_TMP_BUF_SIZE);			\
+		transport_dump_vpd_assoc(vpd, buf, VPD_TMP_BUF_SIZE);	\
+		if ((len + strlen(buf) > PAGE_SIZE))			\
+			break;						\
+		len += sprintf(page+len, "%s", buf);			\
+									\
+		memset(buf, 0, VPD_TMP_BUF_SIZE);			\
+		transport_dump_vpd_ident_type(vpd, buf, VPD_TMP_BUF_SIZE); \
+		if ((len + strlen(buf) > PAGE_SIZE))			\
+			break;						\
+		len += sprintf(page+len, "%s", buf);			\
+									\
+		memset(buf, 0, VPD_TMP_BUF_SIZE);			\
+		transport_dump_vpd_ident(vpd, buf, VPD_TMP_BUF_SIZE); \
+		if ((len + strlen(buf) > PAGE_SIZE))			\
+			break;						\
+		len += sprintf(page+len, "%s", buf);			\
+	}								\
+	spin_unlock(&t10_wwn->t10_vpd_lock);				\
+									\
+	return len;							\
+}
+
+/*
+ * VPD page 0x83 Assoication: Logical Unit
+ */
+DEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_logical_unit, 0x00);
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_assoc_logical_unit(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_assoc_logical_unit, S_IRUGO | S_IWUSR);
+
+/*
+ * VPD page 0x83 Association: Target Port
+ */
+DEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_target_port, 0x10);
+
+static ssize_t target_core_dev_wwn_store_attr_vpd_assoc_target_port(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_assoc_target_port, S_IRUGO | S_IWUSR);
+
+/*
+ * VPD page 0x83 Association: SCSI Target Device
+ */
+DEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_scsi_target_device, 0x20);
+
+static ssize_t
target_core_dev_wwn_store_attr_vpd_assoc_scsi_target_device(
+	struct t10_wwn_s *t10_wwn,
+	const char *page,
+	size_t count)
+{
+	return -ENOSYS;
+}
+
+SE_DEV_WWN_ATTR(vpd_assoc_scsi_target_device, S_IRUGO | S_IWUSR);
+
+CONFIGFS_EATTR_OPS(target_core_dev_wwn, t10_wwn_s, t10_wwn_group);
+
+static struct configfs_attribute *target_core_dev_wwn_attrs[] = {
+	&target_core_dev_wwn_vpd_unit_serial.attr,
+	&target_core_dev_wwn_vpd_protocol_identifier.attr,
+	&target_core_dev_wwn_vpd_assoc_logical_unit.attr,
+	&target_core_dev_wwn_vpd_assoc_target_port.attr,
+	&target_core_dev_wwn_vpd_assoc_scsi_target_device.attr,
+	NULL,
+};
+
+static struct configfs_item_operations target_core_dev_wwn_ops = {
+	.show_attribute		= target_core_dev_wwn_attr_show,
+	.store_attribute	= target_core_dev_wwn_attr_store,
+};
+
+static struct config_item_type target_core_dev_wwn_cit = {
+	.ct_item_ops		= &target_core_dev_wwn_ops,
+	.ct_attrs		= target_core_dev_wwn_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/*  End functions for struct config_item_type target_core_dev_wwn_cit
*/
+
+/*  Start functions for struct config_item_type target_core_dev_pr_cit
*/
+
+CONFIGFS_EATTR_STRUCT(target_core_dev_pr, se_subsystem_dev_s);
+#define SE_DEV_PR_ATTR(_name, _mode)					\
+static struct target_core_dev_pr_attribute target_core_dev_pr_##_name =
\
+	__CONFIGFS_EATTR(_name, _mode,					\
+	target_core_dev_wwn_show_attr_##_name,				\
+	target_core_dev_wwn_store_attr_##_name);
+
+#define SE_DEV_PR_ATTR_RO(_name);					\
+static struct target_core_dev_pr_attribute target_core_dev_pr_##_name =
\
+	__CONFIGFS_EATTR_RO(_name,					\
+	target_core_dev_pr_show_attr_##_name);				\
+
+/*
+ * res_holder
+ */
+static ssize_t target_core_dev_pr_show_spc3_res(
+	struct se_device_s *dev,
+	char *page,
+	ssize_t *len)
+{
+	se_node_acl_t *se_nacl;
+	t10_pr_registration_t *pr_reg;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		*len += sprintf(page + *len, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return *len;
+	}
+	se_nacl = pr_reg->pr_reg_nacl;
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",
+		TPG_TFO(se_nacl->se_tpg)->get_fabric_name(),
+		se_nacl->initiatorname);
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return *len;
+}
+
+static ssize_t target_core_dev_pr_show_spc2_res(
+	struct se_device_s *dev,
+	char *page,
+	ssize_t *len)
+{
+	se_node_acl_t *se_nacl;
+
+	spin_lock(&dev->dev_reservation_lock);
+	se_nacl = dev->dev_reserved_node_acl;
+	if (!(se_nacl)) {
+		*len += sprintf(page + *len, "No SPC-2 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return *len;
+	}
+	*len += sprintf(page + *len, "SPC-2 Reservation: %s Initiator: %s\n",
+		TPG_TFO(se_nacl->se_tpg)->get_fabric_name(),
+		se_nacl->initiatorname);
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return *len;
+}
+
+static ssize_t target_core_dev_pr_show_attr_res_holder(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	ssize_t len = 0;
+
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	switch (T10_RES(su_dev)->res_type) {
+	case SPC3_PERSISTENT_RESERVATIONS:
+		target_core_dev_pr_show_spc3_res(su_dev->se_dev_ptr,
+				page, &len);
+		break;
+	case SPC2_RESERVATIONS:
+		target_core_dev_pr_show_spc2_res(su_dev->se_dev_ptr,
+				page, &len);
+		break;
+	case SPC_PASSTHROUGH:
+		len += sprintf(page+len, "Passthrough\n");
+		break;
+	default:
+		len += sprintf(page+len, "Unknown\n");
+		break;
+	}
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_holder);
+
+/*
+ * res_pr_all_tgt_pts
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_all_tgt_pts(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	se_device_t *dev;
+	t10_pr_registration_t *pr_reg;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return len;
+	}
+	/*
+	 * See All Target Ports (ALL_TG_PT) bit in spcr17, section 6.14.3
+	 * Basic PERSISTENT RESERVER OUT parameter list, page 290
+	 */
+	if (pr_reg->pr_reg_all_tg_pt)
+		len = sprintf(page, "SPC-3 Reservation: All Target"
+			" Ports registration\n");
+	else
+		len = sprintf(page, "SPC-3 Reservation: Single"
+			" Target Port registration\n");
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_all_tgt_pts);
+
+/*
+ * res_pr_generation
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_generation(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return 0;
+
+	return sprintf(page, "0x%08x\n", T10_RES(su_dev)->pr_generation);
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_generation);
+
+/*
+ * res_pr_holder_tg_port
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_holder_tg_port(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	se_device_t *dev;
+	se_node_acl_t *se_nacl;
+	se_lun_t *lun;
+	se_portal_group_t *se_tpg;
+	t10_pr_registration_t *pr_reg;
+	struct target_core_fabric_ops *tfo;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return len;
+	}
+	se_nacl = pr_reg->pr_reg_nacl;
+	se_tpg = se_nacl->se_tpg;
+	lun = pr_reg->pr_reg_tg_pt_lun;
+	tfo = TPG_TFO(se_tpg);
+
+	len += sprintf(page+len, "SPC-3 Reservation: %s"
+		" Target Node Endpoint: %s\n", tfo->get_fabric_name(),
+		tfo->tpg_get_wwn(se_tpg));
+	len += sprintf(page+len, "SPC-3 Reservation: Relative Port"
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
+		" %s Logical Unit: %u\n", lun->lun_sep->sep_rtpi,
+		tfo->get_fabric_name(), tfo->tpg_get_tag(se_tpg),
+		tfo->get_fabric_name(), lun->unpacked_lun);
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_holder_tg_port);
+
+/*
+ * res_pr_registered_i_pts
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_registered_i_pts(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	struct target_core_fabric_ops *tfo;
+	t10_pr_registration_t *pr_reg;
+	unsigned char buf[384];
+	ssize_t len = 0;
+	int reg_count = 0;
+
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	len += sprintf(page+len, "SPC-3 PR Registrations:\n");
+
+	spin_lock(&T10_RES(su_dev)->registration_lock);
+	list_for_each_entry(pr_reg, &T10_RES(su_dev)->registration_list,
+			pr_reg_list) {
+
+		memset(buf, 0, 384);
+		tfo = pr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
+			tfo->get_fabric_name(),
+			pr_reg->pr_reg_nacl->initiatorname,
+			pr_reg->pr_res_key, pr_reg->pr_res_generation);
+
+		if ((len + strlen(buf) > PAGE_SIZE))
+			break;
+
+		len += sprintf(page+len, "%s", buf);
+		reg_count++;
+	}
+	spin_unlock(&T10_RES(su_dev)->registration_lock);
+
+	if (!(reg_count))
+		len += sprintf(page+len, "None\n");
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_registered_i_pts);
+
+/*
+ * res_pr_type
+ */
+static ssize_t target_core_dev_pr_show_attr_res_pr_type(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	se_device_t *dev;
+	t10_pr_registration_t *pr_reg;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_RES(su_dev)->res_type != SPC3_PERSISTENT_RESERVATIONS)
+		return len;
+
+	spin_lock(&dev->dev_reservation_lock);
+	pr_reg = dev->dev_pr_res_holder;
+	if (!(pr_reg)) {
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
+		spin_unlock(&dev->dev_reservation_lock);
+		return len;
+	}
+	len = sprintf(page, "SPC-3 Reservation Type: %s\n",
+		core_scsi3_pr_dump_type(pr_reg->pr_res_type));
+	spin_unlock(&dev->dev_reservation_lock);
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_pr_type);
+
+/*
+ * res_type
+ */
+static ssize_t target_core_dev_pr_show_attr_res_type(
+	struct se_subsystem_dev_s *su_dev,
+	char *page)
+{
+	ssize_t len = 0;
+
+	if (!(su_dev->se_dev_ptr))
+		return -ENODEV;
+
+	switch (T10_RES(su_dev)->res_type) {
+	case SPC3_PERSISTENT_RESERVATIONS:
+		len = sprintf(page, "SPC3_PERSISTENT_RESERVATIONS\n");
+		break;
+	case SPC2_RESERVATIONS:
+		len = sprintf(page, "SPC2_RESERVATIONS\n");
+		break;
+	case SPC_PASSTHROUGH:
+		len = sprintf(page, "SPC_PASSTHROUGH\n");
+		break;
+	default:
+		len = sprintf(page, "UNKNOWN\n");
+		break;
+	}
+
+	return len;
+}
+
+SE_DEV_PR_ATTR_RO(res_type);
+
+CONFIGFS_EATTR_OPS(target_core_dev_pr, se_subsystem_dev_s,
se_dev_pr_group);
+
+static struct configfs_attribute *target_core_dev_pr_attrs[] = {
+	&target_core_dev_pr_res_holder.attr,
+	&target_core_dev_pr_res_pr_all_tgt_pts.attr,
+	&target_core_dev_pr_res_pr_generation.attr,
+	&target_core_dev_pr_res_pr_holder_tg_port.attr,
+	&target_core_dev_pr_res_pr_registered_i_pts.attr,
+	&target_core_dev_pr_res_pr_type.attr,
+	&target_core_dev_pr_res_type.attr,
+	NULL,
+};
+
+static struct configfs_item_operations target_core_dev_pr_ops = {
+	.show_attribute		= target_core_dev_pr_attr_show,
+	.store_attribute	= target_core_dev_pr_attr_store,
+};
+
+static struct config_item_type target_core_dev_pr_cit = {
+	.ct_item_ops		= &target_core_dev_pr_ops,
+	.ct_attrs		= target_core_dev_pr_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/*  End functions for struct config_item_type target_core_dev_pr_cit */
+
+/*  Start functions for struct config_item_type target_core_dev_cit */
+
+static ssize_t target_core_show_dev_info(void *p, char *page)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	int ret = 0, bl = 0;
+	ssize_t read_bytes = 0;
+
+	t = (se_subsystem_api_t *)plugin_get_obj(PLUGIN_TYPE_TRANSPORT,
+			hba->type, &ret);
+	if (!t || (ret != 0))
+		return 0;
+
+	if (se_dev->se_dev_ptr) {
+		transport_dump_dev_state(se_dev->se_dev_ptr, page, &bl);
+		read_bytes += bl;
+	}
+
+	read_bytes += t->show_configfs_dev_params(hba, se_dev, page
+read_bytes);
+	return read_bytes;
+}
+
+static struct target_core_configfs_attribute target_core_attr_dev_info
= {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "info",
+		    .ca_mode = S_IRUGO },
+	.show	= target_core_show_dev_info,
+	.store	= NULL,
+};
+
+static ssize_t target_core_store_dev_control(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	int ret = 0;
+
+	if (!(se_dev->se_dev_su_ptr)) {
+		printk(KERN_ERR "Unable to locate se_subsystem_dev_t>se"
+				"_dev_su_ptr\n");
+		return -EINVAL;
+	}
+
+	t = (se_subsystem_api_t *)plugin_get_obj(PLUGIN_TYPE_TRANSPORT,
+			hba->type, &ret);
+	if (!t || (ret != 0))
+		return -EINVAL;
+
+	return t->set_configfs_dev_params(hba, se_dev, page, count);
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_control = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "control",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_control,
+};
+
+static ssize_t target_core_store_dev_fd(void *p, const char *page,
size_t count)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_device_t *dev;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	int ret = 0;
+
+	if (se_dev->se_dev_ptr) {
+		printk(KERN_ERR "se_dev->se_dev_ptr already set, ignoring"
+			" fd request\n");
+		return -EEXIST;
+	}
+
+	t = (se_subsystem_api_t *)plugin_get_obj(PLUGIN_TYPE_TRANSPORT,
+			hba->type, &ret);
+	if (!t || (ret != 0))
+		return -EINVAL;
+
+	if (!(t->create_virtdevice_from_fd)) {
+		printk(KERN_ERR "se_subsystem_api_t->create_virtdevice_from"
+			"_fd() NULL for: %s\n", hba->transport->name);
+		return -EINVAL;
+	}
+	/*
+	 * The subsystem PLUGIN is responsible for calling target_core_mod
+	 * symbols to claim the underlying struct block_device for TYPE_DISK.
+	 */
+	dev = t->create_virtdevice_from_fd(se_dev, page);
+	if (!(dev) || IS_ERR(dev))
+		goto out;
+
+	se_dev->se_dev_ptr = dev;
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered %s se_dev->se_dev"
+		"_ptr: %p from fd\n", hba->transport->name, se_dev->se_dev_ptr);
+	return count;
+out:
+	return -EINVAL;
+}
+
+static struct target_core_configfs_attribute target_core_attr_dev_fd =
{
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "fd",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_fd,
+};
+
+static ssize_t target_core_store_dev_enable(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_subsystem_dev_t *se_dev = (se_subsystem_dev_t *)p;
+	se_device_t *dev;
+	se_hba_t *hba = se_dev->se_dev_hba;
+	se_subsystem_api_t *t;
+	char *ptr;
+	int ret = 0;
+
+	ptr = strstr(page, "1");
+	if (!(ptr)) {
+		printk(KERN_ERR "For dev_enable ops, only valid value"
+				" is \"1\"\n");
+		return -EINVAL;
+	}

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#235: FILE: drivers/target/target_core_configfs.c:181:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> located fabric:"
 	                                      ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:SPACING: spaces prohibited around that '->' (ctx:WxW)
#235: FILE: drivers/target/target_core_configfs.c:181:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> located fabric:"
 	                                                   ^

CHECK:SPACING: spaces required around that ':' (ctx:VxV)
#235: FILE: drivers/target/target_core_configfs.c:181:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> located fabric:"
 	                                                                    ^

CHECK:CAMELCASE: Avoid CamelCase: <Target_Core_ConfigFS>
#235: FILE: drivers/target/target_core_configfs.c:181:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> located fabric:"

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#236: FILE: drivers/target/target_core_configfs.c:182:
+			" %s\n", tf->tf_name);
 			  ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#239: FILE: drivers/target/target_core_configfs.c:185:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing"
 	                                      ^

ERROR:SPACING: spaces prohibited around that '->' (ctx:WxW)
#239: FILE: drivers/target/target_core_configfs.c:185:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing"
 	                                                   ^

CHECK:CAMELCASE: Avoid CamelCase: <Releasing>
#239: FILE: drivers/target/target_core_configfs.c:185:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing"

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#240: FILE: drivers/target/target_core_configfs.c:186:
+			" tf->tf_fabric for %s\n", tf->tf_name);
 			                    ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#243: FILE: drivers/target/target_core_configfs.c:189:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing ci"
 	                                      ^

ERROR:SPACING: spaces prohibited around that '->' (ctx:WxW)
#243: FILE: drivers/target/target_core_configfs.c:189:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing ci"
 	                                                   ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#244: FILE: drivers/target/target_core_configfs.c:190:
+			" %s\n", config_item_name(item));
 			  ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#254: FILE: drivers/target/target_core_configfs.c:200:
+ * All item attributes appearing in /sys/kernel/target/ appear here.$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#255: FILE: drivers/target/target_core_configfs.c:201:
+ */$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#262: FILE: drivers/target/target_core_configfs.c:208:
+ * Provides Fabrics Groups and Item Attributes$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#264: FILE: drivers/target/target_core_configfs.c:209:
+ */$

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#288: FILE: drivers/target/target_core_configfs.c:233:
+//############################################################################*/

The comment style is incorrect.  The preferred style for multi-
line comments is::

  /*
  * This is the preferred style
  * for multi line comments.
  */

The networking comment style is a bit different, with the first line
not empty like the former::

  /* This is the preferred comment style
  * for files in net/ and drivers/net/
  */

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#commenting

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#291: FILE: drivers/target/target_core_configfs.c:236:
+ * First function called by fabric modules to:$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#292: FILE: drivers/target/target_core_configfs.c:237:
+ *$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#293: FILE: drivers/target/target_core_configfs.c:238:
+ * 1) Allocate a struct target_fabric_configfs and save the *fabric_cit$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#295: FILE: drivers/target/target_core_configfs.c:239:
+ * 2) Add struct target_fabric_configfs to g_tf_list$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#296: FILE: drivers/target/target_core_configfs.c:240:
+ * 3) Return struct target_fabric_configfs to fabric module to be$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#298: FILE: drivers/target/target_core_configfs.c:241:
+ *    into target_fabric_configfs_register().$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#299: FILE: drivers/target/target_core_configfs.c:242:
+ */$

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#307: FILE: drivers/target/target_core_configfs.c:250:
+		printk(KERN_ERR "Missing struct config_item_type * pointer\n");

When using pointer data or a function that returns a pointer type,
the preferred use of * is adjacent to the data name or function name
and not adjacent to the type name.
Examples::

  char *linux_banner;
  unsigned long long memparse(char *ptr, char **retptr);
  char *match_strdup(substring_t *s);

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:CAMELCASE: Avoid CamelCase: <Missing>
#307: FILE: drivers/target/target_core_configfs.c:250:
+		printk(KERN_ERR "Missing struct config_item_type * pointer\n");

CHECK:CAMELCASE: Avoid CamelCase: <Unable>
#311: FILE: drivers/target/target_core_configfs.c:254:
+		printk(KERN_ERR "Unable to locate passed fabric name\n");

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#315: FILE: drivers/target/target_core_configfs.c:258:
+		printk(KERN_ERR "Passed name: %s exceeds TARGET_FABRIC"
 		                            ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#315: FILE: drivers/target/target_core_configfs.c:258:
+		printk(KERN_ERR "Passed name: %s exceeds TARGET_FABRIC"
 		                              ^

CHECK:CAMELCASE: Avoid CamelCase: <Passed>
#315: FILE: drivers/target/target_core_configfs.c:258:
+		printk(KERN_ERR "Passed name: %s exceeds TARGET_FABRIC"

WARNING:MISSING_SPACE: break quoted strings at a space character
#316: FILE: drivers/target/target_core_configfs.c:259:
+		printk(KERN_ERR "Passed name: %s exceeds TARGET_FABRIC"
+			"_NAME_SIZE\n", name);

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#328: FILE: drivers/target/target_core_configfs.c:271:
+	snprintf(tf->tf_name, TARGET_FABRIC_NAME_SIZE, "%s", name);
 	                                                ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                    ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                      ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                        ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                          ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                            ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                              ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                    ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxW)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                      ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:WxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                                          ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                                            ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                                              ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxV)
#334: FILE: drivers/target/target_core_configfs.c:277:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>"
 	                                                                ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:VxO)
#335: FILE: drivers/target/target_core_configfs.c:278:
+			">>>>>>>>>>>>>>\n");
 			 ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#335: FILE: drivers/target/target_core_configfs.c:278:
+			">>>>>>>>>>>>>>\n");
 			   ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#335: FILE: drivers/target/target_core_configfs.c:278:
+			">>>>>>>>>>>>>>\n");
 			     ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#335: FILE: drivers/target/target_core_configfs.c:278:
+			">>>>>>>>>>>>>>\n");
 			       ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#335: FILE: drivers/target/target_core_configfs.c:278:
+			">>>>>>>>>>>>>>\n");
 			         ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#335: FILE: drivers/target/target_core_configfs.c:278:
+			">>>>>>>>>>>>>>\n");
 			           ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxV)
#335: FILE: drivers/target/target_core_configfs.c:278:
+			">>>>>>>>>>>>>>\n");
 			             ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#336: FILE: drivers/target/target_core_configfs.c:279:
+	printk(KERN_INFO "Initialized struct target_fabric_configfs: %p for"
 	                                                           ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#336: FILE: drivers/target/target_core_configfs.c:279:
+	printk(KERN_INFO "Initialized struct target_fabric_configfs: %p for"
 	                                                             ^

CHECK:CAMELCASE: Avoid CamelCase: <Initialized>
#336: FILE: drivers/target/target_core_configfs.c:279:
+	printk(KERN_INFO "Initialized struct target_fabric_configfs: %p for"

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#337: FILE: drivers/target/target_core_configfs.c:280:
+			" %s\n", tf, tf->tf_name);
 			  ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#343: FILE: drivers/target/target_core_configfs.c:286:
+ * Called by fabric plugins after FAILED$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#345: FILE: drivers/target/target_core_configfs.c:287:
+ */$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#358: FILE: drivers/target/target_core_configfs.c:300:
+ * Note that config_group_find_item() calls config_item_get() and grabs$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#360: FILE: drivers/target/target_core_configfs.c:301:
+ * reference to the returned struct config_item *$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#361: FILE: drivers/target/target_core_configfs.c:302:
+ * It will be released with config_put_item() in$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#362: FILE: drivers/target/target_core_configfs.c:303:
+ * target_fabric_configfs_deregister()$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#363: FILE: drivers/target/target_core_configfs.c:304:
+ */$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#378: FILE: drivers/target/target_core_configfs.c:319:
+ * Called 2nd from fabric module with returned parameter of$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#379: FILE: drivers/target/target_core_configfs.c:320:
+ * struct target_fabric_configfs * from target_fabric_configfs_init().$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#380: FILE: drivers/target/target_core_configfs.c:321:
+ *$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#381: FILE: drivers/target/target_core_configfs.c:322:
+ * Upon a successful registration, the new fabric's struct config_item$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#383: FILE: drivers/target/target_core_configfs.c:323:
+ * return.  Also, a pointer to this struct is set in the passed$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#384: FILE: drivers/target/target_core_configfs.c:324:
+ * struct target_fabric_configfs.$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#385: FILE: drivers/target/target_core_configfs.c:325:
+ */$

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                    ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                      ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                        ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                          ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                            ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                              ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                    ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxW)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                      ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:WxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                                        ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                                          ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                                            ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                                              ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                                                ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxV)
#407: FILE: drivers/target/target_core_configfs.c:347:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>"
 	                                                                  ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:VxO)
#408: FILE: drivers/target/target_core_configfs.c:348:
+		">>>>>>>>>>\n");
 		 ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#408: FILE: drivers/target/target_core_configfs.c:348:
+		">>>>>>>>>>\n");
 		   ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#408: FILE: drivers/target/target_core_configfs.c:348:
+		">>>>>>>>>>\n");
 		     ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#408: FILE: drivers/target/target_core_configfs.c:348:
+		">>>>>>>>>>\n");
 		       ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxV)
#408: FILE: drivers/target/target_core_configfs.c:348:
+		">>>>>>>>>>\n");
 		         ^

WARNING:MISSING_SPACE: break quoted strings at a space character
#421: FILE: drivers/target/target_core_configfs.c:361:
+		printk(KERN_ERR "Unable to locate passed target_fabric_"
+			"configfs\n");

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                    ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                      ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                        ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                          ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                            ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                              ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                    ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxW)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                      ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:WxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                                          ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                                            ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                                              ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                                                ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxV)
#437: FILE: drivers/target/target_core_configfs.c:377:
+	printk(KERN_INFO "<<<<<<<<<<<<<<<<<<<<<< BEGIN FABRIC API >>>>>>>>>>"
 	                                                                  ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:VxO)
#438: FILE: drivers/target/target_core_configfs.c:378:
+			">>>>>>>>>>>>\n");
 			 ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#438: FILE: drivers/target/target_core_configfs.c:378:
+			">>>>>>>>>>>>\n");
 			   ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#438: FILE: drivers/target/target_core_configfs.c:378:
+			">>>>>>>>>>>>\n");
 			     ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#438: FILE: drivers/target/target_core_configfs.c:378:
+			">>>>>>>>>>>>\n");
 			       ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#438: FILE: drivers/target/target_core_configfs.c:378:
+			">>>>>>>>>>>>\n");
 			         ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxV)
#438: FILE: drivers/target/target_core_configfs.c:378:
+			">>>>>>>>>>>>\n");
 			           ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#442: FILE: drivers/target/target_core_configfs.c:382:
+		printk(KERN_ERR "Non zero tf->tf_access_cnt for fabric %s\n",
 		                                                       ^

CHECK:CAMELCASE: Avoid CamelCase: <Non>
#442: FILE: drivers/target/target_core_configfs.c:382:
+		printk(KERN_ERR "Non zero tf->tf_access_cnt for fabric %s\n",

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#449: FILE: drivers/target/target_core_configfs.c:389:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing tf:"
 	                                      ^

ERROR:SPACING: spaces prohibited around that '->' (ctx:WxW)
#449: FILE: drivers/target/target_core_configfs.c:389:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing tf:"
 	                                                   ^

CHECK:SPACING: spaces required around that ':' (ctx:VxV)
#449: FILE: drivers/target/target_core_configfs.c:389:
+	printk(KERN_INFO "Target_Core_ConfigFS: DEREGISTER -> Releasing tf:"
 	                                                                  ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#450: FILE: drivers/target/target_core_configfs.c:390:
+			" %s\n", tf->tf_name);
 			  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	        ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	          ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	            ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	              ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                  ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                    ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                      ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                        ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                          ^

CHECK:SPACING: spaces preferred around that '<<' (ctx:OxW)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                            ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:WxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                              ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                  ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                    ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                      ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                        ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                          ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                            ^

ERROR:SPACING: spaces required around that '>' (ctx:OxV)
#455: FILE: drivers/target/target_core_configfs.c:395:
+	printk("<<<<<<<<<<<<<<<<<<<<<< END FABRIC API >>>>>>>>>>>>>>>>>"
 	                                                              ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:VxO)
#456: FILE: drivers/target/target_core_configfs.c:396:
+			">>>>>\n");
 			 ^

CHECK:SPACING: spaces preferred around that '>>' (ctx:OxO)
#456: FILE: drivers/target/target_core_configfs.c:396:
+			">>>>>\n");
 			   ^

ERROR:SPACING: spaces required around that '>' (ctx:OxV)
#456: FILE: drivers/target/target_core_configfs.c:396:
+			">>>>>\n");
 			     ^

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#463: FILE: drivers/target/target_core_configfs.c:403:
+//############################################################################*/

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#480: FILE: drivers/target/target_core_configfs.c:419:
+^I^Ispin_unlock(&se_dev->se_dev_lock); ^I^I^I\$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#483: FILE: drivers/target/target_core_configfs.c:422:
+	rb = snprintf(page, PAGE_SIZE, "%u\n", (u32)DEV_ATTRIB(dev)->_name); \
 	                                ^

WARNING:CONSIDER_KSTRTO: strict_strtoul is obsolete, use kstrtoul instead
#508: FILE: drivers/target/target_core_configfs.c:447:
+		printk(KERN_ERR "strict_strtoul() failed with"		\

The simple_strtol(), simple_strtoll(), simple_strtoul(), and
simple_strtoull() functions explicitly ignore overflows, which
may lead to unexpected results in callers.  The respective kstrtol(),
kstrtoll(), kstrtoul(), and kstrtoull() functions tend to be the
correct replacements.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#simple-strtol-simple-strtoll-simple-strtoul-simple-strtoull

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#509: FILE: drivers/target/target_core_configfs.c:448:
+			" ret: %d\n", ret);				\
 			     ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#509: FILE: drivers/target/target_core_configfs.c:448:
+			" ret: %d\n", ret);				\
 			       ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#613: FILE: drivers/target/target_core_configfs.c:548:
+ * VPD page 0x80 Unit serial$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#614: FILE: drivers/target/target_core_configfs.c:549:
+ */$

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#626: FILE: drivers/target/target_core_configfs.c:561:
+	return sprintf(page, "T10 VPD Unit Serial Number: %s\n",
 	                                                ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#626: FILE: drivers/target/target_core_configfs.c:561:
+	return sprintf(page, "T10 VPD Unit Serial Number: %s\n",
 	                                                  ^

CHECK:CAMELCASE: Avoid CamelCase: <Unit>
#626: FILE: drivers/target/target_core_configfs.c:561:
+	return sprintf(page, "T10 VPD Unit Serial Number: %s\n",

CHECK:CAMELCASE: Avoid CamelCase: <Serial>
#626: FILE: drivers/target/target_core_configfs.c:561:
+	return sprintf(page, "T10 VPD Unit Serial Number: %s\n",

CHECK:CAMELCASE: Avoid CamelCase: <Number>
#626: FILE: drivers/target/target_core_configfs.c:561:
+	return sprintf(page, "T10 VPD Unit Serial Number: %s\n",

CHECK:CAMELCASE: Avoid CamelCase: <Underlying>
#650: FILE: drivers/target/target_core_configfs.c:585:
+		printk(KERN_ERR "Underlying SCSI device firmware provided VPD"

CHECK:CAMELCASE: Avoid CamelCase: <Emulated>
#656: FILE: drivers/target/target_core_configfs.c:591:
+		printk(KERN_ERR "Emulated VPD Unit Serial exceeds"

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#657: FILE: drivers/target/target_core_configfs.c:592:
+		" INQUIRY_VPD_SERIAL_LEN: %d\n", INQUIRY_VPD_SERIAL_LEN);
 		                        ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#657: FILE: drivers/target/target_core_configfs.c:592:
+		" INQUIRY_VPD_SERIAL_LEN: %d\n", INQUIRY_VPD_SERIAL_LEN);
 		                          ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#670: FILE: drivers/target/target_core_configfs.c:605:
+				" active %d $FABRIC_MOD exports exist\n",
 				         ^

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#683: FILE: drivers/target/target_core_configfs.c:618:
+	snprintf(buf, INQUIRY_VPD_SERIAL_LEN, "%s", page);
 	                                       ^

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#685: FILE: drivers/target/target_core_configfs.c:620:
+			"%s", strstrip(buf));
 			 ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#688: FILE: drivers/target/target_core_configfs.c:623:
+	printk(KERN_INFO "Target_Core_ConfigFS: Set emulated VPD Unit Serial:"
 	                                      ^

CHECK:SPACING: spaces required around that ':' (ctx:VxV)
#688: FILE: drivers/target/target_core_configfs.c:623:
+	printk(KERN_INFO "Target_Core_ConfigFS: Set emulated VPD Unit Serial:"
 	                                                                    ^

CHECK:CAMELCASE: Avoid CamelCase: <Set>
#688: FILE: drivers/target/target_core_configfs.c:623:
+	printk(KERN_INFO "Target_Core_ConfigFS: Set emulated VPD Unit Serial:"

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#689: FILE: drivers/target/target_core_configfs.c:624:
+			" %s\n", su_dev->t10_wwn.unit_serial);
 			  ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#696: FILE: drivers/target/target_core_configfs.c:631:
+ * VPD page 0x83 Protocol Identifier$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#697: FILE: drivers/target/target_core_configfs.c:632:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#724: FILE: drivers/target/target_core_configfs.c:659:
+		len += sprintf(page+len, "%s", buf);
 		                          ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#742: FILE: drivers/target/target_core_configfs.c:677:
+ * Generic wrapper for dumping VPD identifiers by association.$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#743: FILE: drivers/target/target_core_configfs.c:678:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#768: FILE: drivers/target/target_core_configfs.c:703:
+		len += sprintf(page+len, "%s", buf);			\
 		                          ^

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#774: FILE: drivers/target/target_core_configfs.c:709:
+		len += sprintf(page+len, "%s", buf);			\
 		                          ^

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#780: FILE: drivers/target/target_core_configfs.c:715:
+		len += sprintf(page+len, "%s", buf);			\
 		                          ^

WARNING:TYPO_SPELLING: 'Assoication' may be misspelled - perhaps 'Association'?
#788: FILE: drivers/target/target_core_configfs.c:723:
+ * VPD page 0x83 Assoication: Logical Unit
                  ^^^^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#788: FILE: drivers/target/target_core_configfs.c:723:
+ * VPD page 0x83 Assoication: Logical Unit$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#789: FILE: drivers/target/target_core_configfs.c:724:
+ */$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#803: FILE: drivers/target/target_core_configfs.c:738:
+ * VPD page 0x83 Association: Target Port$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#804: FILE: drivers/target/target_core_configfs.c:739:
+ */$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#818: FILE: drivers/target/target_core_configfs.c:753:
+ * VPD page 0x83 Association: SCSI Target Device$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#819: FILE: drivers/target/target_core_configfs.c:754:
+ */$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#876: FILE: drivers/target/target_core_configfs.c:806:
+ * res_holder$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#877: FILE: drivers/target/target_core_configfs.c:807:
+ */$

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#889: FILE: drivers/target/target_core_configfs.c:819:
+		*len += sprintf(page + *len, "No SPC-3 Reservation holder\n");
 		                                    ^

CHECK:CAMELCASE: Avoid CamelCase: <No>
#889: FILE: drivers/target/target_core_configfs.c:819:
+		*len += sprintf(page + *len, "No SPC-3 Reservation holder\n");

CHECK:CAMELCASE: Avoid CamelCase: <Reservation>
#889: FILE: drivers/target/target_core_configfs.c:819:
+		*len += sprintf(page + *len, "No SPC-3 Reservation holder\n");

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#894: FILE: drivers/target/target_core_configfs.c:824:
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",
 	                                 ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#894: FILE: drivers/target/target_core_configfs.c:824:
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",
 	                                               ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#894: FILE: drivers/target/target_core_configfs.c:824:
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",
 	                                                 ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#894: FILE: drivers/target/target_core_configfs.c:824:
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",
 	                                                             ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#894: FILE: drivers/target/target_core_configfs.c:824:
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",
 	                                                               ^

CHECK:CAMELCASE: Avoid CamelCase: <Initiator>
#894: FILE: drivers/target/target_core_configfs.c:824:
+	*len += sprintf(page + *len, "SPC-3 Reservation: %s Initiator: %s\n",

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#912: FILE: drivers/target/target_core_configfs.c:842:
+		*len += sprintf(page + *len, "No SPC-2 Reservation holder\n");
 		                                    ^

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#916: FILE: drivers/target/target_core_configfs.c:846:
+	*len += sprintf(page + *len, "SPC-2 Reservation: %s Initiator: %s\n",
 	                                 ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#916: FILE: drivers/target/target_core_configfs.c:846:
+	*len += sprintf(page + *len, "SPC-2 Reservation: %s Initiator: %s\n",
 	                                               ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#916: FILE: drivers/target/target_core_configfs.c:846:
+	*len += sprintf(page + *len, "SPC-2 Reservation: %s Initiator: %s\n",
 	                                                 ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#916: FILE: drivers/target/target_core_configfs.c:846:
+	*len += sprintf(page + *len, "SPC-2 Reservation: %s Initiator: %s\n",
 	                                                             ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#916: FILE: drivers/target/target_core_configfs.c:846:
+	*len += sprintf(page + *len, "SPC-2 Reservation: %s Initiator: %s\n",
 	                                                               ^

CHECK:CAMELCASE: Avoid CamelCase: <Passthrough>
#943: FILE: drivers/target/target_core_configfs.c:873:
+		len += sprintf(page+len, "Passthrough\n");

CHECK:CAMELCASE: Avoid CamelCase: <Unknown>
#946: FILE: drivers/target/target_core_configfs.c:876:
+		len += sprintf(page+len, "Unknown\n");

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#956: FILE: drivers/target/target_core_configfs.c:886:
+ * res_pr_all_tgt_pts$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#957: FILE: drivers/target/target_core_configfs.c:887:
+ */$

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#976: FILE: drivers/target/target_core_configfs.c:906:
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
 		                           ^

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#985: FILE: drivers/target/target_core_configfs.c:915:
+		len = sprintf(page, "SPC-3 Reservation: All Target"
 		                        ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#985: FILE: drivers/target/target_core_configfs.c:915:
+		len = sprintf(page, "SPC-3 Reservation: All Target"
 		                                      ^

CHECK:CAMELCASE: Avoid CamelCase: <All>
#985: FILE: drivers/target/target_core_configfs.c:915:
+		len = sprintf(page, "SPC-3 Reservation: All Target"

CHECK:CAMELCASE: Avoid CamelCase: <Target>
#985: FILE: drivers/target/target_core_configfs.c:915:
+		len = sprintf(page, "SPC-3 Reservation: All Target"

CHECK:CAMELCASE: Avoid CamelCase: <Ports>
#986: FILE: drivers/target/target_core_configfs.c:916:
+			" Ports registration\n");

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#988: FILE: drivers/target/target_core_configfs.c:918:
+		len = sprintf(page, "SPC-3 Reservation: Single"
 		                        ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#988: FILE: drivers/target/target_core_configfs.c:918:
+		len = sprintf(page, "SPC-3 Reservation: Single"
 		                                      ^

CHECK:CAMELCASE: Avoid CamelCase: <Single>
#988: FILE: drivers/target/target_core_configfs.c:918:
+		len = sprintf(page, "SPC-3 Reservation: Single"

CHECK:CAMELCASE: Avoid CamelCase: <Port>
#989: FILE: drivers/target/target_core_configfs.c:919:
+			" Target Port registration\n");

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#998: FILE: drivers/target/target_core_configfs.c:928:
+ * res_pr_generation$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#999: FILE: drivers/target/target_core_configfs.c:929:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1010: FILE: drivers/target/target_core_configfs.c:940:
+	return sprintf(page, "0x%08x\n", T10_RES(su_dev)->pr_generation);
 	                        ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1016: FILE: drivers/target/target_core_configfs.c:946:
+ * res_pr_holder_tg_port$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1017: FILE: drivers/target/target_core_configfs.c:947:
+ */$

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1040: FILE: drivers/target/target_core_configfs.c:970:
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
 		                           ^

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1049: FILE: drivers/target/target_core_configfs.c:979:
+	len += sprintf(page+len, "SPC-3 Reservation: %s"
 	                             ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1049: FILE: drivers/target/target_core_configfs.c:979:
+	len += sprintf(page+len, "SPC-3 Reservation: %s"
 	                                           ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1049: FILE: drivers/target/target_core_configfs.c:979:
+	len += sprintf(page+len, "SPC-3 Reservation: %s"
 	                                             ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1050: FILE: drivers/target/target_core_configfs.c:980:
+		" Target Node Endpoint: %s\n", tfo->get_fabric_name(),
 		                      ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1050: FILE: drivers/target/target_core_configfs.c:980:
+		" Target Node Endpoint: %s\n", tfo->get_fabric_name(),
 		                        ^

CHECK:CAMELCASE: Avoid CamelCase: <Node>
#1050: FILE: drivers/target/target_core_configfs.c:980:
+		" Target Node Endpoint: %s\n", tfo->get_fabric_name(),

CHECK:CAMELCASE: Avoid CamelCase: <Endpoint>
#1050: FILE: drivers/target/target_core_configfs.c:980:
+		" Target Node Endpoint: %s\n", tfo->get_fabric_name(),

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1052: FILE: drivers/target/target_core_configfs.c:982:
+	len += sprintf(page+len, "SPC-3 Reservation: Relative Port"
 	                             ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1052: FILE: drivers/target/target_core_configfs.c:982:
+	len += sprintf(page+len, "SPC-3 Reservation: Relative Port"
 	                                           ^

CHECK:CAMELCASE: Avoid CamelCase: <Relative>
#1052: FILE: drivers/target/target_core_configfs.c:982:
+	len += sprintf(page+len, "SPC-3 Reservation: Relative Port"

WARNING:TYPO_SPELLING: 'Identifer' may be misspelled - perhaps 'Identifier'?
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
 		  ^^^^^^^^^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
 		               ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
 		                 ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
 		                     ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
 		                                        ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"
 		                                          ^

CHECK:CAMELCASE: Avoid CamelCase: <Identifer>
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"

CHECK:CAMELCASE: Avoid CamelCase: <Tag>
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"

CHECK:CAMELCASE: Avoid CamelCase: <Portal>
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"

CHECK:CAMELCASE: Avoid CamelCase: <Group>
#1053: FILE: drivers/target/target_core_configfs.c:983:
+		" Identifer Tag: %hu %s Portal Group Tag: %hu"

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1054: FILE: drivers/target/target_core_configfs.c:984:
+		" %s Logical Unit: %u\n", lun->lun_sep->sep_rtpi,
 		  ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1054: FILE: drivers/target/target_core_configfs.c:984:
+		" %s Logical Unit: %u\n", lun->lun_sep->sep_rtpi,
 		                 ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1054: FILE: drivers/target/target_core_configfs.c:984:
+		" %s Logical Unit: %u\n", lun->lun_sep->sep_rtpi,
 		                   ^

CHECK:CAMELCASE: Avoid CamelCase: <Logical>
#1054: FILE: drivers/target/target_core_configfs.c:984:
+		" %s Logical Unit: %u\n", lun->lun_sep->sep_rtpi,

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1065: FILE: drivers/target/target_core_configfs.c:995:
+ * res_pr_registered_i_pts$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1066: FILE: drivers/target/target_core_configfs.c:996:
+ */$

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1083: FILE: drivers/target/target_core_configfs.c:1013:
+	len += sprintf(page+len, "SPC-3 PR Registrations:\n");
 	                             ^

CHECK:SPACING: spaces required around that ':' (ctx:VxV)
#1083: FILE: drivers/target/target_core_configfs.c:1013:
+	len += sprintf(page+len, "SPC-3 PR Registrations:\n");
 	                                                ^

CHECK:CAMELCASE: Avoid CamelCase: <Registrations>
#1083: FILE: drivers/target/target_core_configfs.c:1013:
+	len += sprintf(page+len, "SPC-3 PR Registrations:\n");

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
 		              ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
 		                     ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
 		                       ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
 		                             ^

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
 		                                 ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
 		                                             ^

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",
 		                                                 ^

CHECK:CAMELCASE: Avoid CamelCase: <Key>
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",

CHECK:CAMELCASE: Avoid CamelCase: <PRgen>
#1091: FILE: drivers/target/target_core_configfs.c:1021:
+		sprintf(buf, "%s Node: %s Key: 0x%016Lx PRgen: 0x%08x\n",

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1099: FILE: drivers/target/target_core_configfs.c:1029:
+		len += sprintf(page+len, "%s", buf);
 		                          ^

CHECK:CAMELCASE: Avoid CamelCase: <None>
#1105: FILE: drivers/target/target_core_configfs.c:1035:
+		len += sprintf(page+len, "None\n");

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1113: FILE: drivers/target/target_core_configfs.c:1043:
+ * res_pr_type$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1114: FILE: drivers/target/target_core_configfs.c:1044:
+ */$

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1133: FILE: drivers/target/target_core_configfs.c:1063:
+		len = sprintf(page, "No SPC-3 Reservation holder\n");
 		                           ^

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1137: FILE: drivers/target/target_core_configfs.c:1067:
+	len = sprintf(page, "SPC-3 Reservation Type: %s\n",
 	                        ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1137: FILE: drivers/target/target_core_configfs.c:1067:
+	len = sprintf(page, "SPC-3 Reservation Type: %s\n",
 	                                           ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1137: FILE: drivers/target/target_core_configfs.c:1067:
+	len = sprintf(page, "SPC-3 Reservation Type: %s\n",
 	                                             ^

CHECK:CAMELCASE: Avoid CamelCase: <Type>
#1137: FILE: drivers/target/target_core_configfs.c:1067:
+	len = sprintf(page, "SPC-3 Reservation Type: %s\n",

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1147: FILE: drivers/target/target_core_configfs.c:1077:
+ * res_type$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1148: FILE: drivers/target/target_core_configfs.c:1078:
+ */$

ERROR:SPACING: spaces required around that '>' (ctx:VxV)
#1250: FILE: drivers/target/target_core_configfs.c:1178:
+		printk(KERN_ERR "Unable to locate se_subsystem_dev_t>se"
 		                                                    ^

WARNING:MISSING_SPACE: break quoted strings at a space character
#1251: FILE: drivers/target/target_core_configfs.c:1179:
+		printk(KERN_ERR "Unable to locate se_subsystem_dev_t>se"
+				"_dev_su_ptr\n");

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1294: FILE: drivers/target/target_core_configfs.c:1220:
+			"_fd() NULL for: %s\n", hba->transport->name);
 			               ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1294: FILE: drivers/target/target_core_configfs.c:1220:
+			"_fd() NULL for: %s\n", hba->transport->name);
 			                 ^

WARNING:MISSING_SPACE: break quoted strings at a space character
#1294: FILE: drivers/target/target_core_configfs.c:1220:
+		printk(KERN_ERR "se_subsystem_api_t->create_virtdevice_from"
+			"_fd() NULL for: %s\n", hba->transport->name);

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1306: FILE: drivers/target/target_core_configfs.c:1232:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered %s se_dev->se_dev"
 	                                      ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1306: FILE: drivers/target/target_core_configfs.c:1232:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered %s se_dev->se_dev"
 	                                                   ^

CHECK:CAMELCASE: Avoid CamelCase: <Registered>
#1306: FILE: drivers/target/target_core_configfs.c:1232:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered %s se_dev->se_dev"

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1307: FILE: drivers/target/target_core_configfs.c:1233:
+		"_ptr: %p from fd\n", hba->transport->name, se_dev->se_dev_ptr);
 		     ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1307: FILE: drivers/target/target_core_configfs.c:1233:
+		"_ptr: %p from fd\n", hba->transport->name, se_dev->se_dev_ptr);
 		       ^

WARNING:MISSING_SPACE: break quoted strings at a space character
#1307: FILE: drivers/target/target_core_configfs.c:1233:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered %s se_dev->se_dev"
+		"_ptr: %p from fd\n", hba->transport->name, se_dev->se_dev_ptr);

CHECK:CAMELCASE: Avoid CamelCase: <For>
#1336: FILE: drivers/target/target_core_configfs.c:1261:
+		printk(KERN_ERR "For dev_enable ops, only valid value"

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'se_dev->se_dev_ptr'
#1340: FILE: drivers/target/target_core_configfs.c:1265:
+	if ((se_dev->se_dev_ptr)) {

Parentheses are not required in the following cases:

  1. Function pointer uses::

      (foo->bar)();

    could be::

      foo->bar();

  2. Comparisons in if::

      if ((foo->bar) && (foo->baz))
      if ((foo == bar))

    could be::

      if (foo->bar && foo->baz)
      if (foo == bar)

  3. addressof/dereference single Lvalues::

      &(foo->bar)
      *(foo->bar)

    could be::

      &foo->bar
      *foo->bar

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#1341: FILE: drivers/target/target_core_configfs.c:1266:
+		printk(KERN_ERR "se_dev->se_dev_ptr already set for storage"

WARNING:SPLIT_STRING: quoted string split across lines
#1342: FILE: drivers/target/target_core_configfs.c:1267:
+		printk(KERN_ERR "se_dev->se_dev_ptr already set for storage"
+				" object\n");

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'ret != 0'
#1348: FILE: drivers/target/target_core_configfs.c:1273:
+	if (!t || (ret != 0))

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#1359: FILE: drivers/target/target_core_configfs.c:1284:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered

WARNING:UNNECESSARY_MODIFIER: Integer promotion: Using 'h' in '%hu' is unnecessary
#1359: FILE: drivers/target/target_core_configfs.c:1284:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered
se_dev->se_dev_ptr:"
+		" %p\n", se_dev->se_dev_ptr);
+
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_enable = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "enable",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_enable,
+};
+
+static ssize_t target_core_show_alua_lu_gp(void *p, char *page)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	struct config_item *lu_ci;
+	t10_alua_lu_gp_t *lu_gp;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED)
+		return len;
+
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		lu_ci = &lu_gp->lu_gp_group.cg_item;
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
+			config_item_name(lu_ci), lu_gp->lu_gp_id);
+	}
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	return len;
+}
+
+static ssize_t target_core_store_alua_lu_gp(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = su_dev->se_dev_hba;
+	t10_alua_lu_gp_t *lu_gp = NULL, *lu_gp_new = NULL;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+	int move = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED) {
+		printk(KERN_WARNING "SPC3_ALUA_EMULATED not enabled for %s/%s\n",
+			config_item_name(&hba->hba_group.cg_item),
+			config_item_name(&su_dev->se_dev_group.cg_item));
+		return -EINVAL;
+	}
+	if (count > LU_GROUP_NAME_BUF) {
+		printk(KERN_ERR "ALUA LU Group Alias too large!\n");
+		return -EINVAL;
+	}
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+	memcpy(buf, page, count);
+	/*
+	 * Any ALUA logical unit alias besides "NULL" means we will be
+	 * making a new group association.
+	 */
+	if (strcmp(strstrip(buf), "NULL")) {
+		/*
+		 * core_alua_get_lu_gp_by_name() will increment reference to
+		 * t10_alua_lu_gp_t.  This reference is released with
+		 * core_alua_get_lu_gp_by_name below().
+		 */
+		lu_gp_new = core_alua_get_lu_gp_by_name(strstrip(buf));
+		if (!(lu_gp_new))
+			return -ENODEV;
+	}
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		if (lu_gp_new)
+			core_alua_put_lu_gp_from_name(lu_gp_new);
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		/*
+		 * Clearing an existing lu_gp association, and replacing
+		 * with NULL
+		 */
+		if (!(lu_gp_new)) {
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
+				" %hu\n",
+				config_item_name(&hba->hba_group.cg_item),
+				config_item_name(&su_dev->se_dev_group.cg_item),
+				config_item_name(&lu_gp->lu_gp_group.cg_item),
+				lu_gp->lu_gp_id);
+
+			__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+			spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+			return count;
+		}
+		/*
+		 * Removing existing association of lu_gp_mem with lu_gp
+		 */
+		__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+		move = 1;
+	}
+	/*
+	 * Associate lu_gp_mem with lu_gp_new.
+	 */
+	__core_alua_attach_lu_gp_mem(lu_gp_mem, lu_gp_new);
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
+		" core/alua/lu_gps/%s, ID: %hu\n",
+		(move) ? "Moving" : "Adding",
+		config_item_name(&hba->hba_group.cg_item),
+		config_item_name(&su_dev->se_dev_group.cg_item),
+		config_item_name(&lu_gp_new->lu_gp_group.cg_item),
+		lu_gp_new->lu_gp_id);
+
+	core_alua_put_lu_gp_from_name(lu_gp_new);
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_alua_lu_gp = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "alua_lu_gp",
+		    .ca_mode = S_IRUGO | S_IWUSR },
+	.show	= target_core_show_alua_lu_gp,
+	.store	= target_core_store_alua_lu_gp,
+};
+
+static struct configfs_attribute *lio_core_dev_attrs[] = {
+	&target_core_attr_dev_info.attr,
+	&target_core_attr_dev_control.attr,
+	&target_core_attr_dev_fd.attr,
+	&target_core_attr_dev_enable.attr,
+	&target_core_attr_dev_alua_lu_gp.attr,
+	NULL,
+};
+
+static ssize_t target_core_dev_show(struct config_item *item,
+				     struct configfs_attribute *attr,
+				     char *page)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->show))
+		return -EINVAL;
+
+	return tc_attr->show((void *)se_dev, page);
+}
+
+static ssize_t target_core_dev_store(struct config_item *item,
+				      struct configfs_attribute *attr,
+				      const char *page, size_t count)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->store))
+		return -EINVAL;
+
+	return tc_attr->store((void *)se_dev, page, count);
+}
+
+static struct configfs_item_operations target_core_dev_item_ops = {
+	.release		= NULL,
+	.show_attribute		= target_core_dev_show,
+	.store_attribute	= target_core_dev_store,
+};
+
+static struct config_item_type target_core_dev_cit = {
+	.ct_item_ops		= &target_core_dev_item_ops,
+	.ct_attrs		= lio_core_dev_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/* End functions for struct config_item_type target_core_dev_cit */
+
+/* Start functions for struct config_item_type
target_core_alua_lu_gp_cit */
+
+CONFIGFS_EATTR_STRUCT(target_core_alua_lu_gp, t10_alua_lu_gp_s);
+#define SE_DEV_ALUA_LU_ATTR_RO(_name)					\
+static struct target_core_alua_lu_gp_attribute				\
+			target_core_alua_lu_gp_##_name =		\
+	__CONFIGFS_EATTR_RO(_name,					\
+	target_core_alua_lu_gp_show_attr_##_name);
+
+/*
+ * alua_access_state
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_alua_access_state(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%d\n", lu_gp->lu_gp_alua_access_state);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(alua_access_state);
+
+/*
+ * lu_gp_id
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_lu_gp_id(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%hu\n", lu_gp->lu_gp_id);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(lu_gp_id);
+
+/*
+ * members
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_members(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	se_device_t *dev;
+	se_hba_t *hba;
+	se_subsystem_dev_t *su_dev;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0, cur_len;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+
+	spin_lock(&lu_gp->lu_gp_lock);
+	list_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list, lu_gp_mem_list)
{
+		dev = lu_gp_mem->lu_gp_mem_dev;
+		su_dev = dev->se_sub_dev;
+		hba = su_dev->se_dev_hba;
+
+		cur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",
+			config_item_name(&su_dev->se_dev_group.cg_item),
+			config_item_name(&hba->hba_group.cg_item));
+		cur_len++; /* Extra byte for NULL terminator */
+
+		if ((cur_len + len) > PAGE_SIZE) {
+			printk(KERN_WARNING "Ran out of lu_gp_show_attr"
+				"_members buffer\n");
+			break;
+		}
+		memcpy(page+len, buf, cur_len);
+		len += cur_len;
+	}
+	spin_unlock(&lu_gp->lu_gp_lock);
+
+	return len;
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(members);
+
+CONFIGFS_EATTR_OPS_RO(target_core_alua_lu_gp, t10_alua_lu_gp_s,
lu_gp_group);

WARNING:UNNECESSARY_MODIFIER: Integer promotion: Using 'h' in '%hu' is unnecessary
#1359: FILE: drivers/target/target_core_configfs.c:1284:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered
se_dev->se_dev_ptr:"
+		" %p\n", se_dev->se_dev_ptr);
+
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_enable = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "enable",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_enable,
+};
+
+static ssize_t target_core_show_alua_lu_gp(void *p, char *page)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	struct config_item *lu_ci;
+	t10_alua_lu_gp_t *lu_gp;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED)
+		return len;
+
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		lu_ci = &lu_gp->lu_gp_group.cg_item;
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
+			config_item_name(lu_ci), lu_gp->lu_gp_id);
+	}
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	return len;
+}
+
+static ssize_t target_core_store_alua_lu_gp(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = su_dev->se_dev_hba;
+	t10_alua_lu_gp_t *lu_gp = NULL, *lu_gp_new = NULL;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+	int move = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED) {
+		printk(KERN_WARNING "SPC3_ALUA_EMULATED not enabled for %s/%s\n",
+			config_item_name(&hba->hba_group.cg_item),
+			config_item_name(&su_dev->se_dev_group.cg_item));
+		return -EINVAL;
+	}
+	if (count > LU_GROUP_NAME_BUF) {
+		printk(KERN_ERR "ALUA LU Group Alias too large!\n");
+		return -EINVAL;
+	}
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+	memcpy(buf, page, count);
+	/*
+	 * Any ALUA logical unit alias besides "NULL" means we will be
+	 * making a new group association.
+	 */
+	if (strcmp(strstrip(buf), "NULL")) {
+		/*
+		 * core_alua_get_lu_gp_by_name() will increment reference to
+		 * t10_alua_lu_gp_t.  This reference is released with
+		 * core_alua_get_lu_gp_by_name below().
+		 */
+		lu_gp_new = core_alua_get_lu_gp_by_name(strstrip(buf));
+		if (!(lu_gp_new))
+			return -ENODEV;
+	}
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		if (lu_gp_new)
+			core_alua_put_lu_gp_from_name(lu_gp_new);
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		/*
+		 * Clearing an existing lu_gp association, and replacing
+		 * with NULL
+		 */
+		if (!(lu_gp_new)) {
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
+				" %hu\n",
+				config_item_name(&hba->hba_group.cg_item),
+				config_item_name(&su_dev->se_dev_group.cg_item),
+				config_item_name(&lu_gp->lu_gp_group.cg_item),
+				lu_gp->lu_gp_id);
+
+			__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+			spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+			return count;
+		}
+		/*
+		 * Removing existing association of lu_gp_mem with lu_gp
+		 */
+		__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+		move = 1;
+	}
+	/*
+	 * Associate lu_gp_mem with lu_gp_new.
+	 */
+	__core_alua_attach_lu_gp_mem(lu_gp_mem, lu_gp_new);
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
+		" core/alua/lu_gps/%s, ID: %hu\n",
+		(move) ? "Moving" : "Adding",
+		config_item_name(&hba->hba_group.cg_item),
+		config_item_name(&su_dev->se_dev_group.cg_item),
+		config_item_name(&lu_gp_new->lu_gp_group.cg_item),
+		lu_gp_new->lu_gp_id);
+
+	core_alua_put_lu_gp_from_name(lu_gp_new);
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_alua_lu_gp = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "alua_lu_gp",
+		    .ca_mode = S_IRUGO | S_IWUSR },
+	.show	= target_core_show_alua_lu_gp,
+	.store	= target_core_store_alua_lu_gp,
+};
+
+static struct configfs_attribute *lio_core_dev_attrs[] = {
+	&target_core_attr_dev_info.attr,
+	&target_core_attr_dev_control.attr,
+	&target_core_attr_dev_fd.attr,
+	&target_core_attr_dev_enable.attr,
+	&target_core_attr_dev_alua_lu_gp.attr,
+	NULL,
+};
+
+static ssize_t target_core_dev_show(struct config_item *item,
+				     struct configfs_attribute *attr,
+				     char *page)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->show))
+		return -EINVAL;
+
+	return tc_attr->show((void *)se_dev, page);
+}
+
+static ssize_t target_core_dev_store(struct config_item *item,
+				      struct configfs_attribute *attr,
+				      const char *page, size_t count)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->store))
+		return -EINVAL;
+
+	return tc_attr->store((void *)se_dev, page, count);
+}
+
+static struct configfs_item_operations target_core_dev_item_ops = {
+	.release		= NULL,
+	.show_attribute		= target_core_dev_show,
+	.store_attribute	= target_core_dev_store,
+};
+
+static struct config_item_type target_core_dev_cit = {
+	.ct_item_ops		= &target_core_dev_item_ops,
+	.ct_attrs		= lio_core_dev_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/* End functions for struct config_item_type target_core_dev_cit */
+
+/* Start functions for struct config_item_type
target_core_alua_lu_gp_cit */
+
+CONFIGFS_EATTR_STRUCT(target_core_alua_lu_gp, t10_alua_lu_gp_s);
+#define SE_DEV_ALUA_LU_ATTR_RO(_name)					\
+static struct target_core_alua_lu_gp_attribute				\
+			target_core_alua_lu_gp_##_name =		\
+	__CONFIGFS_EATTR_RO(_name,					\
+	target_core_alua_lu_gp_show_attr_##_name);
+
+/*
+ * alua_access_state
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_alua_access_state(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%d\n", lu_gp->lu_gp_alua_access_state);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(alua_access_state);
+
+/*
+ * lu_gp_id
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_lu_gp_id(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%hu\n", lu_gp->lu_gp_id);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(lu_gp_id);
+
+/*
+ * members
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_members(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	se_device_t *dev;
+	se_hba_t *hba;
+	se_subsystem_dev_t *su_dev;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0, cur_len;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+
+	spin_lock(&lu_gp->lu_gp_lock);
+	list_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list, lu_gp_mem_list)
{
+		dev = lu_gp_mem->lu_gp_mem_dev;
+		su_dev = dev->se_sub_dev;
+		hba = su_dev->se_dev_hba;
+
+		cur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",
+			config_item_name(&su_dev->se_dev_group.cg_item),
+			config_item_name(&hba->hba_group.cg_item));
+		cur_len++; /* Extra byte for NULL terminator */
+
+		if ((cur_len + len) > PAGE_SIZE) {
+			printk(KERN_WARNING "Ran out of lu_gp_show_attr"
+				"_members buffer\n");
+			break;
+		}
+		memcpy(page+len, buf, cur_len);
+		len += cur_len;
+	}
+	spin_unlock(&lu_gp->lu_gp_lock);
+
+	return len;
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(members);
+
+CONFIGFS_EATTR_OPS_RO(target_core_alua_lu_gp, t10_alua_lu_gp_s,
lu_gp_group);

WARNING:UNNECESSARY_MODIFIER: Integer promotion: Using 'h' in '%hu' is unnecessary
#1359: FILE: drivers/target/target_core_configfs.c:1284:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered
se_dev->se_dev_ptr:"
+		" %p\n", se_dev->se_dev_ptr);
+
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_enable = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "enable",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_enable,
+};
+
+static ssize_t target_core_show_alua_lu_gp(void *p, char *page)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	struct config_item *lu_ci;
+	t10_alua_lu_gp_t *lu_gp;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED)
+		return len;
+
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		lu_ci = &lu_gp->lu_gp_group.cg_item;
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
+			config_item_name(lu_ci), lu_gp->lu_gp_id);
+	}
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	return len;
+}
+
+static ssize_t target_core_store_alua_lu_gp(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = su_dev->se_dev_hba;
+	t10_alua_lu_gp_t *lu_gp = NULL, *lu_gp_new = NULL;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+	int move = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED) {
+		printk(KERN_WARNING "SPC3_ALUA_EMULATED not enabled for %s/%s\n",
+			config_item_name(&hba->hba_group.cg_item),
+			config_item_name(&su_dev->se_dev_group.cg_item));
+		return -EINVAL;
+	}
+	if (count > LU_GROUP_NAME_BUF) {
+		printk(KERN_ERR "ALUA LU Group Alias too large!\n");
+		return -EINVAL;
+	}
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+	memcpy(buf, page, count);
+	/*
+	 * Any ALUA logical unit alias besides "NULL" means we will be
+	 * making a new group association.
+	 */
+	if (strcmp(strstrip(buf), "NULL")) {
+		/*
+		 * core_alua_get_lu_gp_by_name() will increment reference to
+		 * t10_alua_lu_gp_t.  This reference is released with
+		 * core_alua_get_lu_gp_by_name below().
+		 */
+		lu_gp_new = core_alua_get_lu_gp_by_name(strstrip(buf));
+		if (!(lu_gp_new))
+			return -ENODEV;
+	}
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		if (lu_gp_new)
+			core_alua_put_lu_gp_from_name(lu_gp_new);
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		/*
+		 * Clearing an existing lu_gp association, and replacing
+		 * with NULL
+		 */
+		if (!(lu_gp_new)) {
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
+				" %hu\n",
+				config_item_name(&hba->hba_group.cg_item),
+				config_item_name(&su_dev->se_dev_group.cg_item),
+				config_item_name(&lu_gp->lu_gp_group.cg_item),
+				lu_gp->lu_gp_id);
+
+			__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+			spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+			return count;
+		}
+		/*
+		 * Removing existing association of lu_gp_mem with lu_gp
+		 */
+		__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+		move = 1;
+	}
+	/*
+	 * Associate lu_gp_mem with lu_gp_new.
+	 */
+	__core_alua_attach_lu_gp_mem(lu_gp_mem, lu_gp_new);
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
+		" core/alua/lu_gps/%s, ID: %hu\n",
+		(move) ? "Moving" : "Adding",
+		config_item_name(&hba->hba_group.cg_item),
+		config_item_name(&su_dev->se_dev_group.cg_item),
+		config_item_name(&lu_gp_new->lu_gp_group.cg_item),
+		lu_gp_new->lu_gp_id);
+
+	core_alua_put_lu_gp_from_name(lu_gp_new);
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_alua_lu_gp = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "alua_lu_gp",
+		    .ca_mode = S_IRUGO | S_IWUSR },
+	.show	= target_core_show_alua_lu_gp,
+	.store	= target_core_store_alua_lu_gp,
+};
+
+static struct configfs_attribute *lio_core_dev_attrs[] = {
+	&target_core_attr_dev_info.attr,
+	&target_core_attr_dev_control.attr,
+	&target_core_attr_dev_fd.attr,
+	&target_core_attr_dev_enable.attr,
+	&target_core_attr_dev_alua_lu_gp.attr,
+	NULL,
+};
+
+static ssize_t target_core_dev_show(struct config_item *item,
+				     struct configfs_attribute *attr,
+				     char *page)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->show))
+		return -EINVAL;
+
+	return tc_attr->show((void *)se_dev, page);
+}
+
+static ssize_t target_core_dev_store(struct config_item *item,
+				      struct configfs_attribute *attr,
+				      const char *page, size_t count)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->store))
+		return -EINVAL;
+
+	return tc_attr->store((void *)se_dev, page, count);
+}
+
+static struct configfs_item_operations target_core_dev_item_ops = {
+	.release		= NULL,
+	.show_attribute		= target_core_dev_show,
+	.store_attribute	= target_core_dev_store,
+};
+
+static struct config_item_type target_core_dev_cit = {
+	.ct_item_ops		= &target_core_dev_item_ops,
+	.ct_attrs		= lio_core_dev_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/* End functions for struct config_item_type target_core_dev_cit */
+
+/* Start functions for struct config_item_type
target_core_alua_lu_gp_cit */
+
+CONFIGFS_EATTR_STRUCT(target_core_alua_lu_gp, t10_alua_lu_gp_s);
+#define SE_DEV_ALUA_LU_ATTR_RO(_name)					\
+static struct target_core_alua_lu_gp_attribute				\
+			target_core_alua_lu_gp_##_name =		\
+	__CONFIGFS_EATTR_RO(_name,					\
+	target_core_alua_lu_gp_show_attr_##_name);
+
+/*
+ * alua_access_state
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_alua_access_state(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%d\n", lu_gp->lu_gp_alua_access_state);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(alua_access_state);
+
+/*
+ * lu_gp_id
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_lu_gp_id(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%hu\n", lu_gp->lu_gp_id);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(lu_gp_id);
+
+/*
+ * members
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_members(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	se_device_t *dev;
+	se_hba_t *hba;
+	se_subsystem_dev_t *su_dev;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0, cur_len;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+
+	spin_lock(&lu_gp->lu_gp_lock);
+	list_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list, lu_gp_mem_list)
{
+		dev = lu_gp_mem->lu_gp_mem_dev;
+		su_dev = dev->se_sub_dev;
+		hba = su_dev->se_dev_hba;
+
+		cur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",
+			config_item_name(&su_dev->se_dev_group.cg_item),
+			config_item_name(&hba->hba_group.cg_item));
+		cur_len++; /* Extra byte for NULL terminator */
+
+		if ((cur_len + len) > PAGE_SIZE) {
+			printk(KERN_WARNING "Ran out of lu_gp_show_attr"
+				"_members buffer\n");
+			break;
+		}
+		memcpy(page+len, buf, cur_len);
+		len += cur_len;
+	}
+	spin_unlock(&lu_gp->lu_gp_lock);
+
+	return len;
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(members);
+
+CONFIGFS_EATTR_OPS_RO(target_core_alua_lu_gp, t10_alua_lu_gp_s,
lu_gp_group);

WARNING:UNNECESSARY_MODIFIER: Integer promotion: Using 'h' in '%hu' is unnecessary
#1359: FILE: drivers/target/target_core_configfs.c:1284:
+	printk(KERN_INFO "Target_Core_ConfigFS: Registered
se_dev->se_dev_ptr:"
+		" %p\n", se_dev->se_dev_ptr);
+
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_enable = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "enable",
+		    .ca_mode = S_IWUSR },
+	.show	= NULL,
+	.store	= target_core_store_dev_enable,
+};
+
+static ssize_t target_core_show_alua_lu_gp(void *p, char *page)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	struct config_item *lu_ci;
+	t10_alua_lu_gp_t *lu_gp;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED)
+		return len;
+
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		lu_ci = &lu_gp->lu_gp_group.cg_item;
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
+			config_item_name(lu_ci), lu_gp->lu_gp_id);
+	}
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	return len;
+}
+
+static ssize_t target_core_store_alua_lu_gp(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	se_device_t *dev;
+	se_subsystem_dev_t *su_dev = (se_subsystem_dev_t *)p;
+	se_hba_t *hba = su_dev->se_dev_hba;
+	t10_alua_lu_gp_t *lu_gp = NULL, *lu_gp_new = NULL;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+	int move = 0;
+
+	dev = su_dev->se_dev_ptr;
+	if (!(dev))
+		return -ENODEV;
+
+	if (T10_ALUA(su_dev)->alua_type != SPC3_ALUA_EMULATED) {
+		printk(KERN_WARNING "SPC3_ALUA_EMULATED not enabled for %s/%s\n",
+			config_item_name(&hba->hba_group.cg_item),
+			config_item_name(&su_dev->se_dev_group.cg_item));
+		return -EINVAL;
+	}
+	if (count > LU_GROUP_NAME_BUF) {
+		printk(KERN_ERR "ALUA LU Group Alias too large!\n");
+		return -EINVAL;
+	}
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+	memcpy(buf, page, count);
+	/*
+	 * Any ALUA logical unit alias besides "NULL" means we will be
+	 * making a new group association.
+	 */
+	if (strcmp(strstrip(buf), "NULL")) {
+		/*
+		 * core_alua_get_lu_gp_by_name() will increment reference to
+		 * t10_alua_lu_gp_t.  This reference is released with
+		 * core_alua_get_lu_gp_by_name below().
+		 */
+		lu_gp_new = core_alua_get_lu_gp_by_name(strstrip(buf));
+		if (!(lu_gp_new))
+			return -ENODEV;
+	}
+	lu_gp_mem = dev->dev_alua_lu_gp_mem;
+	if (!(lu_gp_mem)) {
+		if (lu_gp_new)
+			core_alua_put_lu_gp_from_name(lu_gp_new);
+		printk(KERN_ERR "NULL se_device_t->dev_alua_lu_gp_mem"
+				" pointer\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&lu_gp_mem->lu_gp_mem_lock);
+	lu_gp = lu_gp_mem->lu_gp;
+	if ((lu_gp)) {
+		/*
+		 * Clearing an existing lu_gp association, and replacing
+		 * with NULL
+		 */
+		if (!(lu_gp_new)) {
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
+				" %hu\n",
+				config_item_name(&hba->hba_group.cg_item),
+				config_item_name(&su_dev->se_dev_group.cg_item),
+				config_item_name(&lu_gp->lu_gp_group.cg_item),
+				lu_gp->lu_gp_id);
+
+			__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+			spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+			return count;
+		}
+		/*
+		 * Removing existing association of lu_gp_mem with lu_gp
+		 */
+		__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);
+		move = 1;
+	}
+	/*
+	 * Associate lu_gp_mem with lu_gp_new.
+	 */
+	__core_alua_attach_lu_gp_mem(lu_gp_mem, lu_gp_new);
+	spin_unlock(&lu_gp_mem->lu_gp_mem_lock);
+
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
+		" core/alua/lu_gps/%s, ID: %hu\n",
+		(move) ? "Moving" : "Adding",
+		config_item_name(&hba->hba_group.cg_item),
+		config_item_name(&su_dev->se_dev_group.cg_item),
+		config_item_name(&lu_gp_new->lu_gp_group.cg_item),
+		lu_gp_new->lu_gp_id);
+
+	core_alua_put_lu_gp_from_name(lu_gp_new);
+	return count;
+}
+
+static struct target_core_configfs_attribute
target_core_attr_dev_alua_lu_gp = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "alua_lu_gp",
+		    .ca_mode = S_IRUGO | S_IWUSR },
+	.show	= target_core_show_alua_lu_gp,
+	.store	= target_core_store_alua_lu_gp,
+};
+
+static struct configfs_attribute *lio_core_dev_attrs[] = {
+	&target_core_attr_dev_info.attr,
+	&target_core_attr_dev_control.attr,
+	&target_core_attr_dev_fd.attr,
+	&target_core_attr_dev_enable.attr,
+	&target_core_attr_dev_alua_lu_gp.attr,
+	NULL,
+};
+
+static ssize_t target_core_dev_show(struct config_item *item,
+				     struct configfs_attribute *attr,
+				     char *page)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->show))
+		return -EINVAL;
+
+	return tc_attr->show((void *)se_dev, page);
+}
+
+static ssize_t target_core_dev_store(struct config_item *item,
+				      struct configfs_attribute *attr,
+				      const char *page, size_t count)
+{
+	se_subsystem_dev_t *se_dev = container_of(
+			to_config_group(item), se_subsystem_dev_t,
+			se_dev_group);
+	struct target_core_configfs_attribute *tc_attr = container_of(
+			attr, struct target_core_configfs_attribute, attr);
+
+	if (!(tc_attr->store))
+		return -EINVAL;
+
+	return tc_attr->store((void *)se_dev, page, count);
+}
+
+static struct configfs_item_operations target_core_dev_item_ops = {
+	.release		= NULL,
+	.show_attribute		= target_core_dev_show,
+	.store_attribute	= target_core_dev_store,
+};
+
+static struct config_item_type target_core_dev_cit = {
+	.ct_item_ops		= &target_core_dev_item_ops,
+	.ct_attrs		= lio_core_dev_attrs,
+	.ct_owner		= THIS_MODULE,
+};
+
+/* End functions for struct config_item_type target_core_dev_cit */
+
+/* Start functions for struct config_item_type
target_core_alua_lu_gp_cit */
+
+CONFIGFS_EATTR_STRUCT(target_core_alua_lu_gp, t10_alua_lu_gp_s);
+#define SE_DEV_ALUA_LU_ATTR_RO(_name)					\
+static struct target_core_alua_lu_gp_attribute				\
+			target_core_alua_lu_gp_##_name =		\
+	__CONFIGFS_EATTR_RO(_name,					\
+	target_core_alua_lu_gp_show_attr_##_name);
+
+/*
+ * alua_access_state
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_alua_access_state(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%d\n", lu_gp->lu_gp_alua_access_state);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(alua_access_state);
+
+/*
+ * lu_gp_id
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_lu_gp_id(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	return sprintf(page, "%hu\n", lu_gp->lu_gp_id);
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(lu_gp_id);
+
+/*
+ * members
+ */
+static ssize_t target_core_alua_lu_gp_show_attr_members(
+	struct t10_alua_lu_gp_s *lu_gp,
+	char *page)
+{
+	se_device_t *dev;
+	se_hba_t *hba;
+	se_subsystem_dev_t *su_dev;
+	t10_alua_lu_gp_member_t *lu_gp_mem;
+	ssize_t len = 0, cur_len;
+	unsigned char buf[LU_GROUP_NAME_BUF];
+
+	memset(buf, 0, LU_GROUP_NAME_BUF);
+
+	spin_lock(&lu_gp->lu_gp_lock);
+	list_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list, lu_gp_mem_list)
{
+		dev = lu_gp_mem->lu_gp_mem_dev;
+		su_dev = dev->se_sub_dev;
+		hba = su_dev->se_dev_hba;
+
+		cur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",
+			config_item_name(&su_dev->se_dev_group.cg_item),
+			config_item_name(&hba->hba_group.cg_item));
+		cur_len++; /* Extra byte for NULL terminator */
+
+		if ((cur_len + len) > PAGE_SIZE) {
+			printk(KERN_WARNING "Ran out of lu_gp_show_attr"
+				"_members buffer\n");
+			break;
+		}
+		memcpy(page+len, buf, cur_len);
+		len += cur_len;
+	}
+	spin_unlock(&lu_gp->lu_gp_lock);
+
+	return len;
+}
+
+SE_DEV_ALUA_LU_ATTR_RO(members);
+
+CONFIGFS_EATTR_OPS_RO(target_core_alua_lu_gp, t10_alua_lu_gp_s,
lu_gp_group);

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1361: FILE: drivers/target/target_core_configfs.c:1285:
+		" %p\n", se_dev->se_dev_ptr);
 		  ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1402: FILE: drivers/target/target_core_configfs.c:1325:
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
 		                                    ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1402: FILE: drivers/target/target_core_configfs.c:1325:
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
 		                                      ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1402: FILE: drivers/target/target_core_configfs.c:1325:
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
 		                                                     ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1402: FILE: drivers/target/target_core_configfs.c:1325:
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",
 		                                                       ^

CHECK:CAMELCASE: Avoid CamelCase: <Alias>
#1402: FILE: drivers/target/target_core_configfs.c:1325:
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",

CHECK:CAMELCASE: Avoid CamelCase: <nLU>
#1402: FILE: drivers/target/target_core_configfs.c:1325:
+		len += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1428: FILE: drivers/target/target_core_configfs.c:1351:
+		printk(KERN_WARNING "SPC3_ALUA_EMULATED not enabled for %s/%s\n",
 		                                                        ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1428: FILE: drivers/target/target_core_configfs.c:1351:
+		printk(KERN_WARNING "SPC3_ALUA_EMULATED not enabled for %s/%s\n",
 		                                                          ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1428: FILE: drivers/target/target_core_configfs.c:1351:
+		printk(KERN_WARNING "SPC3_ALUA_EMULATED not enabled for %s/%s\n",
 		                                                           ^

ERROR:SPACING: space required before that '!' (ctx:VxV)
#1434: FILE: drivers/target/target_core_configfs.c:1357:
+		printk(KERN_ERR "ALUA LU Group Alias too large!\n");
 		                                              ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1470: FILE: drivers/target/target_core_configfs.c:1393:
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
 			                                      ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1470: FILE: drivers/target/target_core_configfs.c:1393:
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
 			                                                  ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1470: FILE: drivers/target/target_core_configfs.c:1393:
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
 			                                                    ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1470: FILE: drivers/target/target_core_configfs.c:1393:
+			printk(KERN_INFO "Target_Core_ConfigFS: Releasing %s/%s"
 			                                                     ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1471: FILE: drivers/target/target_core_configfs.c:1394:
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
 				                    ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1471: FILE: drivers/target/target_core_configfs.c:1394:
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
 				                          ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1471: FILE: drivers/target/target_core_configfs.c:1394:
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
 				                               ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1471: FILE: drivers/target/target_core_configfs.c:1394:
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
 				                                      ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1471: FILE: drivers/target/target_core_configfs.c:1394:
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
 				                                       ^

CHECK:SPACING: spaces required around that ':' (ctx:VxV)
#1471: FILE: drivers/target/target_core_configfs.c:1394:
+				" from ALUA LU Group: core/alua/lu_gps/%s, ID:"
 				                                             ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1472: FILE: drivers/target/target_core_configfs.c:1395:
+				" %hu\n",
 				  ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1495: FILE: drivers/target/target_core_configfs.c:1418:
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
 	                                      ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1495: FILE: drivers/target/target_core_configfs.c:1418:
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
 	                                        ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1495: FILE: drivers/target/target_core_configfs.c:1418:
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
 	                                           ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1495: FILE: drivers/target/target_core_configfs.c:1418:
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
 	                                             ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1495: FILE: drivers/target/target_core_configfs.c:1418:
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
 	                                              ^

CHECK:SPACING: spaces required around that ':' (ctx:VxV)
#1495: FILE: drivers/target/target_core_configfs.c:1418:
+	printk(KERN_INFO "Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"
 	                                                                 ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1496: FILE: drivers/target/target_core_configfs.c:1419:
+		" core/alua/lu_gps/%s, ID: %hu\n",
 		      ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1496: FILE: drivers/target/target_core_configfs.c:1419:
+		" core/alua/lu_gps/%s, ID: %hu\n",
 		           ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1496: FILE: drivers/target/target_core_configfs.c:1419:
+		" core/alua/lu_gps/%s, ID: %hu\n",
 		                  ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1496: FILE: drivers/target/target_core_configfs.c:1419:
+		" core/alua/lu_gps/%s, ID: %hu\n",
 		                   ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1496: FILE: drivers/target/target_core_configfs.c:1419:
+		" core/alua/lu_gps/%s, ID: %hu\n",
 		                         ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1496: FILE: drivers/target/target_core_configfs.c:1419:
+		" core/alua/lu_gps/%s, ID: %hu\n",
 		                           ^

CHECK:CAMELCASE: Avoid CamelCase: <Moving>
#1497: FILE: drivers/target/target_core_configfs.c:1420:
+		(move) ? "Moving" : "Adding",

CHECK:CAMELCASE: Avoid CamelCase: <Adding>
#1497: FILE: drivers/target/target_core_configfs.c:1420:
+		(move) ? "Moving" : "Adding",

CHECK:CONCATENATED_STRING: Concatenated strings should use spaces between elements
#1497: FILE: drivers/target/target_core_configfs.c:1420:
+		(move) ? "Moving" : "Adding",

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1582: FILE: drivers/target/target_core_configfs.c:1503:
+ * alua_access_state$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1583: FILE: drivers/target/target_core_configfs.c:1504:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1588: FILE: drivers/target/target_core_configfs.c:1509:
+	return sprintf(page, "%d\n", lu_gp->lu_gp_alua_access_state);
 	                      ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1594: FILE: drivers/target/target_core_configfs.c:1515:
+ * lu_gp_id$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1595: FILE: drivers/target/target_core_configfs.c:1516:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1600: FILE: drivers/target/target_core_configfs.c:1521:
+	return sprintf(page, "%hu\n", lu_gp->lu_gp_id);
 	                      ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1606: FILE: drivers/target/target_core_configfs.c:1527:
+ * members$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1607: FILE: drivers/target/target_core_configfs.c:1528:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1628: FILE: drivers/target/target_core_configfs.c:1548:
+		cur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",
 		                                            ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1628: FILE: drivers/target/target_core_configfs.c:1548:
+		cur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",
 		                                              ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1628: FILE: drivers/target/target_core_configfs.c:1548:
+		cur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",
 		                                               ^

CHECK:CAMELCASE: Avoid CamelCase: <Ran>
#1634: FILE: drivers/target/target_core_configfs.c:1554:
+			printk(KERN_WARNING "Ran out of lu_gp_show_attr"

WARNING:MISSING_SPACE: break quoted strings at a space character
#1635: FILE: drivers/target/target_core_configfs.c:1555:
+			printk(KERN_WARNING "Ran out of lu_gp_show_attr"
+				"_members buffer\n");

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1693: FILE: drivers/target/target_core_configfs.c:1610:
+	printk(KERN_INFO "Target_Core_ConfigFS: Allocated ALUA Logical Unit"
 	                                      ^

CHECK:CAMELCASE: Avoid CamelCase: <Allocated>
#1693: FILE: drivers/target/target_core_configfs.c:1610:
+	printk(KERN_INFO "Target_Core_ConfigFS: Allocated ALUA Logical Unit"

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1694: FILE: drivers/target/target_core_configfs.c:1611:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		       ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1694: FILE: drivers/target/target_core_configfs.c:1611:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		             ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1694: FILE: drivers/target/target_core_configfs.c:1611:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                  ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1694: FILE: drivers/target/target_core_configfs.c:1611:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                         ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1694: FILE: drivers/target/target_core_configfs.c:1611:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                          ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1694: FILE: drivers/target/target_core_configfs.c:1611:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                                ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1694: FILE: drivers/target/target_core_configfs.c:1611:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                                  ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1708: FILE: drivers/target/target_core_configfs.c:1625:
+	printk(KERN_INFO "Target_Core_ConfigFS: Releasing ALUA Logical Unit"
 	                                      ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1709: FILE: drivers/target/target_core_configfs.c:1626:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		       ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1709: FILE: drivers/target/target_core_configfs.c:1626:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		             ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1709: FILE: drivers/target/target_core_configfs.c:1626:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                  ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1709: FILE: drivers/target/target_core_configfs.c:1626:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                         ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1709: FILE: drivers/target/target_core_configfs.c:1626:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                          ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1709: FILE: drivers/target/target_core_configfs.c:1626:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                                ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1709: FILE: drivers/target/target_core_configfs.c:1626:
+		" Group: core/alua/lu_gps/%s, ID: %hu\n",
 		                                  ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1741: FILE: drivers/target/target_core_configfs.c:1655:
+ * alua_access_state$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1742: FILE: drivers/target/target_core_configfs.c:1656:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1747: FILE: drivers/target/target_core_configfs.c:1661:
+	return sprintf(page, "%d\n", tg_pt_gp->tg_pt_gp_alua_access_state);
 	                      ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1753: FILE: drivers/target/target_core_configfs.c:1667:
+ * tg_pt_gp_id$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1754: FILE: drivers/target/target_core_configfs.c:1668:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1759: FILE: drivers/target/target_core_configfs.c:1673:
+	return sprintf(page, "%hu\n", tg_pt_gp->tg_pt_gp_id);
 	                      ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1765: FILE: drivers/target/target_core_configfs.c:1679:
+ * members$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1766: FILE: drivers/target/target_core_configfs.c:1680:
+ */$

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1787: FILE: drivers/target/target_core_configfs.c:1701:
+		cur_len = snprintf(buf, TG_PT_GROUP_NAME_BUF, "%s/tpgt_%hu"
 		                                               ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1787: FILE: drivers/target/target_core_configfs.c:1701:
+		cur_len = snprintf(buf, TG_PT_GROUP_NAME_BUF, "%s/tpgt_%hu"
 		                                                 ^

CHECK:SPACING: spaces preferred around that '%' (ctx:VxV)
#1787: FILE: drivers/target/target_core_configfs.c:1701:
+		cur_len = snprintf(buf, TG_PT_GROUP_NAME_BUF, "%s/tpgt_%hu"
 		                                                       ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1788: FILE: drivers/target/target_core_configfs.c:1702:
+			"/%s\n", TPG_TFO(tpg)->tpg_get_wwn(tpg),
 			 ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1788: FILE: drivers/target/target_core_configfs.c:1702:
+			"/%s\n", TPG_TFO(tpg)->tpg_get_wwn(tpg),
 			  ^

WARNING:MISSING_SPACE: break quoted strings at a space character
#1795: FILE: drivers/target/target_core_configfs.c:1709:
+			printk(KERN_WARNING "Ran out of lu_gp_show_attr"
+				"_members buffer\n");

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1854: FILE: drivers/target/target_core_configfs.c:1765:
+	printk(KERN_INFO "Target_Core_ConfigFS: Allocated ALUA Target Port"
 	                                      ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1855: FILE: drivers/target/target_core_configfs.c:1766:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		       ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1855: FILE: drivers/target/target_core_configfs.c:1766:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		             ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1855: FILE: drivers/target/target_core_configfs.c:1766:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                  ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1855: FILE: drivers/target/target_core_configfs.c:1766:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                            ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1855: FILE: drivers/target/target_core_configfs.c:1766:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                             ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1855: FILE: drivers/target/target_core_configfs.c:1766:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                                   ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1855: FILE: drivers/target/target_core_configfs.c:1766:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                                     ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1868: FILE: drivers/target/target_core_configfs.c:1779:
+	printk(KERN_INFO "Target_Core_ConfigFS: Releasing ALUA Target Port"
 	                                      ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1869: FILE: drivers/target/target_core_configfs.c:1780:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		       ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1869: FILE: drivers/target/target_core_configfs.c:1780:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		             ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1869: FILE: drivers/target/target_core_configfs.c:1780:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                  ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxO)
#1869: FILE: drivers/target/target_core_configfs.c:1780:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                            ^

CHECK:SPACING: spaces preferred around that '%' (ctx:OxV)
#1869: FILE: drivers/target/target_core_configfs.c:1780:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                             ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#1869: FILE: drivers/target/target_core_configfs.c:1780:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                                   ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#1869: FILE: drivers/target/target_core_configfs.c:1780:
+		" Group: core/alua/tg_pt_gps/%s, ID: %hu\n",
 		                                     ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1893: FILE: drivers/target/target_core_configfs.c:1802:
+ * target_core_alua_cit is a ConfigFS group that lives under$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1894: FILE: drivers/target/target_core_configfs.c:1803:
+ * /sys/kernel/config/target/core/alua.  There are default groups$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1895: FILE: drivers/target/target_core_configfs.c:1804:
+ * core/alua/lu_gps and core/alua/tg_pt_gps that are attached to$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1896: FILE: drivers/target/target_core_configfs.c:1805:
+ * target_core_alua_cit in target_core_init_configfs() below.$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1897: FILE: drivers/target/target_core_configfs.c:1806:
+ */$

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'ret != 0'
#1940: FILE: drivers/target/target_core_configfs.c:1848:
+	if (!t || (ret != 0)) {

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#1947: FILE: drivers/target/target_core_configfs.c:1855:
+		printk(KERN_ERR "Unable to allocate memory for"

WARNING:SPLIT_STRING: quoted string split across lines
#1948: FILE: drivers/target/target_core_configfs.c:1856:
+		printk(KERN_ERR "Unable to allocate memory for"
+				" se_subsystem_dev_t\n");

CHECK:ALLOC_SIZEOF_STRUCT: Prefer kzalloc(sizeof(*dev_cg->default_groups)...) over kzalloc(sizeof(struct config_group)...)
#1963: FILE: drivers/target/target_core_configfs.c:1871:
+	dev_cg->default_groups = kzalloc(sizeof(struct config_group) * 4,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1964: FILE: drivers/target/target_core_configfs.c:1872:
+	dev_cg->default_groups = kzalloc(sizeof(struct config_group) * 4,
+			GFP_KERNEL);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#1972: FILE: drivers/target/target_core_configfs.c:1880:
+		printk(KERN_ERR "Unable to locate subsystem dependent pointer"

WARNING:SPLIT_STRING: quoted string split across lines
#1973: FILE: drivers/target/target_core_configfs.c:1881:
+		printk(KERN_ERR "Unable to locate subsystem dependent pointer"
+			" from allocate_virtdevice()\n");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1978: FILE: drivers/target/target_core_configfs.c:1886:
+	config_group_init_type_name(&se_dev->se_dev_group, name,
+			&target_core_dev_cit);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1980: FILE: drivers/target/target_core_configfs.c:1888:
+	config_group_init_type_name(&se_dev->se_dev_attrib.da_group, "attrib",
+			&target_core_dev_attrib_cit);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1982: FILE: drivers/target/target_core_configfs.c:1890:
+	config_group_init_type_name(&se_dev->se_dev_pr_group, "pr",
+			&target_core_dev_pr_cit);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1984: FILE: drivers/target/target_core_configfs.c:1892:
+	config_group_init_type_name(&se_dev->t10_wwn.t10_wwn_group, "wwn",
+			&target_core_dev_wwn_cit);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#1990: FILE: drivers/target/target_core_configfs.c:1898:
+	printk(KERN_INFO "Target_Core_ConfigFS: Allocated se_subsystem_dev_t:"

WARNING:SPLIT_STRING: quoted string split across lines
#1991: FILE: drivers/target/target_core_configfs.c:1899:
+	printk(KERN_INFO "Target_Core_ConfigFS: Allocated se_subsystem_dev_t:"
+		" %p se_dev_su_ptr: %p\n", se_dev, se_dev->se_dev_su_ptr);

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#2003: FILE: drivers/target/target_core_configfs.c:1911:
+static void target_core_call_freedev(

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2015: FILE: drivers/target/target_core_configfs.c:1923:
+		printk(KERN_ERR "Unable to locate se_hba_t from"

WARNING:SPLIT_STRING: quoted string split across lines
#2016: FILE: drivers/target/target_core_configfs.c:1924:
+		printk(KERN_ERR "Unable to locate se_hba_t from"
+				" se_subsystem_dev_t\n");

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'ret != 0'
#2026: FILE: drivers/target/target_core_configfs.c:1934:
+	if (!t || (ret != 0))

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#2035: FILE: drivers/target/target_core_configfs.c:1943:
+		printk(KERN_INFO "Target_Core_ConfigFS: Calling se_free_"

WARNING:SPLIT_STRING: quoted string split across lines
#2036: FILE: drivers/target/target_core_configfs.c:1944:
+		printk(KERN_INFO "Target_Core_ConfigFS: Calling se_free_"
+			"virtual_device() for se_dev_ptr: %p\n",

WARNING:MISSING_SPACE: break quoted strings at a space character
#2036: FILE: drivers/target/target_core_configfs.c:1944:
+		printk(KERN_INFO "Target_Core_ConfigFS: Calling se_free_"
+			"virtual_device() for se_dev_ptr: %p\n",

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#2046: FILE: drivers/target/target_core_configfs.c:1954:
+		printk(KERN_INFO "Target_Core_ConfigFS: Calling t->free_"

WARNING:SPLIT_STRING: quoted string split across lines
#2047: FILE: drivers/target/target_core_configfs.c:1955:
+		printk(KERN_INFO "Target_Core_ConfigFS: Calling t->free_"
+			"device() for se_dev_su_ptr: %p\n",

WARNING:MISSING_SPACE: break quoted strings at a space character
#2047: FILE: drivers/target/target_core_configfs.c:1955:
+		printk(KERN_INFO "Target_Core_ConfigFS: Calling t->free_"
+			"device() for se_dev_su_ptr: %p\n",

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#2053: FILE: drivers/target/target_core_configfs.c:1961:
+	printk(KERN_INFO "Target_Core_ConfigFS: Deallocating se_subsystem"

WARNING:SPLIT_STRING: quoted string split across lines
#2054: FILE: drivers/target/target_core_configfs.c:1962:
+	printk(KERN_INFO "Target_Core_ConfigFS: Deallocating se_subsystem"
+		"_dev_t: %p\n", se_dev);

WARNING:MISSING_SPACE: break quoted strings at a space character
#2054: FILE: drivers/target/target_core_configfs.c:1962:
+	printk(KERN_INFO "Target_Core_ConfigFS: Deallocating se_subsystem"
+		"_dev_t: %p\n", se_dev);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2068: FILE: drivers/target/target_core_configfs.c:1976:
+static ssize_t target_core_hba_show(struct config_item *item,
+				struct configfs_attribute *attr,

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2075: FILE: drivers/target/target_core_configfs.c:1983:
+		printk(KERN_ERR "Unable to locate se_hba_t\n");

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRUGO' are not preferred. Consider using octal permissions '0444'.
#2087: FILE: drivers/target/target_core_configfs.c:1995:
+	.ca_mode		= S_IRUGO,

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#2106: FILE: drivers/target/target_core_configfs.c:2014:
+static struct config_group *target_core_call_addhbatotarget(

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2119: FILE: drivers/target/target_core_configfs.c:2027:
+		printk(KERN_ERR "Passed *name strlen(): %d exceeds"

WARNING:SPLIT_STRING: quoted string split across lines
#2120: FILE: drivers/target/target_core_configfs.c:2028:
+		printk(KERN_ERR "Passed *name strlen(): %d exceeds"
+			" TARGET_CORE_NAME_MAX_LEN: %d\n", (int)strlen(name),

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2128: FILE: drivers/target/target_core_configfs.c:2036:
+		printk(KERN_ERR "Unable to locate \"_\" for $SUBSYSTEM_PLUGIN_

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#2154: FILE: drivers/target/target_core_configfs.c:2061:
+		printk(KERN_ERR "strict_strtoul() returned %d for"
 		                                           ^

WARNING:CONSIDER_KSTRTO: strict_strtoul is obsolete, use kstrtoul instead
#2154: FILE: drivers/target/target_core_configfs.c:2061:
+		printk(KERN_ERR "strict_strtoul() returned %d for"

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#2158: FILE: drivers/target/target_core_configfs.c:2065:
+	printk(KERN_INFO "Target_Core_ConfigFS: Located se_plugin: %p"
 	                                      ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#2158: FILE: drivers/target/target_core_configfs.c:2065:
+	printk(KERN_INFO "Target_Core_ConfigFS: Located se_plugin: %p"
 	                                                         ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#2158: FILE: drivers/target/target_core_configfs.c:2065:
+	printk(KERN_INFO "Target_Core_ConfigFS: Located se_plugin: %p"
 	                                                           ^

CHECK:CAMELCASE: Avoid CamelCase: <Located>
#2158: FILE: drivers/target/target_core_configfs.c:2065:
+	printk(KERN_INFO "Target_Core_ConfigFS: Located se_plugin: %p"

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#2159: FILE: drivers/target/target_core_configfs.c:2066:
+		" plugin_name: %s hba_type: %d plugin_dep_id: %lu\n",
 		             ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#2159: FILE: drivers/target/target_core_configfs.c:2066:
+		" plugin_name: %s hba_type: %d plugin_dep_id: %lu\n",
 		               ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#2159: FILE: drivers/target/target_core_configfs.c:2066:
+		" plugin_name: %s hba_type: %d plugin_dep_id: %lu\n",
 		                          ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#2159: FILE: drivers/target/target_core_configfs.c:2066:
+		" plugin_name: %s hba_type: %d plugin_dep_id: %lu\n",
 		                            ^

ERROR:SPACING: spaces required around that ':' (ctx:VxW)
#2159: FILE: drivers/target/target_core_configfs.c:2066:
+		" plugin_name: %s hba_type: %d plugin_dep_id: %lu\n",
 		                                            ^

CHECK:SPACING: spaces preferred around that '%' (ctx:WxV)
#2159: FILE: drivers/target/target_core_configfs.c:2066:
+		" plugin_name: %s hba_type: %d plugin_dep_id: %lu\n",
 		                                              ^

CHECK:LINE_SPACING: Please don't use multiple blank lines
#2183: FILE: drivers/target/target_core_configfs.c:2090:
+
+

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#2235: FILE: drivers/target/target_core_configfs.c:2141:
+	printk(KERN_INFO "TARGET_CORE[0]: Loading Generic Kernel Storage"

WARNING:SPLIT_STRING: quoted string split across lines
#2236: FILE: drivers/target/target_core_configfs.c:2142:
+	printk(KERN_INFO "TARGET_CORE[0]: Loading Generic Kernel Storage"
+		" Engine: %s on %s/%s on "UTS_RELEASE"\n",

CHECK:CONCATENATED_STRING: Concatenated strings should use spaces between elements
#2236: FILE: drivers/target/target_core_configfs.c:2142:
+		" Engine: %s on %s/%s on "UTS_RELEASE"\n",

CHECK:ALLOC_SIZEOF_STRUCT: Prefer kzalloc(sizeof(*target_cg->default_groups)...) over kzalloc(sizeof(struct config_group)...)
#2257: FILE: drivers/target/target_core_configfs.c:2162:
+	target_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2258: FILE: drivers/target/target_core_configfs.c:2163:
+	target_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,
+				GFP_KERNEL);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2260: FILE: drivers/target/target_core_configfs.c:2165:
+		printk(KERN_ERR "Unable to allocate target_cg->default_groups\n");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2265: FILE: drivers/target/target_core_configfs.c:2170:
+	config_group_init_type_name(&se_global->target_core_hbagroup,
+			"core", &target_core_cit);

CHECK:ALLOC_SIZEOF_STRUCT: Prefer kzalloc(sizeof(*hba_cg->default_groups)...) over kzalloc(sizeof(struct config_group)...)
#2273: FILE: drivers/target/target_core_configfs.c:2177:
+	hba_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2274: FILE: drivers/target/target_core_configfs.c:2178:
+	hba_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,
+				GFP_KERNEL);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2276: FILE: drivers/target/target_core_configfs.c:2180:
+		printk(KERN_ERR "Unable to allocate hba_cg->default_groups\n");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2280: FILE: drivers/target/target_core_configfs.c:2184:
+	config_group_init_type_name(&se_global->alua_group,
+			"alua", &target_core_alua_cit);

CHECK:ALLOC_SIZEOF_STRUCT: Prefer kzalloc(sizeof(*alua_cg->default_groups)...) over kzalloc(sizeof(struct config_group)...)
#2288: FILE: drivers/target/target_core_configfs.c:2192:
+	alua_cg->default_groups = kzalloc(sizeof(struct config_group) * 3,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2289: FILE: drivers/target/target_core_configfs.c:2193:
+	alua_cg->default_groups = kzalloc(sizeof(struct config_group) * 3,
+			GFP_KERNEL);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2291: FILE: drivers/target/target_core_configfs.c:2195:
+		printk(KERN_ERR "Unable to allocate alua_cg->default_groups\n");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2296: FILE: drivers/target/target_core_configfs.c:2200:
+	config_group_init_type_name(&se_global->alua_lu_gps_group,
+			"lu_gps", &target_core_alua_lu_gps_cit);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2298: FILE: drivers/target/target_core_configfs.c:2202:
+	config_group_init_type_name(&se_global->alua_tg_pt_gps_group,
+			"tg_pt_gps", &target_core_alua_tg_pt_gps_cit);

CHECK:ALLOC_SIZEOF_STRUCT: Prefer kzalloc(sizeof(*lu_gp_cg->default_groups)...) over kzalloc(sizeof(struct config_group)...)
#2310: FILE: drivers/target/target_core_configfs.c:2214:
+	lu_gp_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2311: FILE: drivers/target/target_core_configfs.c:2215:
+	lu_gp_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,
+			GFP_KERNEL);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2313: FILE: drivers/target/target_core_configfs.c:2217:
+		printk(KERN_ERR "Unable to allocate lu_gp_cg->default_groups\n");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2318: FILE: drivers/target/target_core_configfs.c:2222:
+	config_group_init_type_name(&lu_gp->lu_gp_group, "default_lu_gp",
+				&target_core_alua_lu_gp_cit);

CHECK:ALLOC_SIZEOF_STRUCT: Prefer kzalloc(sizeof(*tg_pt_gp_cg->default_groups)...) over kzalloc(sizeof(struct config_group)...)
#2330: FILE: drivers/target/target_core_configfs.c:2234:
+	tg_pt_gp_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2331: FILE: drivers/target/target_core_configfs.c:2235:
+	tg_pt_gp_cg->default_groups = kzalloc(sizeof(struct config_group) * 2,
+				GFP_KERNEL);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2333: FILE: drivers/target/target_core_configfs.c:2237:
+		printk(KERN_ERR "Unable to allocate tg_pt_gp_cg->"

WARNING:SPLIT_STRING: quoted string split across lines
#2334: FILE: drivers/target/target_core_configfs.c:2238:
+		printk(KERN_ERR "Unable to allocate tg_pt_gp_cg->"
+				"default_groups\n");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2339: FILE: drivers/target/target_core_configfs.c:2243:
+	config_group_init_type_name(&tg_pt_gp->tg_pt_gp_group,
+			"default_tg_pt_gp", &target_core_alua_tg_pt_gp_cit);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2348: FILE: drivers/target/target_core_configfs.c:2252:
+		printk(KERN_ERR "Error %d while registering subsystem %s\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2349: FILE: drivers/target/target_core_configfs.c:2253:
+		printk(KERN_ERR "Error %d while registering subsystem %s\n",
+			ret, subsys->su_group.cg_item.ci_namebuf);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#2352: FILE: drivers/target/target_core_configfs.c:2256:
+	printk(KERN_INFO "TARGET_CORE[0]: Initialized ConfigFS Fabric"

WARNING:SPLIT_STRING: quoted string split across lines
#2353: FILE: drivers/target/target_core_configfs.c:2257:
+	printk(KERN_INFO "TARGET_CORE[0]: Initialized ConfigFS Fabric"
+		" Infrastructure: "TARGET_CORE_CONFIGFS_VERSION" on %s/%s"

CHECK:CONCATENATED_STRING: Concatenated strings should use spaces between elements
#2353: FILE: drivers/target/target_core_configfs.c:2257:
+		" Infrastructure: "TARGET_CORE_CONFIGFS_VERSION" on %s/%s"

WARNING:SPLIT_STRING: quoted string split across lines
#2354: FILE: drivers/target/target_core_configfs.c:2258:
+		" Infrastructure: "TARGET_CORE_CONFIGFS_VERSION" on %s/%s"
+		" on "UTS_RELEASE"\n", utsname()->sysname, utsname()->machine);

CHECK:CONCATENATED_STRING: Concatenated strings should use spaces between elements
#2354: FILE: drivers/target/target_core_configfs.c:2258:
+		" on "UTS_RELEASE"\n", utsname()->sysname, utsname()->machine);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2360: FILE: drivers/target/target_core_configfs.c:2264:
+		printk(KERN_ERR "proc_mkdir(scsi_target, 0) failed\n");

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_info([subsystem]dev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
#2446: FILE: drivers/target/target_core_configfs.c:2350:
+	printk(KERN_INFO "TARGET_CORE[0]: Released ConfigFS Fabric"

WARNING:SPLIT_STRING: quoted string split across lines
#2447: FILE: drivers/target/target_core_configfs.c:2351:
+	printk(KERN_INFO "TARGET_CORE[0]: Released ConfigFS Fabric"
+			" Infrastructure\n");

WARNING:RETURN_VOID: void function return statements are not generally useful
#2456: FILE: drivers/target/target_core_configfs.c:2360:
+	return;
+}

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#2471: FILE: include/target/configfs_macros.h:1:
+/* -*- mode: c; c-basic-offset: 8; -*-

ERROR:FSF_MAILING_ADDRESS: Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.
#2488: FILE: include/target/configfs_macros.h:18:
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,$

Kernel maintainers reject new instances of the GPL boilerplate paragraph
directing people to write to the FSF for a copy of the GPL, since the
FSF has moved in the past and may do so again.
So do not write paragraphs about writing to the Free Software Foundation's
mailing address.

See: https://lore.kernel.org/lkml/20131006222342.GT19510@leaf/

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2492: FILE: include/target/configfs_macros.h:22:
+ * ^Isysfs is Copyright (C) 2001, 2002, 2003 Patrick Mochel$

WARNING:TYPO_SPELLING: 'Copright' may be misspelled - perhaps 'Copyright'?
#2501: FILE: include/target/configfs_macros.h:31:
+ * Copright (C) 2008-2009 Nicholas A. Bellinger <nab@linux-iscsi.org>
    ^^^^^^^^

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_item' - possible side-effects?
#2527: FILE: include/target/configfs_macros.h:53:
+#define CONFIGFS_EATTR_STRUCT(_name, _item)				\
+struct _name##_attribute {						\
+	struct configfs_attribute attr;					\
+	ssize_t (*show)(struct _item *, char *);			\
+	ssize_t (*store)(struct _item *, const char *, size_t);		\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument '_item' may be better as '(_item)' to avoid precedence issues
#2527: FILE: include/target/configfs_macros.h:53:
+#define CONFIGFS_EATTR_STRUCT(_name, _item)				\
+struct _name##_attribute {						\
+	struct configfs_attribute attr;					\
+	ssize_t (*show)(struct _item *, char *);			\
+	ssize_t (*store)(struct _item *, const char *, size_t);		\
+}

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct _item *' should also have an identifier name
#2530: FILE: include/target/configfs_macros.h:56:
+	ssize_t (*show)(struct _item *, char *);			\

This warning is emitted due to any of the following reasons:

  1. Arguments for the function declaration do not follow
     the identifier name.  Example::

       void foo
       (int bar, int baz)

     This should be corrected to::

       void foo(int bar, int baz)

  2. Some arguments for the function definition do not
     have an identifier name.  Example::

       void foo(int)

     All arguments should have identifier names.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'char *' should also have an identifier name
#2530: FILE: include/target/configfs_macros.h:56:
+	ssize_t (*show)(struct _item *, char *);			\

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct _item *' should also have an identifier name
#2531: FILE: include/target/configfs_macros.h:57:
+	ssize_t (*store)(struct _item *, const char *, size_t);		\

WARNING:FUNCTION_ARGUMENTS: function definition argument 'const char *' should also have an identifier name
#2531: FILE: include/target/configfs_macros.h:57:
+	ssize_t (*store)(struct _item *, const char *, size_t);		\

WARNING:FUNCTION_ARGUMENTS: function definition argument 'size_t' should also have an identifier name
#2531: FILE: include/target/configfs_macros.h:57:
+	ssize_t (*store)(struct _item *, const char *, size_t);		\

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#2552: FILE: include/target/configfs_macros.h:78:
+}
+/* Here is a readonly version, only requiring a show() operation */

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_item' - possible side-effects?
#2581: FILE: include/target/configfs_macros.h:101:
+#define CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member)		\
+static struct _item *to_##_name(struct config_item *ci)			\
+{									\
+	return((ci) ? container_of(to_config_group(ci), struct _item,	\
+		_item_member) : NULL);					\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument '_item' may be better as '(_item)' to avoid precedence issues
#2581: FILE: include/target/configfs_macros.h:101:
+#define CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member)		\
+static struct _item *to_##_name(struct config_item *ci)			\
+{									\
+	return((ci) ? container_of(to_config_group(ci), struct _item,	\
+		_item_member) : NULL);					\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_item' - possible side-effects?
#2588: FILE: include/target/configfs_macros.h:108:
+#define CONFIGFS_EATTR_OPS_SHOW(_name, _item)				\
+static ssize_t _name##_attr_show(struct config_item *item,		\
+				 struct configfs_attribute *attr,	\
+				 char *page)				\
+{									\
+	struct _item *_item = to_##_name(item);				\
+	struct _name##_attribute *_name##_attr =			\
+		container_of(attr, struct _name##_attribute, attr);	\
+	ssize_t ret = 0;						\
+									\
+	if (_name##_attr->show)						\
+		ret = _name##_attr->show(_item, page);			\
+	return ret;							\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument '_item' may be better as '(_item)' to avoid precedence issues
#2588: FILE: include/target/configfs_macros.h:108:
+#define CONFIGFS_EATTR_OPS_SHOW(_name, _item)				\
+static ssize_t _name##_attr_show(struct config_item *item,		\
+				 struct configfs_attribute *attr,	\
+				 char *page)				\
+{									\
+	struct _item *_item = to_##_name(item);				\
+	struct _name##_attribute *_name##_attr =			\
+		container_of(attr, struct _name##_attribute, attr);	\
+	ssize_t ret = 0;						\
+									\
+	if (_name##_attr->show)						\
+		ret = _name##_attr->show(_item, page);			\
+	return ret;							\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_item' - possible side-effects?
#2603: FILE: include/target/configfs_macros.h:123:
+#define CONFIGFS_EATTR_OPS_STORE(_name, _item)				\
+static ssize_t _name##_attr_store(struct config_item *item,		\
+				  struct configfs_attribute *attr,	\
+				  const char *page, size_t count)	\
+{									\
+	struct _item *_item = to_##_name(item);				\
+	struct _name##_attribute *_name##_attr =			\
+		container_of(attr, struct _name##_attribute, attr);	\
+	ssize_t ret = -EINVAL;						\
+									\
+	if (_name##_attr->store)					\
+		ret = _name##_attr->store(_item, page, count);		\
+	return ret;							\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument '_item' may be better as '(_item)' to avoid precedence issues
#2603: FILE: include/target/configfs_macros.h:123:
+#define CONFIGFS_EATTR_OPS_STORE(_name, _item)				\
+static ssize_t _name##_attr_store(struct config_item *item,		\
+				  struct configfs_attribute *attr,	\
+				  const char *page, size_t count)	\
+{									\
+	struct _item *_item = to_##_name(item);				\
+	struct _name##_attribute *_name##_attr =			\
+		container_of(attr, struct _name##_attribute, attr);	\
+	ssize_t ret = -EINVAL;						\
+									\
+	if (_name##_attr->store)					\
+		ret = _name##_attr->store(_item, page, count);		\
+	return ret;							\
+}

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#2618: FILE: include/target/configfs_macros.h:138:
+#define CONFIGFS_EATTR_OPS(_name, _item, _item_member)			\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);					\
+CONFIGFS_EATTR_OPS_STORE(_name, _item);	

Macros with multiple statements should be enclosed in a
do - while block.  Same should also be the case for macros
starting with `if` to avoid logic defects::

  #define macrofun(a, b, c)                 \
    do {                                    \
            if (a == 5)                     \
                    do_this(b, c);          \
    } while (0)

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#macros-enums-and-rtl

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_name' - possible side-effects?
#2618: FILE: include/target/configfs_macros.h:138:
+#define CONFIGFS_EATTR_OPS(_name, _item, _item_member)			\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);					\
+CONFIGFS_EATTR_OPS_STORE(_name, _item);	

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_item' - possible side-effects?
#2618: FILE: include/target/configfs_macros.h:138:
+#define CONFIGFS_EATTR_OPS(_name, _item, _item_member)			\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);					\
+CONFIGFS_EATTR_OPS_STORE(_name, _item);	

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#2618: FILE: include/target/configfs_macros.h:138:
+#define CONFIGFS_EATTR_OPS(_name, _item, _item_member)			\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);					\
+CONFIGFS_EATTR_OPS_STORE(_name, _item);	

Macro definition should not end with a semicolon. The macro
invocation style should be consistent with function calls.
This can prevent any unexpected code paths::

  #define MAC do_something;

If this macro is used within a if else statement, like::

  if (some_condition)
          MAC;

  else
          do_something;

Then there would be a compilation error, because when the macro is
expanded there are two trailing semicolons, so the else branch gets
orphaned.

See: https://lore.kernel.org/lkml/1399671106.2912.21.camel@joe-AO725/

ERROR:TRAILING_WHITESPACE: trailing whitespace
#2621: FILE: include/target/configfs_macros.h:141:
+CONFIGFS_EATTR_OPS_STORE(_name, _item);^I$

Trailing whitespace should always be removed.
Some editors highlight the trailing whitespace and cause visual
distractions when editing files.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#2623: FILE: include/target/configfs_macros.h:143:
+#define CONFIGFS_EATTR_OPS_RO(_name, _item, _item_member)		\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_name' - possible side-effects?
#2623: FILE: include/target/configfs_macros.h:143:
+#define CONFIGFS_EATTR_OPS_RO(_name, _item, _item_member)		\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);

CHECK:MACRO_ARG_REUSE: Macro argument reuse '_item' - possible side-effects?
#2623: FILE: include/target/configfs_macros.h:143:
+#define CONFIGFS_EATTR_OPS_RO(_name, _item, _item_member)		\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#2623: FILE: include/target/configfs_macros.h:143:
+#define CONFIGFS_EATTR_OPS_RO(_name, _item, _item_member)		\
+CONFIGFS_EATTR_OPS_TO_FUNC(_name, _item, _item_member);			\
+CONFIGFS_EATTR_OPS_SHOW(_name, _item);

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#2635: FILE: include/target/target_core_configfs.h:1:
+/***************************************************************************

ERROR:FSF_MAILING_ADDRESS: Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.
#2657: FILE: include/target/target_core_configfs.h:23:
+ * along with this program; if not, write to the Free Software$

ERROR:FSF_MAILING_ADDRESS: Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.
#2658: FILE: include/target/target_core_configfs.h:24:
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA$

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#2675: FILE: include/target/target_core_configfs.h:40:
+extern struct target_core_fabric_ops *target_core_get_iscsi_ops(void);

Function prototypes don't need to be declared extern in .h
files.  It's assumed by the compiler and is unnecessary.

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#2677: FILE: include/target/target_core_configfs.h:42:
+extern struct target_fabric_configfs *target_fabric_configfs_init(

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#2677: FILE: include/target/target_core_configfs.h:42:
+extern struct target_fabric_configfs *target_fabric_configfs_init(

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct config_item_type *' should also have an identifier name
#2677: FILE: include/target/target_core_configfs.h:42:
+extern struct target_fabric_configfs *target_fabric_configfs_init(

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#2679: FILE: include/target/target_core_configfs.h:44:
+extern void target_fabric_configfs_free(struct target_fabric_configfs

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct target_fabric_configfs' should also have an identifier name
#2679: FILE: include/target/target_core_configfs.h:44:
+extern void target_fabric_configfs_free(struct target_fabric_configfs

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#2681: FILE: include/target/target_core_configfs.h:45:
+extern int target_fabric_configfs_register(struct

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct
 arget_fabric_configfs *' should also have an identifier name
#2681: FILE: include/target/target_core_configfs.h:45:
+extern int target_fabric_configfs_register(struct

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#2683: FILE: include/target/target_core_configfs.h:46:
+extern void target_fabric_configfs_deregister(struct

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct
 arget_fabric_configfs *' should also have an identifier name
#2683: FILE: include/target/target_core_configfs.h:46:
+extern void target_fabric_configfs_deregister(struct

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#2685: FILE: include/target/target_core_configfs.h:47:
+extern int target_core_init_configfs(void);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#2686: FILE: include/target/target_core_configfs.h:48:
+extern void target_core_exit_configfs(void);

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000144116.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 68 errors, 162 warnings, 320 checks, 2634 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000144116.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
