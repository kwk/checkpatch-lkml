CHECK:SPACING: No space is necessary after a cast
#74: FILE: fs/udf/balloc.c:46:
+	uintBPL_t *p = ((uintBPL_t *) addr) + (offset / BITS_PER_LONG);

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:CAMELCASE: Avoid CamelCase: <uintBPL_t>
#74: FILE: fs/udf/balloc.c:46:
+	uintBPL_t *p = ((uintBPL_t *) addr) + (offset / BITS_PER_LONG);

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

WARNING:INDENTED_LABEL: labels should not be indented
#106: FILE: fs/udf/balloc.c:73:
+      found_first:

WARNING:INDENTED_LABEL: labels should not be indented
#108: FILE: fs/udf/balloc.c:75:
+      found_middle:

WARNING:BRACES: braces {} are not necessary for single statement blocks
#129: FILE: fs/udf/balloc.c:94:
+	if (!bh) {
 		retval = -EIO;
 	}

The placement of braces is stylistically incorrect.
The preferred way is to put the opening brace last on the line,
and put the closing brace first::

  if (x is true) {
          we do y
  }

This applies for all non-functional blocks.
However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus::

  int function(int x)
  {
          body of function
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

CHECK:BRACES: Unbalanced braces around else statement
#158: FILE: fs/udf/balloc.c:115:
+	else {

ERROR:OPEN_BRACE: that open brace { should be on the previous line
#198: FILE: fs/udf/balloc.c:157:
 	if (bloc.logicalBlockNum < 0 ||
+	    (bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb,
+							    bloc.
+							    partitionReferenceNum))
+	{

The opening brace should be following the function definitions on the
next line.  For any non-functional block it should be on the same line
as the last construct.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

CHECK:CAMELCASE: Avoid CamelCase: <logicalBlockNum>
#204: FILE: fs/udf/balloc.c:158:
+	    (bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb,

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'bloc.partitionReferenceNum'
#206: FILE: fs/udf/balloc.c:160:
+							    bloc.
+							    partitionReferenceNum))

A single dereferencing identifier spanned on multiple lines like::

  struct_identifier->member[index].
  member = <foo>;

is generally hard to follow. It can easily lead to typos and so makes
the code vulnerable to bugs.

If fixing the multiple line dereferencing leads to an 80 column
violation, then either rewrite the code in a more simple way or if the
starting part of the dereferencing identifier is the same and used at
multiple places then store it in a temporary variable, and use that
temporary variable only at all the places. For example, if there are
two dereferencing identifiers::

  member1->member2->member3.foo1;
  member1->member2->member3.foo2;

then store the member1->member2->member3 part in a temporary variable.
It not only helps to avoid the 80 column violation but also reduces
the program size by removing the unnecessary dereferences.

But if none of the above methods work then ignore the 80 column
violation because it is much easier to read a dereferencing identifier
on a single line.

CHECK:CAMELCASE: Avoid CamelCase: <partitionReferenceNum>
#206: FILE: fs/udf/balloc.c:160:
+							    partitionReferenceNum))

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'bloc.partitionReferenceNum'
#211: FILE: fs/udf/balloc.c:165:
+								      bloc.
+								      partitionReferenceNum));

CHECK:CAMELCASE: Avoid CamelCase: <spaceBitmapDesc>
#218: FILE: fs/udf/balloc.c:171:
+	    (sizeof(struct spaceBitmapDesc) << 3);

WARNING:INDENTED_LABEL: labels should not be indented
#221: FILE: fs/udf/balloc.c:173:
+      do_more:

CHECK:CAMELCASE: Avoid CamelCase: <freeSpaceTable>
#261: FILE: fs/udf/balloc.c:200:
+				    freeSpaceTable[UDF_SB_PARTITION(sb)] =

WARNING:INDENTED_LABEL: labels should not be indented
#278: FILE: fs/udf/balloc.c:214:
+      error_return:

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#293: FILE: fs/udf/balloc.c:225:
+				      uint16_t partition, uint32_t first_block,

WARNING:INDENTED_LABEL: labels should not be indented
#303: FILE: fs/udf/balloc.c:241:
+      repeat:

WARNING:INDENTED_LABEL: labels should not be indented
#344: FILE: fs/udf/balloc.c:274:
+      out:

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#364: FILE: fs/udf/balloc.c:290:
+				uint32_t goal, int *err)

WARNING:INDENTED_LABEL: labels should not be indented
#377: FILE: fs/udf/balloc.c:302:
+      repeat:

WARNING:BRACES: braces {} are not necessary for single statement blocks
#397: FILE: fs/udf/balloc.c:322:
+		if (udf_test_bit(bit, bh->b_data)) {
 			goto got_block;
 		}

WARNING:INDENTED_LABEL: labels should not be indented
#487: FILE: fs/udf/balloc.c:388:
+      search_back:

ERROR:TRAILING_STATEMENTS: trailing statements should be on next line
#488: FILE: fs/udf/balloc.c:389:
+	for (i = 0;
[...]
+	     && udf_test_bit(bit - 1, bh->b_data); i++, bit--) ;

Trailing statements (for example after any conditional) should be
on the next line.
Statements, such as::

  if (x == y) break;

should be::

  if (x == y)
          break;

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#490: FILE: fs/udf/balloc.c:391:
+	     i < 7 && bit > (group_start << 3)
+	     && udf_test_bit(bit - 1, bh->b_data); i++, bit--) ;

WARNING:SPACING: space prohibited before semicolon
#490: FILE: fs/udf/balloc.c:391:
+	     && udf_test_bit(bit - 1, bh->b_data); i++, bit--) ;

WARNING:INDENTED_LABEL: labels should not be indented
#493: FILE: fs/udf/balloc.c:393:
+      got_block:

WARNING:INDENTED_LABEL: labels should not be indented
#535: FILE: fs/udf/balloc.c:426:
+      error_return:

ERROR:OPEN_BRACE: that open brace { should be on the previous line
#556: FILE: fs/udf/balloc.c:447:
 	if (bloc.logicalBlockNum < 0 ||
+	    (bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb,
+							    bloc.
+							    partitionReferenceNum))
+	{

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'bloc.partitionReferenceNum'
#564: FILE: fs/udf/balloc.c:450:
+							    bloc.
+							    partitionReferenceNum))

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'bloc.partitionReferenceNum'
#569: FILE: fs/udf/balloc.c:455:
+								      bloc.
+								      partitionReferenceNum));

CHECK:BRACES: Unbalanced braces around else statement
#675: FILE: fs/udf/balloc.c:533:
+		} else

CHECK:BRACES: Unbalanced braces around else statement
#718: FILE: fs/udf/balloc.c:562:
+		else {

CHECK:CAMELCASE: Avoid CamelCase: <previousAllocExtLocation>
#753: FILE: fs/udf/balloc.c:588:
+			aed->previousAllocExtLocation =

CHECK:CAMELCASE: Avoid CamelCase: <allocExtDesc>
#766: FILE: fs/udf/balloc.c:598:
+				    sizeof(struct allocExtDesc);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'oepos.bh->b_data'
#786: FILE: fs/udf/balloc.c:611:
+					    (struct allocExtDesc *)oepos.bh->
+					    b_data;

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'aed->lengthAllocDescs'
#794: FILE: fs/udf/balloc.c:615:
+							(aed->
+							 lengthAllocDescs) +

CHECK:CAMELCASE: Avoid CamelCase: <lengthAllocDescs>
#794: FILE: fs/udf/balloc.c:615:
+							 lengthAllocDescs) +

CHECK:SPACING: No space is necessary after a cast
#824: FILE: fs/udf/balloc.c:633:
+					sad = (short_ad *) sptr;

CHECK:CAMELCASE: Avoid CamelCase: <extLength>
#825: FILE: fs/udf/balloc.c:634:
+					sad->extLength =

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sb->s_blocksize'
#828: FILE: fs/udf/balloc.c:637:
+					    (EXT_NEXT_EXTENT_ALLOCDECS | sb->
+					     s_blocksize);

CHECK:CAMELCASE: Avoid CamelCase: <extPosition>
#829: FILE: fs/udf/balloc.c:638:
+					sad->extPosition =

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'epos.block.logicalBlockNum'
#831: FILE: fs/udf/balloc.c:640:
+					    cpu_to_le32(epos.block.
+							logicalBlockNum);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sb->s_blocksize'
#846: FILE: fs/udf/balloc.c:649:
+					    (EXT_NEXT_EXTENT_ALLOCDECS | sb->
+					     s_blocksize);

CHECK:CAMELCASE: Avoid CamelCase: <extLocation>
#847: FILE: fs/udf/balloc.c:650:
+					lad->extLocation =

CHECK:BRACES: Unbalanced braces around else statement
#859: FILE: fs/udf/balloc.c:658:
+			} else

WARNING:INDENTED_LABEL: labels should not be indented
#891: FILE: fs/udf/balloc.c:683:
+      error_return:

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#904: FILE: fs/udf/balloc.c:692:
+				     uint32_t first_block, uint32_t block_count)

CHECK:BRACES: braces {} should be used on all arms of this statement
#929: FILE: fs/udf/balloc.c:729:
+	if (first_block == eloc.logicalBlockNum) {
[...]
-		else
[...]

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#935: FILE: fs/udf/balloc.c:734:
+		if (inode
+		    && DQUOT_PREALLOC_BLOCK(inode,

CHECK:BRACES: Unbalanced braces around else statement
#954: FILE: fs/udf/balloc.c:745:
+		} else

CHECK:BRACES: Unbalanced braces around else statement
#957: FILE: fs/udf/balloc.c:748:
+	} else

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#983: FILE: fs/udf/balloc.c:768:
+			       uint32_t goal, int *err)

CHECK:BRACES: Unbalanced braces around else statement
#1015: FILE: fs/udf/balloc.c:810:
+		} else

CHECK:BRACES: braces {} should be used on all arms of this statement
#1083: FILE: fs/udf/balloc.c:878:
+	if (UDF_SB_PARTFLAGS(sb, partition) & UDF_PART_FLAG_UNALLOC_BITMAP) {
[...]
-	else if (UDF_SB_PARTFLAGS(sb, partition) & UDF_PART_FLAG_UNALLOC_TABLE)
[...]
+		   UDF_PART_FLAG_UNALLOC_TABLE) {
[...]
-	else if (UDF_SB_PARTFLAGS(sb, partition) & UDF_PART_FLAG_FREED_BITMAP)
[...]
+	} else if (UDF_SB_PARTFLAGS(sb, partition) & UDF_PART_FLAG_FREED_BITMAP) {
[...]

CHECK:BRACES: Unbalanced braces around else statement
#1123: FILE: fs/udf/balloc.c:899:
+	} else

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#1132: FILE: fs/udf/balloc.c:905:
+			       uint16_t partition, uint32_t first_block,

CHECK:BRACES: Unbalanced braces around else statement
#1179: FILE: fs/udf/balloc.c:931:
+	} else

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#1188: FILE: fs/udf/balloc.c:937:
+			 uint16_t partition, uint32_t goal, int *err)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1250: FILE: fs/udf/crc.c:82:
+uint16_t udf_crc(uint8_t * data, uint32_t size, uint16_t crc)

When using pointer data or a function that returns a pointer type,
the preferred use of * is adjacent to the data name or function name
and not adjacent to the type name.
Examples::

  char *linux_banner;
  unsigned long long memparse(char *ptr, char **retptr);
  char *match_strdup(substring_t *s);

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1250: FILE: fs/udf/crc.c:82:
+uint16_t udf_crc(uint8_t * data, uint32_t size, uint16_t crc)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1352: FILE: fs/udf/dir.c:100:
+do_udf_readdir(struct inode *dir, struct file *filp, filldir_t filldir,
                                                ^^^^

Some words may have been misspelled.  Consider reviewing them.

CHECK:CAMELCASE: Avoid CamelCase: <fileIdentDesc>
#1357: FILE: fs/udf/dir.c:104:
+	struct fileIdentDesc *fi = NULL;

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#1375: FILE: fs/udf/dir.c:128:
+	fibh.soffset = fibh.eoffset =

Multiple assignments on a single line makes the code unnecessarily
complicated. So on a single line assign value to a single variable
only, this makes the code more readable and helps avoid typos.

CHECK:BRACES: braces {} should be used on all arms of this statement
#1387: FILE: fs/udf/dir.c:136:
+		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
[...]
-		}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#1394: FILE: fs/udf/dir.c:141:
+		} else

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#1399: FILE: fs/udf/dir.c:144:
+		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {

Do not use assignments in if condition.
Example::

  if ((foo = bar(...)) < BAZ) {

should be written as::

  foo = bar(...);
  if (foo < BAZ) {

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#1424: FILE: fs/udf/dir.c:160:
+				if (tmp && !buffer_uptodate(tmp)
+				    && !buffer_locked(tmp))

CHECK:BRACES: Unbalanced braces around else statement
#1467: FILE: fs/udf/dir.c:195:
+		else {

CHECK:BRACES: Unbalanced braces around else statement
#1481: FILE: fs/udf/dir.c:205:
+			else {

CHECK:CAMELCASE: Avoid CamelCase: <fileIdent>
#1485: FILE: fs/udf/dir.c:207:
+				memcpy(nameptr, fi->fileIdent + liu,

CHECK:CAMELCASE: Avoid CamelCase: <fileCharacteristics>
#1495: FILE: fs/udf/dir.c:214:
+		if ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1560: FILE: fs/udf/directory.c:22:
+static uint8_t *udf_filead_read(struct inode *dir, uint8_t * tmpad,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1561: FILE: fs/udf/directory.c:23:
+				uint8_t ad_size, kernel_lb_addr fe_loc,

CHECK:SPACING: No space is necessary after a cast
#1572: FILE: fs/udf/directory.c:34:
+	ad = (uint8_t *) (*bh)->b_data + *offset;

CHECK:SPACING: No space is necessary after a cast
#1600: FILE: fs/udf/directory.c:54:
+		memcpy((uint8_t *) ad, (*bh)->b_data + loffset, remainder);

CHECK:SPACING: No space is necessary after a cast
#1609: FILE: fs/udf/directory.c:63:
+		memcpy((uint8_t *) ad + remainder, (*bh)->b_data,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1624: FILE: fs/udf/directory.c:71:
+struct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t * nf_pos,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1628: FILE: fs/udf/directory.c:75:
+					 kernel_lb_addr * eloc, uint32_t * elen,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1628: FILE: fs/udf/directory.c:75:
+					 kernel_lb_addr * eloc, uint32_t * elen,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1629: FILE: fs/udf/directory.c:76:
+					 sector_t * offset)

CHECK:CAMELCASE: Avoid CamelCase: <extendedFileEntry>
#1647: FILE: fs/udf/directory.c:87:
+					sizeof(struct extendedFileEntry) :

CHECK:CAMELCASE: Avoid CamelCase: <fileEntry>
#1648: FILE: fs/udf/directory.c:88:
+					sizeof(struct fileEntry)),

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around fibh->eoffset
#1650: FILE: fs/udf/directory.c:90:
+				       &(fibh->eoffset));

Parentheses are not required in the following cases:

  1. Function pointer uses::

      (foo->bar)();

    could be::

      foo->bar();

  2. Comparisons in if::

      if ((foo->bar) && (foo->baz))
      if ((foo == bar))

    could be::

      if (foo->bar && foo->baz)
      if (foo == bar)

  3. addressof/dereference single Lvalues::

      &(foo->bar)
      *(foo->bar)

    could be::

      &foo->bar
      *foo->bar

CHECK:SPACING: No space is necessary after a cast
#1658: FILE: fs/udf/directory.c:97:
+		memcpy((uint8_t *) cfi, (uint8_t *) fi,

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#1706: FILE: fs/udf/directory.c:138:
+				if (tmp && !buffer_uptodate(tmp)
+				    && !buffer_locked(tmp))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around fibh->eoffset
#1730: FILE: fs/udf/directory.c:155:
+			       &(fibh->eoffset));

CHECK:SPACING: No space is necessary after a cast
#1744: FILE: fs/udf/directory.c:163:
+		memcpy((uint8_t *) cfi, (uint8_t *) fi,

CHECK:SPACING: No space is necessary after a cast
#1773: FILE: fs/udf/directory.c:190:
+			memcpy((uint8_t *) cfi, (uint8_t *) fi, -fibh->soffset);

CHECK:SPACING: No space is necessary after a cast
#1774: FILE: fs/udf/directory.c:191:
+			memcpy((uint8_t *) cfi - fibh->soffset,

CHECK:CAMELCASE: Avoid CamelCase: <lengthFileIdent>
#1782: FILE: fs/udf/directory.c:197:
+			     cfi->lengthFileIdent +

CHECK:CAMELCASE: Avoid CamelCase: <lengthOfImpUse>
#1783: FILE: fs/udf/directory.c:198:
+			     le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;

CHECK:SPACING: No space is necessary after a cast
#1794: FILE: fs/udf/directory.c:204:
+			memcpy((uint8_t *) cfi, (uint8_t *) fi,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1808: FILE: fs/udf/directory.c:215:
+	uint8_t *ptr;

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!buffer'
#1813: FILE: fs/udf/directory.c:218:
+	if ((!buffer) || (!offset)) {

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!offset'
#1813: FILE: fs/udf/directory.c:218:
+	if ((!buffer) || (!offset)) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#1822: FILE: fs/udf/directory.c:226:
+	if ((*offset > 0) && (*offset < bufsize)) {
 		ptr += *offset;
 	}

CHECK:CAMELCASE: Avoid CamelCase: <descTag>
#1829: FILE: fs/udf/directory.c:230:
+	if (le16_to_cpu(fi->descTag.tagIdent) != TAG_IDENT_FID) {

CHECK:CAMELCASE: Avoid CamelCase: <tagIdent>
#1829: FILE: fs/udf/directory.c:230:
+	if (le16_to_cpu(fi->descTag.tagIdent) != TAG_IDENT_FID) {

CHECK:BRACES: braces {} should be used on all arms of this statement
#1841: FILE: fs/udf/directory.c:238:
+	if ((*offset + sizeof(struct fileIdentDesc)) > bufsize) {
[...]
-	}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#1845: FILE: fs/udf/directory.c:240:
+	} else

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1864: FILE: fs/udf/directory.c:258:
+	uint8_t *ptr;

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!buffer'
#1868: FILE: fs/udf/directory.c:260:
+	if ((!buffer) || (!offset)) {

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!offset'
#1868: FILE: fs/udf/directory.c:260:
+	if ((!buffer) || (!offset)) {

CHECK:SPACING: No space is necessary after a cast
#1886: FILE: fs/udf/directory.c:274:
+	    (uint8_t *) (fe->extendedAttr) +

CHECK:CAMELCASE: Avoid CamelCase: <extendedAttr>
#1886: FILE: fs/udf/directory.c:274:
+	    (uint8_t *) (fe->extendedAttr) +

CHECK:CAMELCASE: Avoid CamelCase: <lengthExtendedAttr>
#1887: FILE: fs/udf/directory.c:275:
+	    le32_to_cpu(fe->lengthExtendedAttr);

WARNING:BRACES: braces {} are not necessary for single statement blocks
#1891: FILE: fs/udf/directory.c:277:
+	if ((*offset > 0) && (*offset < le32_to_cpu(fe->lengthAllocDescs))) {
 		ptr += *offset;
 	}

CHECK:SPACING: No space is necessary after a cast
#1896: FILE: fs/udf/directory.c:281:
+	ext = (extent_ad *) ptr;

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1905: FILE: fs/udf/directory.c:288:
+short_ad *udf_get_fileshortad(uint8_t * ptr, int maxoffset, int *offset,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1905: FILE: fs/udf/directory.c:288:
+short_ad *udf_get_fileshortad(uint8_t * ptr, int maxoffset, int *offset,

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!ptr'
#1912: FILE: fs/udf/directory.c:293:
+	if ((!ptr) || (!offset)) {

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!offset'
#1912: FILE: fs/udf/directory.c:293:
+	if ((!ptr) || (!offset)) {

CHECK:SPACING: No space is necessary after a cast
#1921: FILE: fs/udf/directory.c:300:
+	else if ((sa = (short_ad *) ptr)->extLength == 0)

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#1921: FILE: fs/udf/directory.c:300:
+	else if ((sa = (short_ad *) ptr)->extLength == 0)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1931: FILE: fs/udf/directory.c:308:
+long_ad *udf_get_filelongad(uint8_t * ptr, int maxoffset, int *offset, int inc)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1931: FILE: fs/udf/directory.c:308:
+long_ad *udf_get_filelongad(uint8_t * ptr, int maxoffset, int *offset, int inc)

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!ptr'
#1937: FILE: fs/udf/directory.c:312:
+	if ((!ptr) || (!offset)) {

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!offset'
#1937: FILE: fs/udf/directory.c:312:
+	if ((!ptr) || (!offset)) {

CHECK:SPACING: No space is necessary after a cast
#1946: FILE: fs/udf/directory.c:319:
+	else if ((la = (long_ad *) ptr)->extLength == 0)

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#1946: FILE: fs/udf/directory.c:319:
+	else if ((la = (long_ad *) ptr)->extLength == 0)

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1962: FILE: fs/udf/ecma_167.h:41:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <charSetType>
#1963: FILE: fs/udf/ecma_167.h:42:
+	uint8_t charSetType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1963: FILE: fs/udf/ecma_167.h:42:
+	uint8_t charSetType;

CHECK:CAMELCASE: Avoid CamelCase: <charSetInfo>
#1964: FILE: fs/udf/ecma_167.h:43:
+	uint8_t charSetInfo[63];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1964: FILE: fs/udf/ecma_167.h:43:
+	uint8_t charSetInfo[63];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1973: FILE: fs/udf/ecma_167.h:57:
+typedef uint8_t dstring;

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1988: FILE: fs/udf/ecma_167.h:60:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <typeAndTimezone>
#1989: FILE: fs/udf/ecma_167.h:61:
+	__le16 typeAndTimezone;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1991: FILE: fs/udf/ecma_167.h:63:
+	uint8_t month;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1992: FILE: fs/udf/ecma_167.h:64:
+	uint8_t day;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1993: FILE: fs/udf/ecma_167.h:65:
+	uint8_t hour;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1994: FILE: fs/udf/ecma_167.h:66:
+	uint8_t minute;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1995: FILE: fs/udf/ecma_167.h:67:
+	uint8_t second;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1996: FILE: fs/udf/ecma_167.h:68:
+	uint8_t centiseconds;

CHECK:CAMELCASE: Avoid CamelCase: <hundredsOfMicroseconds>
#1997: FILE: fs/udf/ecma_167.h:69:
+	uint8_t hundredsOfMicroseconds;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1997: FILE: fs/udf/ecma_167.h:69:
+	uint8_t hundredsOfMicroseconds;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1998: FILE: fs/udf/ecma_167.h:70:
+	uint8_t microseconds;

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2013: FILE: fs/udf/ecma_167.h:73:
+typedef struct {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#2014: FILE: fs/udf/ecma_167.h:74:
+	uint16_t typeAndTimezone;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 's16' over 'int16_t'
#2015: FILE: fs/udf/ecma_167.h:75:
+	int16_t year;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2016: FILE: fs/udf/ecma_167.h:76:
+	uint8_t month;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2017: FILE: fs/udf/ecma_167.h:77:
+	uint8_t day;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2018: FILE: fs/udf/ecma_167.h:78:
+	uint8_t hour;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2019: FILE: fs/udf/ecma_167.h:79:
+	uint8_t minute;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2020: FILE: fs/udf/ecma_167.h:80:
+	uint8_t second;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2021: FILE: fs/udf/ecma_167.h:81:
+	uint8_t centiseconds;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2022: FILE: fs/udf/ecma_167.h:82:
+	uint8_t hundredsOfMicroseconds;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2023: FILE: fs/udf/ecma_167.h:83:
+	uint8_t microseconds;

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2036: FILE: fs/udf/ecma_167.h:94:
+typedef struct {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2037: FILE: fs/udf/ecma_167.h:95:
+	uint8_t flags;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2038: FILE: fs/udf/ecma_167.h:96:
+	uint8_t ident[23];

CHECK:CAMELCASE: Avoid CamelCase: <identSuffix>
#2039: FILE: fs/udf/ecma_167.h:97:
+	uint8_t identSuffix[8];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2039: FILE: fs/udf/ecma_167.h:97:
+	uint8_t identSuffix[8];

CHECK:CAMELCASE: Avoid CamelCase: <volStructDesc>
#2053: FILE: fs/udf/ecma_167.h:106:
+struct volStructDesc {

CHECK:CAMELCASE: Avoid CamelCase: <structType>
#2054: FILE: fs/udf/ecma_167.h:107:
+	uint8_t structType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2054: FILE: fs/udf/ecma_167.h:107:
+	uint8_t structType;

CHECK:CAMELCASE: Avoid CamelCase: <stdIdent>
#2055: FILE: fs/udf/ecma_167.h:108:
+	uint8_t stdIdent[VSD_STD_ID_LEN];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2055: FILE: fs/udf/ecma_167.h:108:
+	uint8_t stdIdent[VSD_STD_ID_LEN];

CHECK:CAMELCASE: Avoid CamelCase: <structVersion>
#2056: FILE: fs/udf/ecma_167.h:109:
+	uint8_t structVersion;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2056: FILE: fs/udf/ecma_167.h:109:
+	uint8_t structVersion;

CHECK:CAMELCASE: Avoid CamelCase: <structData>
#2057: FILE: fs/udf/ecma_167.h:110:
+	uint8_t structData[2041];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2057: FILE: fs/udf/ecma_167.h:110:
+	uint8_t structData[2041];

CHECK:CAMELCASE: Avoid CamelCase: <beginningExtendedAreaDesc>
#2071: FILE: fs/udf/ecma_167.h:125:
+struct beginningExtendedAreaDesc {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2072: FILE: fs/udf/ecma_167.h:126:
+	uint8_t structType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2073: FILE: fs/udf/ecma_167.h:127:
+	uint8_t stdIdent[VSD_STD_ID_LEN];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2074: FILE: fs/udf/ecma_167.h:128:
+	uint8_t structVersion;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2075: FILE: fs/udf/ecma_167.h:129:
+	uint8_t structData[2041];

CHECK:CAMELCASE: Avoid CamelCase: <terminatingExtendedAreaDesc>
#2085: FILE: fs/udf/ecma_167.h:133:
+struct terminatingExtendedAreaDesc {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2086: FILE: fs/udf/ecma_167.h:134:
+	uint8_t structType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2087: FILE: fs/udf/ecma_167.h:135:
+	uint8_t stdIdent[VSD_STD_ID_LEN];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2088: FILE: fs/udf/ecma_167.h:136:
+	uint8_t structVersion;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2089: FILE: fs/udf/ecma_167.h:137:
+	uint8_t structData[2041];

CHECK:CAMELCASE: Avoid CamelCase: <bootDesc>
#2109: FILE: fs/udf/ecma_167.h:141:
+struct bootDesc {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2110: FILE: fs/udf/ecma_167.h:142:
+	uint8_t structType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2111: FILE: fs/udf/ecma_167.h:143:
+	uint8_t stdIdent[VSD_STD_ID_LEN];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2112: FILE: fs/udf/ecma_167.h:144:
+	uint8_t structVersion;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2113: FILE: fs/udf/ecma_167.h:145:
+	uint8_t reserved1;

WARNING:TYPO_SPELLING: 'archType' may be misspelled - perhaps 'archetype'?
#2114: FILE: fs/udf/ecma_167.h:146:
+	regid archType;
 	      ^^^^^^^^

CHECK:CAMELCASE: Avoid CamelCase: <archType>
#2114: FILE: fs/udf/ecma_167.h:146:
+	regid archType;

CHECK:CAMELCASE: Avoid CamelCase: <bootIdent>
#2115: FILE: fs/udf/ecma_167.h:147:
+	regid bootIdent;

CHECK:CAMELCASE: Avoid CamelCase: <bootExtLocation>
#2116: FILE: fs/udf/ecma_167.h:148:
+	__le32 bootExtLocation;

CHECK:CAMELCASE: Avoid CamelCase: <bootExtLength>
#2117: FILE: fs/udf/ecma_167.h:149:
+	__le32 bootExtLength;

CHECK:CAMELCASE: Avoid CamelCase: <loadAddress>
#2118: FILE: fs/udf/ecma_167.h:150:
+	__le64 loadAddress;

CHECK:CAMELCASE: Avoid CamelCase: <startAddress>
#2119: FILE: fs/udf/ecma_167.h:151:
+	__le64 startAddress;

CHECK:CAMELCASE: Avoid CamelCase: <descCreationDateAndTime>
#2120: FILE: fs/udf/ecma_167.h:152:
+	timestamp descCreationDateAndTime;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2122: FILE: fs/udf/ecma_167.h:154:
+	uint8_t reserved2[32];

CHECK:CAMELCASE: Avoid CamelCase: <bootUse>
#2123: FILE: fs/udf/ecma_167.h:155:
+	uint8_t bootUse[1906];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2123: FILE: fs/udf/ecma_167.h:155:
+	uint8_t bootUse[1906];

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2134: FILE: fs/udf/ecma_167.h:162:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2143: FILE: fs/udf/ecma_167.h:167:
+typedef struct {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#2144: FILE: fs/udf/ecma_167.h:168:
+	uint32_t extLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#2145: FILE: fs/udf/ecma_167.h:169:
+	uint32_t extLocation;

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2159: FILE: fs/udf/ecma_167.h:173:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <descVersion>
#2161: FILE: fs/udf/ecma_167.h:175:
+	__le16 descVersion;

CHECK:CAMELCASE: Avoid CamelCase: <tagChecksum>
#2162: FILE: fs/udf/ecma_167.h:176:
+	uint8_t tagChecksum;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2162: FILE: fs/udf/ecma_167.h:176:
+	uint8_t tagChecksum;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2163: FILE: fs/udf/ecma_167.h:177:
+	uint8_t reserved;

CHECK:CAMELCASE: Avoid CamelCase: <tagSerialNum>
#2164: FILE: fs/udf/ecma_167.h:178:
+	__le16 tagSerialNum;

CHECK:CAMELCASE: Avoid CamelCase: <descCRC>
#2165: FILE: fs/udf/ecma_167.h:179:
+	__le16 descCRC;

CHECK:CAMELCASE: Avoid CamelCase: <descCRCLength>
#2166: FILE: fs/udf/ecma_167.h:180:
+	__le16 descCRCLength;

CHECK:CAMELCASE: Avoid CamelCase: <tagLocation>
#2167: FILE: fs/udf/ecma_167.h:181:
+	__le32 tagLocation;

CHECK:CAMELCASE: Avoid CamelCase: <NSRDesc>
#2184: FILE: fs/udf/ecma_167.h:196:
+struct NSRDesc {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2185: FILE: fs/udf/ecma_167.h:197:
+	uint8_t structType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2186: FILE: fs/udf/ecma_167.h:198:
+	uint8_t stdIdent[VSD_STD_ID_LEN];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2187: FILE: fs/udf/ecma_167.h:199:
+	uint8_t structVersion;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2188: FILE: fs/udf/ecma_167.h:200:
+	uint8_t reserved;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2189: FILE: fs/udf/ecma_167.h:201:
+	uint8_t structData[2040];

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __packed over __attribute__((packed))
#2190: FILE: fs/udf/ecma_167.h:202:
+} __attribute__ ((packed));

CHECK:CAMELCASE: Avoid CamelCase: <primaryVolDesc>
#2217: FILE: fs/udf/ecma_167.h:205:
+struct primaryVolDesc {

CHECK:CAMELCASE: Avoid CamelCase: <volDescSeqNum>
#2219: FILE: fs/udf/ecma_167.h:207:
+	__le32 volDescSeqNum;

CHECK:CAMELCASE: Avoid CamelCase: <primaryVolDescNum>
#2220: FILE: fs/udf/ecma_167.h:208:
+	__le32 primaryVolDescNum;

CHECK:CAMELCASE: Avoid CamelCase: <volIdent>
#2221: FILE: fs/udf/ecma_167.h:209:
+	dstring volIdent[32];

CHECK:CAMELCASE: Avoid CamelCase: <volSeqNum>
#2222: FILE: fs/udf/ecma_167.h:210:
+	__le16 volSeqNum;

CHECK:CAMELCASE: Avoid CamelCase: <maxVolSeqNum>
#2223: FILE: fs/udf/ecma_167.h:211:
+	__le16 maxVolSeqNum;

CHECK:CAMELCASE: Avoid CamelCase: <interchangeLvl>
#2224: FILE: fs/udf/ecma_167.h:212:
+	__le16 interchangeLvl;

CHECK:CAMELCASE: Avoid CamelCase: <maxInterchangeLvl>
#2225: FILE: fs/udf/ecma_167.h:213:
+	__le16 maxInterchangeLvl;

CHECK:CAMELCASE: Avoid CamelCase: <charSetList>
#2226: FILE: fs/udf/ecma_167.h:214:
+	__le32 charSetList;

CHECK:CAMELCASE: Avoid CamelCase: <maxCharSetList>
#2227: FILE: fs/udf/ecma_167.h:215:
+	__le32 maxCharSetList;

CHECK:CAMELCASE: Avoid CamelCase: <volSetIdent>
#2228: FILE: fs/udf/ecma_167.h:216:
+	dstring volSetIdent[128];

CHECK:CAMELCASE: Avoid CamelCase: <descCharSet>
#2229: FILE: fs/udf/ecma_167.h:217:
+	charspec descCharSet;

CHECK:CAMELCASE: Avoid CamelCase: <explanatoryCharSet>
#2230: FILE: fs/udf/ecma_167.h:218:
+	charspec explanatoryCharSet;

CHECK:CAMELCASE: Avoid CamelCase: <volAbstract>
#2231: FILE: fs/udf/ecma_167.h:219:
+	extent_ad volAbstract;

CHECK:CAMELCASE: Avoid CamelCase: <volCopyright>
#2232: FILE: fs/udf/ecma_167.h:220:
+	extent_ad volCopyright;

CHECK:CAMELCASE: Avoid CamelCase: <appIdent>
#2233: FILE: fs/udf/ecma_167.h:221:
+	regid appIdent;

CHECK:CAMELCASE: Avoid CamelCase: <recordingDateAndTime>
#2234: FILE: fs/udf/ecma_167.h:222:
+	timestamp recordingDateAndTime;

CHECK:CAMELCASE: Avoid CamelCase: <impIdent>
#2235: FILE: fs/udf/ecma_167.h:223:
+	regid impIdent;

CHECK:CAMELCASE: Avoid CamelCase: <impUse>
#2236: FILE: fs/udf/ecma_167.h:224:
+	uint8_t impUse[64];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2236: FILE: fs/udf/ecma_167.h:224:
+	uint8_t impUse[64];

CHECK:CAMELCASE: Avoid CamelCase: <predecessorVolDescSeqLocation>
#2237: FILE: fs/udf/ecma_167.h:225:
+	__le32 predecessorVolDescSeqLocation;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2239: FILE: fs/udf/ecma_167.h:227:
+	uint8_t reserved[22];

CHECK:CAMELCASE: Avoid CamelCase: <anchorVolDescPtr>
#2252: FILE: fs/udf/ecma_167.h:234:
+struct anchorVolDescPtr {

CHECK:CAMELCASE: Avoid CamelCase: <mainVolDescSeqExt>
#2254: FILE: fs/udf/ecma_167.h:236:
+	extent_ad mainVolDescSeqExt;

CHECK:CAMELCASE: Avoid CamelCase: <reserveVolDescSeqExt>
#2255: FILE: fs/udf/ecma_167.h:237:
+	extent_ad reserveVolDescSeqExt;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2256: FILE: fs/udf/ecma_167.h:238:
+	uint8_t reserved[480];

CHECK:CAMELCASE: Avoid CamelCase: <volDescPtr>
#2266: FILE: fs/udf/ecma_167.h:242:
+struct volDescPtr {

CHECK:CAMELCASE: Avoid CamelCase: <nextVolDescSeqExt>
#2269: FILE: fs/udf/ecma_167.h:245:
+	extent_ad nextVolDescSeqExt;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2270: FILE: fs/udf/ecma_167.h:246:
+	uint8_t reserved[484];

CHECK:CAMELCASE: Avoid CamelCase: <impUseVolDesc>
#2280: FILE: fs/udf/ecma_167.h:250:
+struct impUseVolDesc {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2284: FILE: fs/udf/ecma_167.h:254:
+	uint8_t impUse[460];

CHECK:CAMELCASE: Avoid CamelCase: <partitionDesc>
#2302: FILE: fs/udf/ecma_167.h:258:
+struct partitionDesc {

CHECK:CAMELCASE: Avoid CamelCase: <partitionFlags>
#2305: FILE: fs/udf/ecma_167.h:261:
+	__le16 partitionFlags;

CHECK:CAMELCASE: Avoid CamelCase: <partitionNumber>
#2306: FILE: fs/udf/ecma_167.h:262:
+	__le16 partitionNumber;

CHECK:CAMELCASE: Avoid CamelCase: <partitionContents>
#2307: FILE: fs/udf/ecma_167.h:263:
+	regid partitionContents;

CHECK:CAMELCASE: Avoid CamelCase: <partitionContentsUse>
#2308: FILE: fs/udf/ecma_167.h:264:
+	uint8_t partitionContentsUse[128];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2308: FILE: fs/udf/ecma_167.h:264:
+	uint8_t partitionContentsUse[128];

CHECK:CAMELCASE: Avoid CamelCase: <accessType>
#2309: FILE: fs/udf/ecma_167.h:265:
+	__le32 accessType;

CHECK:CAMELCASE: Avoid CamelCase: <partitionStartingLocation>
#2310: FILE: fs/udf/ecma_167.h:266:
+	__le32 partitionStartingLocation;

CHECK:CAMELCASE: Avoid CamelCase: <partitionLength>
#2311: FILE: fs/udf/ecma_167.h:267:
+	__le32 partitionLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2313: FILE: fs/udf/ecma_167.h:269:
+	uint8_t impUse[128];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2314: FILE: fs/udf/ecma_167.h:270:
+	uint8_t reserved[156];

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolDesc>
#2337: FILE: fs/udf/ecma_167.h:293:
+struct logicalVolDesc {

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolIdent>
#2341: FILE: fs/udf/ecma_167.h:297:
+	dstring logicalVolIdent[128];

CHECK:CAMELCASE: Avoid CamelCase: <logicalBlockSize>
#2342: FILE: fs/udf/ecma_167.h:298:
+	__le32 logicalBlockSize;

CHECK:CAMELCASE: Avoid CamelCase: <domainIdent>
#2343: FILE: fs/udf/ecma_167.h:299:
+	regid domainIdent;

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolContentsUse>
#2344: FILE: fs/udf/ecma_167.h:300:
+	uint8_t logicalVolContentsUse[16];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2344: FILE: fs/udf/ecma_167.h:300:
+	uint8_t logicalVolContentsUse[16];

CHECK:CAMELCASE: Avoid CamelCase: <mapTableLength>
#2345: FILE: fs/udf/ecma_167.h:301:
+	__le32 mapTableLength;

CHECK:CAMELCASE: Avoid CamelCase: <numPartitionMaps>
#2346: FILE: fs/udf/ecma_167.h:302:
+	__le32 numPartitionMaps;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2348: FILE: fs/udf/ecma_167.h:304:
+	uint8_t impUse[128];

CHECK:CAMELCASE: Avoid CamelCase: <integritySeqExt>
#2349: FILE: fs/udf/ecma_167.h:305:
+	extent_ad integritySeqExt;

CHECK:CAMELCASE: Avoid CamelCase: <partitionMaps>
#2350: FILE: fs/udf/ecma_167.h:306:
+	uint8_t partitionMaps[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2350: FILE: fs/udf/ecma_167.h:306:
+	uint8_t partitionMaps[0];

CHECK:CAMELCASE: Avoid CamelCase: <genericPartitionMap>
#2359: FILE: fs/udf/ecma_167.h:310:
+struct genericPartitionMap {

CHECK:CAMELCASE: Avoid CamelCase: <partitionMapType>
#2360: FILE: fs/udf/ecma_167.h:311:
+	uint8_t partitionMapType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2360: FILE: fs/udf/ecma_167.h:311:
+	uint8_t partitionMapType;

CHECK:CAMELCASE: Avoid CamelCase: <partitionMapLength>
#2361: FILE: fs/udf/ecma_167.h:312:
+	uint8_t partitionMapLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2361: FILE: fs/udf/ecma_167.h:312:
+	uint8_t partitionMapLength;

CHECK:CAMELCASE: Avoid CamelCase: <partitionMapping>
#2362: FILE: fs/udf/ecma_167.h:313:
+	uint8_t partitionMapping[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2362: FILE: fs/udf/ecma_167.h:313:
+	uint8_t partitionMapping[0];

CHECK:CAMELCASE: Avoid CamelCase: <genericPartitionMap1>
#2376: FILE: fs/udf/ecma_167.h:322:
+struct genericPartitionMap1 {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2377: FILE: fs/udf/ecma_167.h:323:
+	uint8_t partitionMapType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2378: FILE: fs/udf/ecma_167.h:324:
+	uint8_t partitionMapLength;

CHECK:CAMELCASE: Avoid CamelCase: <partitionNum>
#2380: FILE: fs/udf/ecma_167.h:326:
+	__le16 partitionNum;

CHECK:CAMELCASE: Avoid CamelCase: <genericPartitionMap2>
#2389: FILE: fs/udf/ecma_167.h:330:
+struct genericPartitionMap2 {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2390: FILE: fs/udf/ecma_167.h:331:
+	uint8_t partitionMapType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2391: FILE: fs/udf/ecma_167.h:332:
+	uint8_t partitionMapLength;

CHECK:CAMELCASE: Avoid CamelCase: <partitionIdent>
#2392: FILE: fs/udf/ecma_167.h:333:
+	uint8_t partitionIdent[62];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2392: FILE: fs/udf/ecma_167.h:333:
+	uint8_t partitionIdent[62];

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceDesc>
#2402: FILE: fs/udf/ecma_167.h:337:
+struct unallocSpaceDesc {

CHECK:CAMELCASE: Avoid CamelCase: <numAllocDescs>
#2405: FILE: fs/udf/ecma_167.h:340:
+	__le32 numAllocDescs;

CHECK:CAMELCASE: Avoid CamelCase: <allocDescs>
#2406: FILE: fs/udf/ecma_167.h:341:
+	extent_ad allocDescs[0];

CHECK:CAMELCASE: Avoid CamelCase: <terminatingDesc>
#2414: FILE: fs/udf/ecma_167.h:345:
+struct terminatingDesc {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2416: FILE: fs/udf/ecma_167.h:347:
+	uint8_t reserved[496];

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolIntegrityDesc>
#2432: FILE: fs/udf/ecma_167.h:351:
+struct logicalVolIntegrityDesc {

CHECK:CAMELCASE: Avoid CamelCase: <integrityType>
#2435: FILE: fs/udf/ecma_167.h:354:
+	__le32 integrityType;

CHECK:CAMELCASE: Avoid CamelCase: <nextIntegrityExt>
#2436: FILE: fs/udf/ecma_167.h:355:
+	extent_ad nextIntegrityExt;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2437: FILE: fs/udf/ecma_167.h:356:
+	uint8_t logicalVolContentsUse[32];

CHECK:CAMELCASE: Avoid CamelCase: <numOfPartitions>
#2438: FILE: fs/udf/ecma_167.h:357:
+	__le32 numOfPartitions;

CHECK:CAMELCASE: Avoid CamelCase: <sizeTable>
#2441: FILE: fs/udf/ecma_167.h:360:
+	__le32 sizeTable[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2442: FILE: fs/udf/ecma_167.h:361:
+	uint8_t impUse[0];

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2454: FILE: fs/udf/ecma_167.h:369:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2464: FILE: fs/udf/ecma_167.h:375:
+typedef struct {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#2465: FILE: fs/udf/ecma_167.h:376:
+	uint32_t logicalBlockNum;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#2466: FILE: fs/udf/ecma_167.h:377:
+	uint16_t partitionReferenceNum;

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2474: FILE: fs/udf/ecma_167.h:381:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2485: FILE: fs/udf/ecma_167.h:387:
+typedef struct {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2488: FILE: fs/udf/ecma_167.h:390:
+	uint8_t impUse[6];

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2496: FILE: fs/udf/ecma_167.h:393:
+typedef struct {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#2497: FILE: fs/udf/ecma_167.h:394:
+	uint32_t extLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2499: FILE: fs/udf/ecma_167.h:396:
+	uint8_t impUse[6];

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2509: FILE: fs/udf/ecma_167.h:400:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <recordedLength>
#2511: FILE: fs/udf/ecma_167.h:402:
+	__le32 recordedLength;

CHECK:CAMELCASE: Avoid CamelCase: <informationLength>
#2512: FILE: fs/udf/ecma_167.h:403:
+	__le32 informationLength;

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2522: FILE: fs/udf/ecma_167.h:407:
+typedef struct {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#2523: FILE: fs/udf/ecma_167.h:408:
+	uint32_t extLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#2524: FILE: fs/udf/ecma_167.h:409:
+	uint32_t recordedLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#2525: FILE: fs/udf/ecma_167.h:410:
+	uint32_t informationLength;

CHECK:CAMELCASE: Avoid CamelCase: <fileSetDesc>
#2555: FILE: fs/udf/ecma_167.h:430:
+struct fileSetDesc {

CHECK:CAMELCASE: Avoid CamelCase: <fileSetNum>
#2562: FILE: fs/udf/ecma_167.h:437:
+	__le32 fileSetNum;

CHECK:CAMELCASE: Avoid CamelCase: <fileSetDescNum>
#2563: FILE: fs/udf/ecma_167.h:438:
+	__le32 fileSetDescNum;

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolIdentCharSet>
#2564: FILE: fs/udf/ecma_167.h:439:
+	charspec logicalVolIdentCharSet;

CHECK:CAMELCASE: Avoid CamelCase: <fileSetCharSet>
#2566: FILE: fs/udf/ecma_167.h:441:
+	charspec fileSetCharSet;

CHECK:CAMELCASE: Avoid CamelCase: <fileSetIdent>
#2567: FILE: fs/udf/ecma_167.h:442:
+	dstring fileSetIdent[32];

CHECK:CAMELCASE: Avoid CamelCase: <copyrightFileIdent>
#2568: FILE: fs/udf/ecma_167.h:443:
+	dstring copyrightFileIdent[32];

CHECK:CAMELCASE: Avoid CamelCase: <abstractFileIdent>
#2569: FILE: fs/udf/ecma_167.h:444:
+	dstring abstractFileIdent[32];

CHECK:CAMELCASE: Avoid CamelCase: <rootDirectoryICB>
#2570: FILE: fs/udf/ecma_167.h:445:
+	long_ad rootDirectoryICB;

CHECK:CAMELCASE: Avoid CamelCase: <nextExt>
#2572: FILE: fs/udf/ecma_167.h:447:
+	long_ad nextExt;

CHECK:CAMELCASE: Avoid CamelCase: <streamDirectoryICB>
#2573: FILE: fs/udf/ecma_167.h:448:
+	long_ad streamDirectoryICB;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2574: FILE: fs/udf/ecma_167.h:449:
+	uint8_t reserved[32];

CHECK:CAMELCASE: Avoid CamelCase: <partitionHeaderDesc>
#2586: FILE: fs/udf/ecma_167.h:453:
+struct partitionHeaderDesc {

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceTable>
#2587: FILE: fs/udf/ecma_167.h:454:
+	short_ad unallocSpaceTable;

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceBitmap>
#2588: FILE: fs/udf/ecma_167.h:455:
+	short_ad unallocSpaceBitmap;

CHECK:CAMELCASE: Avoid CamelCase: <partitionIntegrityTable>
#2589: FILE: fs/udf/ecma_167.h:456:
+	short_ad partitionIntegrityTable;

CHECK:CAMELCASE: Avoid CamelCase: <freedSpaceTable>
#2590: FILE: fs/udf/ecma_167.h:457:
+	short_ad freedSpaceTable;

CHECK:CAMELCASE: Avoid CamelCase: <freedSpaceBitmap>
#2591: FILE: fs/udf/ecma_167.h:458:
+	short_ad freedSpaceBitmap;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2592: FILE: fs/udf/ecma_167.h:459:
+	uint8_t reserved[88];

CHECK:CAMELCASE: Avoid CamelCase: <fileVersionNum>
#2609: FILE: fs/udf/ecma_167.h:465:
+	__le16 fileVersionNum;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2610: FILE: fs/udf/ecma_167.h:466:
+	uint8_t fileCharacteristics;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2611: FILE: fs/udf/ecma_167.h:467:
+	uint8_t lengthFileIdent;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2614: FILE: fs/udf/ecma_167.h:470:
+	uint8_t impUse[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2615: FILE: fs/udf/ecma_167.h:471:
+	uint8_t fileIdent[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2616: FILE: fs/udf/ecma_167.h:472:
+	uint8_t padding[0];

WARNING:NEW_TYPEDEFS: do not add new typedefs
#2646: FILE: fs/udf/ecma_167.h:490:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <priorRecordedNumDirectEntries>
#2647: FILE: fs/udf/ecma_167.h:491:
+	__le32 priorRecordedNumDirectEntries;

CHECK:CAMELCASE: Avoid CamelCase: <strategyType>
#2648: FILE: fs/udf/ecma_167.h:492:
+	__le16 strategyType;

CHECK:CAMELCASE: Avoid CamelCase: <strategyParameter>
#2649: FILE: fs/udf/ecma_167.h:493:
+	__le16 strategyParameter;

CHECK:CAMELCASE: Avoid CamelCase: <numEntries>
#2650: FILE: fs/udf/ecma_167.h:494:
+	__le16 numEntries;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2651: FILE: fs/udf/ecma_167.h:495:
+	uint8_t reserved;

CHECK:CAMELCASE: Avoid CamelCase: <fileType>
#2652: FILE: fs/udf/ecma_167.h:496:
+	uint8_t fileType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2652: FILE: fs/udf/ecma_167.h:496:
+	uint8_t fileType;

CHECK:CAMELCASE: Avoid CamelCase: <parentICBLocation>
#2653: FILE: fs/udf/ecma_167.h:497:
+	lb_addr parentICBLocation;

CHECK:CAMELCASE: Avoid CamelCase: <indirectEntry>
#2667: FILE: fs/udf/ecma_167.h:543:
+struct indirectEntry {

CHECK:CAMELCASE: Avoid CamelCase: <icbTag>
#2669: FILE: fs/udf/ecma_167.h:545:
+	icbtag icbTag;

CHECK:CAMELCASE: Avoid CamelCase: <indirectICB>
#2670: FILE: fs/udf/ecma_167.h:546:
+	long_ad indirectICB;

CHECK:CAMELCASE: Avoid CamelCase: <terminalEntry>
#2678: FILE: fs/udf/ecma_167.h:550:
+struct terminalEntry {

CHECK:CAMELCASE: Avoid CamelCase: <fileLinkCount>
#2714: FILE: fs/udf/ecma_167.h:562:
+	__le16 fileLinkCount;

CHECK:CAMELCASE: Avoid CamelCase: <recordFormat>
#2715: FILE: fs/udf/ecma_167.h:563:
+	uint8_t recordFormat;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2715: FILE: fs/udf/ecma_167.h:563:
+	uint8_t recordFormat;

CHECK:CAMELCASE: Avoid CamelCase: <recordDisplayAttr>
#2716: FILE: fs/udf/ecma_167.h:564:
+	uint8_t recordDisplayAttr;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2716: FILE: fs/udf/ecma_167.h:564:
+	uint8_t recordDisplayAttr;

CHECK:CAMELCASE: Avoid CamelCase: <recordLength>
#2717: FILE: fs/udf/ecma_167.h:565:
+	__le32 recordLength;

CHECK:CAMELCASE: Avoid CamelCase: <logicalBlocksRecorded>
#2719: FILE: fs/udf/ecma_167.h:567:
+	__le64 logicalBlocksRecorded;

CHECK:CAMELCASE: Avoid CamelCase: <accessTime>
#2720: FILE: fs/udf/ecma_167.h:568:
+	timestamp accessTime;

CHECK:CAMELCASE: Avoid CamelCase: <modificationTime>
#2721: FILE: fs/udf/ecma_167.h:569:
+	timestamp modificationTime;

CHECK:CAMELCASE: Avoid CamelCase: <attrTime>
#2722: FILE: fs/udf/ecma_167.h:570:
+	timestamp attrTime;

CHECK:CAMELCASE: Avoid CamelCase: <extendedAttrICB>
#2724: FILE: fs/udf/ecma_167.h:572:
+	long_ad extendedAttrICB;

CHECK:CAMELCASE: Avoid CamelCase: <uniqueID>
#2726: FILE: fs/udf/ecma_167.h:574:
+	__le64 uniqueID;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2729: FILE: fs/udf/ecma_167.h:577:
+	uint8_t extendedAttr[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2730: FILE: fs/udf/ecma_167.h:578:
+	uint8_t allocDescs[0];

CHECK:CAMELCASE: Avoid CamelCase: <extendedAttrHeaderDesc>
#2743: FILE: fs/udf/ecma_167.h:619:
+struct extendedAttrHeaderDesc {

CHECK:CAMELCASE: Avoid CamelCase: <impAttrLocation>
#2745: FILE: fs/udf/ecma_167.h:621:
+	__le32 impAttrLocation;

CHECK:CAMELCASE: Avoid CamelCase: <appAttrLocation>
#2746: FILE: fs/udf/ecma_167.h:622:
+	__le32 appAttrLocation;

CHECK:CAMELCASE: Avoid CamelCase: <genericFormat>
#2757: FILE: fs/udf/ecma_167.h:626:
+struct genericFormat {

CHECK:CAMELCASE: Avoid CamelCase: <attrType>
#2758: FILE: fs/udf/ecma_167.h:627:
+	__le32 attrType;

CHECK:CAMELCASE: Avoid CamelCase: <attrSubtype>
#2759: FILE: fs/udf/ecma_167.h:628:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2759: FILE: fs/udf/ecma_167.h:628:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2760: FILE: fs/udf/ecma_167.h:629:
+	uint8_t reserved[3];

CHECK:CAMELCASE: Avoid CamelCase: <attrLength>
#2761: FILE: fs/udf/ecma_167.h:630:
+	__le32 attrLength;

CHECK:CAMELCASE: Avoid CamelCase: <attrData>
#2762: FILE: fs/udf/ecma_167.h:631:
+	uint8_t attrData[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2762: FILE: fs/udf/ecma_167.h:631:
+	uint8_t attrData[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2777: FILE: fs/udf/ecma_167.h:637:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2778: FILE: fs/udf/ecma_167.h:638:
+	uint8_t reserved[3];

CHECK:CAMELCASE: Avoid CamelCase: <escapeSeqLength>
#2780: FILE: fs/udf/ecma_167.h:640:
+	__le32 escapeSeqLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2781: FILE: fs/udf/ecma_167.h:641:
+	uint8_t charSetType;

CHECK:CAMELCASE: Avoid CamelCase: <escapeSeq>
#2782: FILE: fs/udf/ecma_167.h:642:
+	uint8_t escapeSeq[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2782: FILE: fs/udf/ecma_167.h:642:
+	uint8_t escapeSeq[0];

CHECK:CAMELCASE: Avoid CamelCase: <altPerms>
#2795: FILE: fs/udf/ecma_167.h:646:
+struct altPerms {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2797: FILE: fs/udf/ecma_167.h:648:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2798: FILE: fs/udf/ecma_167.h:649:
+	uint8_t reserved[3];

CHECK:CAMELCASE: Avoid CamelCase: <ownerIdent>
#2800: FILE: fs/udf/ecma_167.h:651:
+	__le16 ownerIdent;

CHECK:CAMELCASE: Avoid CamelCase: <groupIdent>
#2801: FILE: fs/udf/ecma_167.h:652:
+	__le16 groupIdent;

CHECK:CAMELCASE: Avoid CamelCase: <fileTimesExtAttr>
#2815: FILE: fs/udf/ecma_167.h:657:
+struct fileTimesExtAttr {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2817: FILE: fs/udf/ecma_167.h:659:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2818: FILE: fs/udf/ecma_167.h:660:
+	uint8_t reserved[3];

CHECK:CAMELCASE: Avoid CamelCase: <dataLength>
#2820: FILE: fs/udf/ecma_167.h:662:
+	__le32 dataLength;

CHECK:CAMELCASE: Avoid CamelCase: <fileTimeExistence>
#2821: FILE: fs/udf/ecma_167.h:663:
+	__le32 fileTimeExistence;

CHECK:CAMELCASE: Avoid CamelCase: <fileTimes>
#2822: FILE: fs/udf/ecma_167.h:664:
+	uint8_t fileTimes;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2822: FILE: fs/udf/ecma_167.h:664:
+	uint8_t fileTimes;

CHECK:CAMELCASE: Avoid CamelCase: <infoTimesExtAttr>
#2839: FILE: fs/udf/ecma_167.h:674:
+struct infoTimesExtAttr {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2841: FILE: fs/udf/ecma_167.h:676:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2842: FILE: fs/udf/ecma_167.h:677:
+	uint8_t reserved[3];

CHECK:CAMELCASE: Avoid CamelCase: <infoTimeExistence>
#2845: FILE: fs/udf/ecma_167.h:680:
+	__le32 infoTimeExistence;

CHECK:CAMELCASE: Avoid CamelCase: <infoTimes>
#2846: FILE: fs/udf/ecma_167.h:681:
+	uint8_t infoTimes[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2846: FILE: fs/udf/ecma_167.h:681:
+	uint8_t infoTimes[0];

CHECK:CAMELCASE: Avoid CamelCase: <deviceSpec>
#2860: FILE: fs/udf/ecma_167.h:685:
+struct deviceSpec {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2862: FILE: fs/udf/ecma_167.h:687:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2863: FILE: fs/udf/ecma_167.h:688:
+	uint8_t reserved[3];

CHECK:CAMELCASE: Avoid CamelCase: <impUseLength>
#2865: FILE: fs/udf/ecma_167.h:690:
+	__le32 impUseLength;

CHECK:CAMELCASE: Avoid CamelCase: <majorDeviceIdent>
#2866: FILE: fs/udf/ecma_167.h:691:
+	__le32 majorDeviceIdent;

CHECK:CAMELCASE: Avoid CamelCase: <minorDeviceIdent>
#2867: FILE: fs/udf/ecma_167.h:692:
+	__le32 minorDeviceIdent;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2868: FILE: fs/udf/ecma_167.h:693:
+	uint8_t impUse[0];

CHECK:CAMELCASE: Avoid CamelCase: <impUseExtAttr>
#2881: FILE: fs/udf/ecma_167.h:697:
+struct impUseExtAttr {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2883: FILE: fs/udf/ecma_167.h:699:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2884: FILE: fs/udf/ecma_167.h:700:
+	uint8_t reserved[3];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2888: FILE: fs/udf/ecma_167.h:704:
+	uint8_t impUse[0];

CHECK:CAMELCASE: Avoid CamelCase: <appUseExtAttr>
#2901: FILE: fs/udf/ecma_167.h:708:
+struct appUseExtAttr {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2903: FILE: fs/udf/ecma_167.h:710:
+	uint8_t attrSubtype;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2904: FILE: fs/udf/ecma_167.h:711:
+	uint8_t reserved[3];

CHECK:CAMELCASE: Avoid CamelCase: <appUseLength>
#2906: FILE: fs/udf/ecma_167.h:713:
+	__le32 appUseLength;

CHECK:CAMELCASE: Avoid CamelCase: <appUse>
#2908: FILE: fs/udf/ecma_167.h:715:
+	uint8_t appUse[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2908: FILE: fs/udf/ecma_167.h:715:
+	uint8_t appUse[0];

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceEntry>
#2924: FILE: fs/udf/ecma_167.h:727:
+struct unallocSpaceEntry {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2928: FILE: fs/udf/ecma_167.h:731:
+	uint8_t allocDescs[0];

CHECK:CAMELCASE: Avoid CamelCase: <numOfBits>
#2940: FILE: fs/udf/ecma_167.h:737:
+	__le32 numOfBits;

CHECK:CAMELCASE: Avoid CamelCase: <numOfBytes>
#2941: FILE: fs/udf/ecma_167.h:738:
+	__le32 numOfBytes;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2942: FILE: fs/udf/ecma_167.h:739:
+	uint8_t bitmap[0];

CHECK:CAMELCASE: Avoid CamelCase: <partitionIntegrityEntry>
#2955: FILE: fs/udf/ecma_167.h:743:
+struct partitionIntegrityEntry {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2959: FILE: fs/udf/ecma_167.h:747:
+	uint8_t integrityType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2960: FILE: fs/udf/ecma_167.h:748:
+	uint8_t reserved[175];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2962: FILE: fs/udf/ecma_167.h:750:
+	uint8_t impUse[256];

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolHeaderDesc>
#2974: FILE: fs/udf/ecma_167.h:766:
+struct logicalVolHeaderDesc {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2976: FILE: fs/udf/ecma_167.h:768:
+	uint8_t reserved[24];

CHECK:CAMELCASE: Avoid CamelCase: <pathComponent>
#2986: FILE: fs/udf/ecma_167.h:772:
+struct pathComponent {

CHECK:CAMELCASE: Avoid CamelCase: <componentType>
#2987: FILE: fs/udf/ecma_167.h:773:
+	uint8_t componentType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2987: FILE: fs/udf/ecma_167.h:773:
+	uint8_t componentType;

CHECK:CAMELCASE: Avoid CamelCase: <lengthComponentIdent>
#2988: FILE: fs/udf/ecma_167.h:774:
+	uint8_t lengthComponentIdent;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#2988: FILE: fs/udf/ecma_167.h:774:
+	uint8_t lengthComponentIdent;

CHECK:CAMELCASE: Avoid CamelCase: <componentFileVersionNum>
#2989: FILE: fs/udf/ecma_167.h:775:
+	__le16 componentFileVersionNum;

CHECK:CAMELCASE: Avoid CamelCase: <componentIdent>
#2990: FILE: fs/udf/ecma_167.h:776:
+	dstring componentIdent[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#3032: FILE: fs/udf/ecma_167.h:787:
+	uint8_t recordFormat;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#3033: FILE: fs/udf/ecma_167.h:788:
+	uint8_t recordDisplayAttr;

CHECK:CAMELCASE: Avoid CamelCase: <objectSize>
#3036: FILE: fs/udf/ecma_167.h:791:
+	__le64 objectSize;

CHECK:CAMELCASE: Avoid CamelCase: <createTime>
#3040: FILE: fs/udf/ecma_167.h:795:
+	timestamp createTime;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#3050: FILE: fs/udf/ecma_167.h:805:
+	uint8_t extendedAttr[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#3051: FILE: fs/udf/ecma_167.h:806:
+	uint8_t allocDescs[0];

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __packed over __attribute__((packed))
#3052: FILE: fs/udf/ecma_167.h:807:
+} __attribute__ ((packed));

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#3093: FILE: fs/udf/file.c:79:
+				     unsigned offset, unsigned to)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#3093: FILE: fs/udf/file.c:79:
+				     unsigned offset, unsigned to)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#3101: FILE: fs/udf/file.c:86:
+				    unsigned offset, unsigned to)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#3101: FILE: fs/udf/file.c:86:
+				    unsigned offset, unsigned to)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#3178: FILE: fs/udf/file.c:186:
+	if (file_permission(filp, MAY_READ) != 0) {
 	                    ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#3241: FILE: fs/udf/file.c:240:
+static int udf_release_file(struct inode *inode, struct file *filp)
                                                               ^^^^

CHECK:CAMELCASE: Avoid CamelCase: <numDirs>
#3318: FILE: fs/udf/ialloc.c:49:
+			    cpu_to_le32(le32_to_cpu(UDF_SB_LVIDIU(sb)->numDirs)

CHECK:CAMELCASE: Avoid CamelCase: <numFiles>
#3323: FILE: fs/udf/ialloc.c:53:
+			    cpu_to_le32(le32_to_cpu(UDF_SB_LVIDIU(sb)->numFiles)

CHECK:BRACES: braces {} should be used on all arms of this statement
#3396: FILE: fs/udf/ialloc.c:117:
+	if (dir->i_mode & S_ISGID) {
[...]
-	}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#3402: FILE: fs/udf/ialloc.c:121:
+	} else

WARNING:INDENTED_LABEL: labels should not be indented
#3499: FILE: fs/udf/inode.c:100:
+      no_delete:

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#3509: FILE: fs/udf/inode.c:133:
+			     unsigned from, unsigned to)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#3509: FILE: fs/udf/inode.c:133:
+			     unsigned from, unsigned to)

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#3617: FILE: fs/udf/inode.c:247:
+	sfibh.soffset = sfibh.eoffset =

WARNING:INDENTED_LABEL: labels should not be indented
#3699: FILE: fs/udf/inode.c:334:
+      abort:

WARNING:INDENTED_LABEL: labels should not be indented
#3704: FILE: fs/udf/inode.c:338:
+      abort_negative:

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#3735: FILE: fs/udf/inode.c:368:
+		    kernel_long_ad * last_ext, sector_t blocks)

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sb->s_blocksize_bits'
#3785: FILE: fs/udf/inode.c:408:
+		     (last_ext->extLength & UDF_EXTENT_LENGTH_MASK)) >> sb->
+		    s_blocksize_bits;

CHECK:BRACES: Unbalanced braces around else statement
#3799: FILE: fs/udf/inode.c:419:
+	} else

WARNING:INDENTED_LABEL: labels should not be indented
#3835: FILE: fs/udf/inode.c:448:
+      out:

CHECK:SPACING: No space is necessary after a cast
#3860: FILE: fs/udf/inode.c:490:
+	b_off = (loff_t) block << inode->i_sb->s_blocksize_bits;

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#3870: FILE: fs/udf/inode.c:494:
+	   current extent, and the previous extent */

The comment style is incorrect.  The preferred style for multi-
line comments is::

  /*
  * This is the preferred style
  * for multi line comments.
  */

The networking comment style is a bit different, with the first line
not empty like the former::

  /* This is the preferred comment style
  * for files in net/ and drivers/net/
  */

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#commenting

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#3888: FILE: fs/udf/inode.c:515:
+		if ((etype =

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#3912: FILE: fs/udf/inode.c:542:
+	   if the extent is not a multiple of the blocksize, round up */

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#4001: FILE: fs/udf/inode.c:618:
+		if ((etype =

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#4015: FILE: fs/udf/inode.c:631:
+	   block in the extent corresponding to the requested block */

CHECK:BRACES: Unbalanced braces around else statement
#4020: FILE: fs/udf/inode.c:634:
+	else {			/* otherwise, allocate a new block */

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#4050: FILE: fs/udf/inode.c:658:
+	   block, requested block, and blocks after requested block */

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#4061: FILE: fs/udf/inode.c:671:
+	   the new number of extents is less than the old number */

WARNING:SPACING: space prohibited before semicolon
#4117: FILE: fs/udf/inode.c:709:
+		if (blen == 1) ;

ERROR:TRAILING_STATEMENTS: trailing statements should be on next line
#4117: FILE: fs/udf/inode.c:709:
+		if (blen == 1) ;

CHECK:BRACES: braces {} should be used on all arms of this statement
#4117: FILE: fs/udf/inode.c:709:
+		if (blen == 1) ;
[...]
+		else if (!offset || blen == offset + 1) {
[...]
+		} else {
[...]

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#4123: FILE: fs/udf/inode.c:715:
+			laarr[curr + 2] = laarr[curr + 1] = laarr[curr];

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb'
#4134: FILE: fs/udf/inode.c:726:
+								      inode->
+								      i_sb->

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'i_sb->s_blocksize_bits'
#4135: FILE: fs/udf/inode.c:727:
+								      i_sb->
+								      s_blocksize_bits);

CHECK:BRACES: Unbalanced braces around else statement
#4142: FILE: fs/udf/inode.c:731:
+			} else

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb->s_blocksize_bits'
#4178: FILE: fs/udf/inode.c:753:
+			    (etype << 30) | ((blen - (offset + 1)) << inode->
+					     i_sb->s_blocksize_bits);

CHECK:BRACES: braces {} should be used on all arms of this statement
#4210: FILE: fs/udf/inode.c:772:
+		if ((laarr[c + 1].extLength >> 30) ==
[...]
+		} else
[...]

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#4213: FILE: fs/udf/inode.c:775:
+			length = currlength =

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[c+1].extLength'
#4215: FILE: fs/udf/inode.c:777:
+			    (((laarr[c + 1].
+			       extLength & UDF_EXTENT_LENGTH_MASK) +

CHECK:BRACES: Unbalanced braces around else statement
#4218: FILE: fs/udf/inode.c:780:
+		} else

CHECK:BRACES: braces {} should be used on all arms of this statement
#4227: FILE: fs/udf/inode.c:785:
+		if (i == *endnum) {
[...]
-		}
[...]
+			length +=
[...]

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[start].extLocation.partitionReferenceNum'
#4262: FILE: fs/udf/inode.c:805:
+						   laarr[start].extLocation.
+						   partitionReferenceNum,

CHECK:BRACES: Unbalanced braces around else statement
#4286: FILE: fs/udf/inode.c:817:
+			else {

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb->s_blocksize_bits'
#4296: FILE: fs/udf/inode.c:827:
+								  inode->i_sb->
+								  s_blocksize_bits);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4307: FILE: fs/udf/inode.c:834:
+				    ((laarr[i].
+				      extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb->s_blocksize_bits'
#4317: FILE: fs/udf/inode.c:841:
+					    (numalloc << inode->i_sb->
+					     s_blocksize_bits);

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#4390: FILE: fs/udf/inode.c:871:
+			     (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))
+			    ||

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4397: FILE: fs/udf/inode.c:878:
+				if (((laarr[i].
+				      extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i+1].extLength'
#4399: FILE: fs/udf/inode.c:880:
+				     (laarr[i + 1].
+				      extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4405: FILE: fs/udf/inode.c:886:
+					     (laarr[i].
+					      extLength &

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb'
#4408: FILE: fs/udf/inode.c:889:
+					     UDF_EXTENT_LENGTH_MASK) & ~(inode->
+									 i_sb->

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'i_sb->s_blocksize'
#4409: FILE: fs/udf/inode.c:890:
+									 i_sb->
+									 s_blocksize

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4413: FILE: fs/udf/inode.c:894:
+					    (laarr[i].
+					     extLength & UDF_EXTENT_FLAG_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLocation.logicalBlockNum'
#4419: FILE: fs/udf/inode.c:900:
+					    laarr[i].extLocation.
+					    logicalBlockNum +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4421: FILE: fs/udf/inode.c:902:
+					    ((laarr[i].
+					      extLength &

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb->s_blocksize_bits'
#4423: FILE: fs/udf/inode.c:904:
+					      UDF_EXTENT_LENGTH_MASK) >> inode->
+					     i_sb->s_blocksize_bits);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4428: FILE: fs/udf/inode.c:909:
+					    (((laarr[i].
+					       extLength &

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (16, 20)
#4449: FILE: fs/udf/inode.c:923:
+		} else
+		    if (((laarr[i].extLength >> 30) ==

CHECK:BRACES: Unbalanced braces around else statement
#4449: FILE: fs/udf/inode.c:923:
+		} else

WARNING:TABSTOP: Statements should start on a tabstop
#4450: FILE: fs/udf/inode.c:924:
+		    if (((laarr[i].extLength >> 30) ==

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#4452: FILE: fs/udf/inode.c:926:
+			 (EXT_NOT_RECORDED_ALLOCATED >> 30))
+			&& ((laarr[i + 1].extLength >> 30) ==

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4457: FILE: fs/udf/inode.c:931:
+					((laarr[i].
+					  extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4478: FILE: fs/udf/inode.c:944:
+				     (laarr[i].
+				      extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb->s_blocksize'
#4480: FILE: fs/udf/inode.c:946:
+				     UDF_EXTENT_LENGTH_MASK) & ~(inode->i_sb->
+								 s_blocksize -

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4484: FILE: fs/udf/inode.c:950:
+				    (laarr[i].
+				     extLength & UDF_EXTENT_FLAG_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4490: FILE: fs/udf/inode.c:956:
+				    (((laarr[i].
+				       extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4522: FILE: fs/udf/inode.c:971:
+					((laarr[i].
+					  extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'laarr[i].extLength'
#4531: FILE: fs/udf/inode.c:978:
+			    (laarr[i].
+			     extLength & UDF_EXTENT_LENGTH_MASK) |

CHECK:BRACES: braces {} should be used on all arms of this statement
#4623: FILE: fs/udf/inode.c:1050:
+			if (UDF_I_ALLOCTYPE(inode) == ICBTAG_FLAG_AD_IN_ICB) {
[...]
-			}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#4629: FILE: fs/udf/inode.c:1054:
+			} else

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#4688: FILE: fs/udf/inode.c:1107:
+		printk(KERN_ERR

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#4730: FILE: fs/udf/inode.c:1136:
+					if (ident == TAG_IDENT_FE
+					    || ident == TAG_IDENT_EFE) {

CHECK:BRACES: Unbalanced braces around else statement
#4748: FILE: fs/udf/inode.c:1149:
+				} else

CHECK:BRACES: Unbalanced braces around else statement
#4753: FILE: fs/udf/inode.c:1152:
+		} else

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRWXUGO' are not preferred. Consider using octal permissions '0777'.
#5043: FILE: fs/udf/inode.c:1376:
+			inode->i_mode = S_IFLNK | S_IRWXUGO;

Permission bits in the octal form are more readable and easier to
understand than their symbolic counterparts because many command-line
tools use this notation. Experienced kernel developers have been using
these traditional Unix permission bits for decades and so they find it
easier to understand the octal notation than the symbolic macros.
For example, it is harder to read S_IWUSR|S_IRUGO than 0644, which
obscures the developer's intent rather than clarifying it.

See: https://lore.kernel.org/lkml/CA+55aFw5v23T-zvDZp-MmD_EYxF8WbafwwB59934FV7g21uMGQ@mail.gmail.com/

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#5051: FILE: fs/udf/inode.c:1381:
+			printk(KERN_ERR

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'udf_fill_inode', this function's name, in a string
#5052: FILE: fs/udf/inode.c:1382:
+			       "udf: udf_fill_inode(ino %ld) failed unknown file type=%d\n",

Embedded function names are less appropriate to use as
refactoring can cause function renaming.  Prefer the use of
"%s", __func__ to embedded function names.

Note that this does not work with -f (--file) checkpatch option
as it depends on patch context providing the function name.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'dsea->minorDeviceIdent'
#5077: FILE: fs/udf/inode.c:1397:
+						 le32_to_cpu(dsea->
+							     minorDeviceIdent)));

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#5094: FILE: fs/udf/inode.c:1410:
+		printk(KERN_ERR

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'udf_alloc_i_data', this function's name, in a string
#5095: FILE: fs/udf/inode.c:1411:
+		       "udf:udf_alloc_i_data (ino %ld) no free memory\n",

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRWXO' are not preferred. Consider using octal permissions '0007'.
#5119: FILE: fs/udf/inode.c:1428:
+	mode = ((permissions) & S_IRWXO) |

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRWXG' are not preferred. Consider using octal permissions '0070'.
#5120: FILE: fs/udf/inode.c:1429:
+	    ((permissions >> 2) & S_IRWXG) |

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRWXU' are not preferred. Consider using octal permissions '0700'.
#5121: FILE: fs/udf/inode.c:1430:
+	    ((permissions >> 4) & S_IRWXU) |

CHECK:SPACING: No space is necessary after a cast
#5203: FILE: fs/udf/inode.c:1515:
+				    ((uint8_t *) & (use->descTag))[i];

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#5203: FILE: fs/udf/inode.c:1515:
+				    ((uint8_t *) & (use->descTag))[i];
 				                 ^

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around use->descTag
#5203: FILE: fs/udf/inode.c:1515:
+				    ((uint8_t *) & (use->descTag))[i];

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRWXO' are not preferred. Consider using octal permissions '0007'.
#5224: FILE: fs/udf/inode.c:1532:
+	udfperms = ((inode->i_mode & S_IRWXO)) |

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRWXG' are not preferred. Consider using octal permissions '0070'.
#5225: FILE: fs/udf/inode.c:1533:
+	    ((inode->i_mode & S_IRWXG) << 2) | ((inode->i_mode & S_IRWXU) << 4);

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRWXU' are not preferred. Consider using octal permissions '0700'.
#5225: FILE: fs/udf/inode.c:1533:
+	    ((inode->i_mode & S_IRWXG) << 2) | ((inode->i_mode & S_IRWXU) << 4);

CHECK:SPACING: No space is necessary after a cast
#5272: FILE: fs/udf/inode.c:1565:
+		eid = (regid *) dsea->impUse;

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb->s_blocksize_bits'
#5316: FILE: fs/udf/inode.c:1606:
+							   (inode->i_sb->
+							    s_blocksize_bits -

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_sb->s_blocksize_bits'
#5319: FILE: fs/udf/inode.c:1609:
+							  1) >> (inode->i_sb->
+								 s_blocksize_bits

CHECK:SPACING: No space is necessary after a cast
#5404: FILE: fs/udf/inode.c:1696:
+			    ((uint8_t *) & (fe->descTag))[i];

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#5404: FILE: fs/udf/inode.c:1696:
+			    ((uint8_t *) & (fe->descTag))[i];
 			                 ^

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around fe->descTag
#5404: FILE: fs/udf/inode.c:1696:
+			    ((uint8_t *) & (fe->descTag))[i];

WARNING:INDENTED_LABEL: labels should not be indented
#5448: FILE: fs/udf/inode.c:1739:
+      out_iput:

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5455: FILE: fs/udf/inode.c:1744:
+int8_t udf_add_aext(struct inode * inode, struct extent_position * epos,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5455: FILE: fs/udf/inode.c:1744:
+int8_t udf_add_aext(struct inode * inode, struct extent_position * epos,

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5486: FILE: fs/udf/inode.c:1774:
+		if (!

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5496: FILE: fs/udf/inode.c:1781:
+		if (!

CHECK:SPACING: No space is necessary after a cast
#5565: FILE: fs/udf/inode.c:1831:
+				sad = (short_ad *) sptr;

CHECK:SPACING: No space is necessary after a cast
#5580: FILE: fs/udf/inode.c:1841:
+				lad = (long_ad *) sptr;

CHECK:BRACES: braces {} should be used on all arms of this statement
#5592: FILE: fs/udf/inode.c:1850:
+		if (epos->bh) {
[...]
 			brelse(epos->bh);
[...]

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#5594: FILE: fs/udf/inode.c:1852:
+			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT)
+			    || UDF_SB_UDFREV(inode->i_sb) >= 0x0201)

CHECK:BRACES: Unbalanced braces around else statement
#5604: FILE: fs/udf/inode.c:1859:
+		} else

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#5627: FILE: fs/udf/inode.c:1874:
+		if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT)
+		    || UDF_SB_UDFREV(inode->i_sb) >= 0x0201)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5642: FILE: fs/udf/inode.c:1886:
+int8_t udf_write_aext(struct inode * inode, struct extent_position * epos,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5642: FILE: fs/udf/inode.c:1886:
+int8_t udf_write_aext(struct inode * inode, struct extent_position * epos,

CHECK:SPACING: No space is necessary after a cast
#5663: FILE: fs/udf/inode.c:1902:
+			short_ad *sad = (short_ad *) ptr;

CHECK:SPACING: No space is necessary after a cast
#5673: FILE: fs/udf/inode.c:1910:
+			long_ad *lad = (long_ad *) ptr;

CHECK:BRACES: braces {} should be used on all arms of this statement
#5691: FILE: fs/udf/inode.c:1921:
+	if (epos->bh) {
[...]
 		mark_buffer_dirty_inode(epos->bh, inode);
[...]

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#5693: FILE: fs/udf/inode.c:1923:
+		if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT)
+		    || UDF_SB_UDFREV(inode->i_sb) >= 0x0201) {

CHECK:BRACES: Unbalanced braces around else statement
#5704: FILE: fs/udf/inode.c:1931:
+	} else

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5714: FILE: fs/udf/inode.c:1939:
+int8_t udf_next_aext(struct inode * inode, struct extent_position * epos,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5714: FILE: fs/udf/inode.c:1939:
+int8_t udf_next_aext(struct inode * inode, struct extent_position * epos,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5715: FILE: fs/udf/inode.c:1940:
+		     kernel_lb_addr * eloc, uint32_t * elen, int inc)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5715: FILE: fs/udf/inode.c:1940:
+		     kernel_lb_addr * eloc, uint32_t * elen, int inc)

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5728: FILE: fs/udf/inode.c:1949:
+		if (!

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5746: FILE: fs/udf/inode.c:1964:
+int8_t udf_current_aext(struct inode * inode, struct extent_position * epos,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5746: FILE: fs/udf/inode.c:1964:
+int8_t udf_current_aext(struct inode * inode, struct extent_position * epos,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5747: FILE: fs/udf/inode.c:1965:
+			kernel_lb_addr * eloc, uint32_t * elen, int inc)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5747: FILE: fs/udf/inode.c:1965:
+			kernel_lb_addr * eloc, uint32_t * elen, int inc)

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5788: FILE: fs/udf/inode.c:1994:
+			if (!

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sad->extLength'
#5802: FILE: fs/udf/inode.c:2006:
+			    le32_to_cpu(sad->
+					extLength) & UDF_EXTENT_LENGTH_MASK;

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5811: FILE: fs/udf/inode.c:2013:
+			if (!

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'lad->extLength'
#5821: FILE: fs/udf/inode.c:2022:
+			    le32_to_cpu(lad->
+					extLength) & UDF_EXTENT_LENGTH_MASK;

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5849: FILE: fs/udf/inode.c:2058:
+int8_t udf_delete_aext(struct inode * inode, struct extent_position epos,

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#5904: FILE: fs/udf/inode.c:2108:
+			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT)
+			    || UDF_SB_UDFREV(inode->i_sb) >= 0x0201)

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#5935: FILE: fs/udf/inode.c:2127:
+			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT)
+			    || UDF_SB_UDFREV(inode->i_sb) >= 0x0201)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5951: FILE: fs/udf/inode.c:2142:
+int8_t inode_bmap(struct inode * inode, sector_t block,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5952: FILE: fs/udf/inode.c:2143:
+		  struct extent_position * pos, kernel_lb_addr * eloc,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5952: FILE: fs/udf/inode.c:2143:
+		  struct extent_position * pos, kernel_lb_addr * eloc,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5953: FILE: fs/udf/inode.c:2144:
+		  uint32_t * elen, sector_t * offset)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5953: FILE: fs/udf/inode.c:2144:
+		  uint32_t * elen, sector_t * offset)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#5953: FILE: fs/udf/inode.c:2144:
+		  uint32_t * elen, sector_t * offset)

CHECK:SPACING: No space is necessary after a cast
#5957: FILE: fs/udf/inode.c:2147:
+	    (loff_t) block << inode->i_sb->s_blocksize_bits;

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5976: FILE: fs/udf/inode.c:2161:
+		if ((etype = udf_next_aext(inode, pos, eloc, elen, 1)) == -1) {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#6088: FILE: fs/udf/misc.c:49:
+					   uint32_t type, uint8_t loc)

CHECK:BRACES: Unbalanced braces around else statement
#6098: FILE: fs/udf/misc.c:59:
+	else {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#6117: FILE: fs/udf/misc.c:73:
+		if (UDF_I_LENALLOC(inode)) {
 			memmove(&ad[size], ad, UDF_I_LENALLOC(inode));
 		}

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#6130: FILE: fs/udf/misc.c:81:
+			    TAG_IDENT_EAHD
+			    || le32_to_cpu(eahd->descTag.tagLocation) !=

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#6168: FILE: fs/udf/misc.c:106:
+				uint32_t aal =

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#6182: FILE: fs/udf/misc.c:115:
+				uint32_t ial =

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#6200: FILE: fs/udf/misc.c:125:
+				uint32_t aal =

CHECK:SPACING: No space is necessary after a cast
#6220: FILE: fs/udf/misc.c:142:
+				    ((uint8_t *) & (eahd->descTag))[i];

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#6220: FILE: fs/udf/misc.c:142:
+				    ((uint8_t *) & (eahd->descTag))[i];
 				                 ^

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around eahd->descTag
#6220: FILE: fs/udf/misc.c:142:
+				    ((uint8_t *) & (eahd->descTag))[i];

WARNING:BRACES: braces {} are not necessary for single statement blocks
#6226: FILE: fs/udf/misc.c:146:
+	if (loc & 0x02) {
 	}

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#6271: FILE: fs/udf/misc.c:181:
+			if (le32_to_cpu(gaf->attrType) == type
+			    && gaf->attrSubtype == subtype)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#6282: FILE: fs/udf/misc.c:201:
+				    uint32_t location, uint16_t * ident)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#6282: FILE: fs/udf/misc.c:201:
+				    uint32_t location, uint16_t * ident)

CHECK:SPACING: No space is necessary after a cast
#6300: FILE: fs/udf/misc.c:219:
+	tag_p = (tag *) (bh->b_data);

CHECK:SPACING: No space is necessary after a cast
#6319: FILE: fs/udf/misc.c:233:
+		checksum += (uint8_t) (bh->b_data[i]);

CHECK:SPACING: No space is necessary after a cast
#6322: FILE: fs/udf/misc.c:235:
+		checksum += (uint8_t) (bh->b_data[i]);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'tag_p->descCRCLength'
#6346: FILE: fs/udf/misc.c:253:
+						   le16_to_cpu(tag_p->
+							       descCRCLength),

WARNING:INDENTED_LABEL: labels should not be indented
#6356: FILE: fs/udf/misc.c:261:
+      error_out:

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#6364: FILE: fs/udf/misc.c:267:
+				     uint32_t offset, uint16_t * ident)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#6364: FILE: fs/udf/misc.c:267:
+				     uint32_t offset, uint16_t * ident)

CHECK:SPACING: No space is necessary after a cast
#6374: FILE: fs/udf/misc.c:275:
+	tag *tptr = (tag *) data;

CHECK:SPACING: No space is necessary after a cast
#6386: FILE: fs/udf/misc.c:286:
+			tptr->tagChecksum += (uint8_t) (data[i]);

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#6391: FILE: fs/udf/misc.c:290:
+		 uint32_t loc, int length)

CHECK:SPACING: No space is necessary after a cast
#6394: FILE: fs/udf/misc.c:292:
+	tag *tptr = (tag *) data;

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#6419: FILE: fs/udf/namei.c:45:
+		 uint8_t * impuse, uint8_t * fileident)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#6419: FILE: fs/udf/namei.c:45:
+		 uint8_t * impuse, uint8_t * fileident)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#6419: FILE: fs/udf/namei.c:45:
+		 uint8_t * impuse, uint8_t * fileident)

CHECK:SPACING: No space is necessary after a cast
#6441: FILE: fs/udf/namei.c:65:
+			memcpy((uint8_t *) sfi->impUse, impuse, liu);

CHECK:BRACES: Unbalanced braces around else statement
#6448: FILE: fs/udf/namei.c:68:
+		else {

CHECK:SPACING: No space is necessary after a cast
#6449: FILE: fs/udf/namei.c:69:
+			memcpy((uint8_t *) sfi->impUse, impuse, -offset);

CHECK:SPACING: No space is necessary after a cast
#6462: FILE: fs/udf/namei.c:79:
+			memcpy((uint8_t *) sfi->fileIdent + liu, fileident,

CHECK:BRACES: Unbalanced braces around else statement
#6470: FILE: fs/udf/namei.c:83:
+		else {

CHECK:SPACING: No space is necessary after a cast
#6471: FILE: fs/udf/namei.c:84:
+			memcpy((uint8_t *) sfi->fileIdent + liu, fileident,

CHECK:SPACING: No space is necessary after a cast
#6482: FILE: fs/udf/namei.c:94:
+		memset((uint8_t *) sfi->padding + liu + lfi, 0x00, padlen);

CHECK:BRACES: Unbalanced braces around else statement
#6488: FILE: fs/udf/namei.c:97:
+	else {

CHECK:SPACING: No space is necessary after a cast
#6489: FILE: fs/udf/namei.c:98:
+		memset((uint8_t *) sfi->padding + liu + lfi, 0x00, -offset);

CHECK:SPACING: No space is necessary after a cast
#6496: FILE: fs/udf/namei.c:103:
+	    udf_crc((uint8_t *) cfi + sizeof(tag),

CHECK:SPACING: No space is necessary after a cast
#6502: FILE: fs/udf/namei.c:107:
+		crc = udf_crc((uint8_t *) sfi->impUse,

CHECK:BRACES: Unbalanced braces around else statement
#6517: FILE: fs/udf/namei.c:116:
+	else {

CHECK:SPACING: No space is necessary after a cast
#6518: FILE: fs/udf/namei.c:117:
+		crc = udf_crc((uint8_t *) sfi->impUse,

CHECK:SPACING: No space is necessary after a cast
#6531: FILE: fs/udf/namei.c:128:
+			checksum += ((uint8_t *) & cfi->descTag)[i];

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#6531: FILE: fs/udf/namei.c:128:
+			checksum += ((uint8_t *) & cfi->descTag)[i];
 			                         ^

CHECK:SPACING: No space is necessary after a cast
#6541: FILE: fs/udf/namei.c:132:
+		memcpy((uint8_t *) sfi, (uint8_t *) cfi,

CHECK:BRACES: Unbalanced braces around else statement
#6543: FILE: fs/udf/namei.c:134:
+	else {

CHECK:SPACING: No space is necessary after a cast
#6544: FILE: fs/udf/namei.c:135:
+		memcpy((uint8_t *) sfi, (uint8_t *) cfi, -fibh->soffset);

CHECK:SPACING: No space is necessary after a cast
#6545: FILE: fs/udf/namei.c:136:
+		memcpy(fibh->ebh->b_data, (uint8_t *) cfi - fibh->soffset,

CHECK:BRACES: Unbalanced braces around else statement
#6553: FILE: fs/udf/namei.c:142:
+	else {

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#6586: FILE: fs/udf/namei.c:171:
+	fibh->soffset = fibh->eoffset =

CHECK:BRACES: braces {} should be used on all arms of this statement
#6598: FILE: fs/udf/namei.c:179:
+		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
[...]
-		}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#6605: FILE: fs/udf/namei.c:184:
+		} else

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6610: FILE: fs/udf/namei.c:187:
+		if (!(fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block))) {

CHECK:SPACING: No space is necessary after a cast
#6659: FILE: fs/udf/namei.c:222:
+				    (uint8_t *) (fibh->ebh->b_data + poffset -

CHECK:BRACES: Unbalanced braces around else statement
#6661: FILE: fs/udf/namei.c:224:
+			else {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6696: FILE: fs/udf/namei.c:246:
+		if ((flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi))) {

WARNING:TYPO_SPELLING: 'nd' may be misspelled - perhaps 'and'?
#6710: FILE: fs/udf/namei.c:296:
+				 struct nameidata *nd)
 				                   ^^

ERROR:OPEN_BRACE: that open brace { should be on the previous line
#6728: FILE: fs/udf/namei.c:310:
+		kernel_lb_addr lb =
+		    { 0, simple_strtoul(dentry->d_name.name + 3, NULL, 0) };

WARNING:CONSIDER_KSTRTO: simple_strtoul is obsolete, use kstrtoul instead
#6728: FILE: fs/udf/namei.c:310:
+		    { 0, simple_strtoul(dentry->d_name.name + 3, NULL, 0) };

The simple_strtol(), simple_strtoll(), simple_strtoul(), and
simple_strtoull() functions explicitly ignore overflows, which
may lead to unexpected results in callers.  The respective kstrtol(),
kstrtoll(), kstrtoul(), and kstrtoull() functions tend to be the
correct replacements.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#simple-strtol-simple-strtoll-simple-strtoul-simple-strtoull

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (8, 8)
#6739: FILE: fs/udf/namei.c:316:
+	} else
[...]
+	if (udf_find_entry(dir, dentry, &fibh, &cfi)) {

CHECK:BRACES: Unbalanced braces around else statement
#6739: FILE: fs/udf/namei.c:316:
+	} else

CHECK:BRACES: braces {} should be used on all arms of this statement
#6788: FILE: fs/udf/namei.c:359:
+	if (dentry) {
[...]
 			return NULL;
[...]

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6796: FILE: fs/udf/namei.c:365:
+		if (!

CHECK:BRACES: Unbalanced braces around else statement
#6805: FILE: fs/udf/namei.c:372:
+	} else

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#6813: FILE: fs/udf/namei.c:379:
+	fibh->soffset = fibh->eoffset =

CHECK:BRACES: Unbalanced braces around else statement
#6832: FILE: fs/udf/namei.c:392:
+		} else

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6837: FILE: fs/udf/namei.c:395:
+		if (!(fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block))) {

CHECK:BRACES: Unbalanced braces around else statement
#6874: FILE: fs/udf/namei.c:428:
+		else {

CHECK:BRACES: Unbalanced braces around else statement
#6888: FILE: fs/udf/namei.c:438:
+			else {

CHECK:BRACES: Unbalanced braces around else statement
#6918: FILE: fs/udf/namei.c:459:
+				else {

WARNING:INDENTED_LABEL: labels should not be indented
#6938: FILE: fs/udf/namei.c:481:
+      add:

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6953: FILE: fs/udf/namei.c:494:
+		if (!

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'dir->i_sb->s_blocksize_bits'
#6998: FILE: fs/udf/namei.c:527:
+							dir->i_sb->
+							s_blocksize_bits);

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7021: FILE: fs/udf/namei.c:542:
+		if (!

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'dir->i_sb->s_blocksize_bits'
#7043: FILE: fs/udf/namei.c:556:
+								dir->i_sb->
+								s_blocksize_bits);

CHECK:BRACES: Unbalanced braces around else statement
#7044: FILE: fs/udf/namei.c:557:
+			} else

WARNING:TYPO_SPELLING: 'nd' may be misspelled - perhaps 'and'?
#7105: FILE: fs/udf/namei.c:608:
+		      struct nameidata *nd)
 		                        ^^

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7126: FILE: fs/udf/namei.c:631:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

CHECK:SPACING: No space is necessary after a cast
#7137: FILE: fs/udf/namei.c:640:
+	*(__le32 *) ((struct allocDescImpUse *)cfi.icb.impUse)->impUse =

CHECK:CAMELCASE: Avoid CamelCase: <allocDescImpUse>
#7137: FILE: fs/udf/namei.c:640:
+	*(__le32 *) ((struct allocDescImpUse *)cfi.icb.impUse)->impUse =

WARNING:BRACES: braces {} are not necessary for single statement blocks
#7142: FILE: fs/udf/namei.c:643:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7166: FILE: fs/udf/namei.c:673:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

CHECK:SPACING: No space is necessary after a cast
#7177: FILE: fs/udf/namei.c:682:
+	*(__le32 *) ((struct allocDescImpUse *)cfi.icb.impUse)->impUse =

WARNING:BRACES: braces {} are not necessary for single statement blocks
#7182: FILE: fs/udf/namei.c:685:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

WARNING:INDENTED_LABEL: labels should not be indented
#7191: FILE: fs/udf/namei.c:695:
+      out:

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7218: FILE: fs/udf/namei.c:719:
+	if (!(fi = udf_add_entry(inode, NULL, &fibh, &cfi, &err))) {

CHECK:SPACING: No space is necessary after a cast
#7229: FILE: fs/udf/namei.c:728:
+	*(__le32 *) ((struct allocDescImpUse *)cfi.icb.impUse)->impUse =

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7242: FILE: fs/udf/namei.c:739:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

CHECK:SPACING: No space is necessary after a cast
#7252: FILE: fs/udf/namei.c:747:
+	*(__le32 *) ((struct allocDescImpUse *)cfi.icb.impUse)->impUse =

WARNING:INDENTED_LABEL: labels should not be indented
#7262: FILE: fs/udf/namei.c:758:
+      out:

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#7276: FILE: fs/udf/namei.c:777:
+	fibh.soffset = fibh.eoffset =

CHECK:BRACES: braces {} should be used on all arms of this statement
#7289: FILE: fs/udf/namei.c:786:
+		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
[...]
-		}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#7296: FILE: fs/udf/namei.c:791:
+		} else

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7301: FILE: fs/udf/namei.c:794:
+		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#7334: FILE: fs/udf/namei.c:816:
+		if (cfi.lengthFileIdent
+		    && (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#7363: FILE: fs/udf/namei.c:862:
+	inode->i_ctime = dir->i_ctime = dir->i_mtime =

WARNING:INDENTED_LABEL: labels should not be indented
#7368: FILE: fs/udf/namei.c:866:
+      end_rmdir:

WARNING:INDENTED_LABEL: labels should not be indented
#7373: FILE: fs/udf/namei.c:870:
+      out:

WARNING:INDENTED_LABEL: labels should not be indented
#7405: FILE: fs/udf/namei.c:909:
+      end_unlink:

WARNING:INDENTED_LABEL: labels should not be indented
#7410: FILE: fs/udf/namei.c:913:
+      out:

CHECK:BRACES: Unbalanced braces around else statement
#7473: FILE: fs/udf/namei.c:975:
+	} else

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#7519: FILE: fs/udf/namei.c:1014:
+			else if ((symname - compstart) == 2
+				 && compstart[1] == '.')

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7527: FILE: fs/udf/namei.c:1019:
+			if (!

CHECK:SPACING: No space is necessary after a cast
#7568: FILE: fs/udf/namei.c:1060:
+		*(__le32 *) ((struct allocDescImpUse *)cfi.icb.impUse)->impUse =

WARNING:BRACES: braces {} are not necessary for single statement blocks
#7578: FILE: fs/udf/namei.c:1068:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

WARNING:INDENTED_LABEL: labels should not be indented
#7587: FILE: fs/udf/namei.c:1077:
+      out:

WARNING:INDENTED_LABEL: labels should not be indented
#7592: FILE: fs/udf/namei.c:1081:
+      out_no_entry:

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7618: FILE: fs/udf/namei.c:1101:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

CHECK:SPACING: No space is necessary after a cast
#7636: FILE: fs/udf/namei.c:1114:
+		*(__le32 *) ((struct allocDescImpUse *)cfi.icb.impUse)->impUse =

WARNING:BRACES: braces {} are not necessary for single statement blocks
#7646: FILE: fs/udf/namei.c:1122:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7674: FILE: fs/udf/namei.c:1153:
+	if ((ofi = udf_find_entry(old_dir, old_dentry, &ofibh, &ocfi))) {

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#7749: FILE: fs/udf/namei.c:1207:
+		if (!new_inode
+		    && new_dir->i_nlink >=

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'dir_fi->lengthOfImpUse'
#7784: FILE: fs/udf/namei.c:1248:
+						le16_to_cpu(dir_fi->
+							    lengthOfImpUse) +

WARNING:BRACES: braces {} are not necessary for any arm of this statement
#7786: FILE: fs/udf/namei.c:1250:
+		if (UDF_I_ALLOCTYPE(old_inode) == ICBTAG_FLAG_AD_IN_ICB) {
[...]
-		}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#7790: FILE: fs/udf/namei.c:1252:
+		} else

WARNING:INDENTED_LABEL: labels should not be indented
#7817: FILE: fs/udf/namei.c:1271:
+      end_rename:

CHECK:CAMELCASE: Avoid CamelCase: <UDFIdentSuffix>
#7862: FILE: fs/udf/osta_udf.h:68:
+struct UDFIdentSuffix {

CHECK:CAMELCASE: Avoid CamelCase: <UDFRevision>
#7863: FILE: fs/udf/osta_udf.h:69:
+	__le16 UDFRevision;

CHECK:CAMELCASE: Avoid CamelCase: <OSClass>
#7864: FILE: fs/udf/osta_udf.h:70:
+	uint8_t OSClass;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7864: FILE: fs/udf/osta_udf.h:70:
+	uint8_t OSClass;

CHECK:CAMELCASE: Avoid CamelCase: <OSIdentifier>
#7865: FILE: fs/udf/osta_udf.h:71:
+	uint8_t OSIdentifier;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7865: FILE: fs/udf/osta_udf.h:71:
+	uint8_t OSIdentifier;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7866: FILE: fs/udf/osta_udf.h:72:
+	uint8_t reserved[4];

CHECK:CAMELCASE: Avoid CamelCase: <impIdentSuffix>
#7874: FILE: fs/udf/osta_udf.h:75:
+struct impIdentSuffix {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7875: FILE: fs/udf/osta_udf.h:76:
+	uint8_t OSClass;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7876: FILE: fs/udf/osta_udf.h:77:
+	uint8_t OSIdentifier;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7877: FILE: fs/udf/osta_udf.h:78:
+	uint8_t reserved[6];

CHECK:CAMELCASE: Avoid CamelCase: <appIdentSuffix>
#7883: FILE: fs/udf/osta_udf.h:81:
+struct appIdentSuffix {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7884: FILE: fs/udf/osta_udf.h:82:
+	uint8_t impUse[8];

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolIntegrityDescImpUse>
#7898: FILE: fs/udf/osta_udf.h:87:
+struct logicalVolIntegrityDescImpUse {

CHECK:CAMELCASE: Avoid CamelCase: <minUDFReadRev>
#7902: FILE: fs/udf/osta_udf.h:91:
+	__le16 minUDFReadRev;

CHECK:CAMELCASE: Avoid CamelCase: <minUDFWriteRev>
#7903: FILE: fs/udf/osta_udf.h:92:
+	__le16 minUDFWriteRev;

CHECK:CAMELCASE: Avoid CamelCase: <maxUDFWriteRev>
#7904: FILE: fs/udf/osta_udf.h:93:
+	__le16 maxUDFWriteRev;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7905: FILE: fs/udf/osta_udf.h:94:
+	uint8_t impUse[0];

CHECK:CAMELCASE: Avoid CamelCase: <impUseVolDescImpUse>
#7919: FILE: fs/udf/osta_udf.h:99:
+struct impUseVolDescImpUse {

CHECK:CAMELCASE: Avoid CamelCase: <LVICharset>
#7920: FILE: fs/udf/osta_udf.h:100:
+	charspec LVICharset;

CHECK:CAMELCASE: Avoid CamelCase: <LVInfo1>
#7922: FILE: fs/udf/osta_udf.h:102:
+	dstring LVInfo1[36];

CHECK:CAMELCASE: Avoid CamelCase: <LVInfo2>
#7923: FILE: fs/udf/osta_udf.h:103:
+	dstring LVInfo2[36];

CHECK:CAMELCASE: Avoid CamelCase: <LVInfo3>
#7924: FILE: fs/udf/osta_udf.h:104:
+	dstring LVInfo3[36];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7926: FILE: fs/udf/osta_udf.h:106:
+	uint8_t impUse[128];

CHECK:CAMELCASE: Avoid CamelCase: <udfPartitionMap2>
#7937: FILE: fs/udf/osta_udf.h:109:
+struct udfPartitionMap2 {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7938: FILE: fs/udf/osta_udf.h:110:
+	uint8_t partitionMapType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7939: FILE: fs/udf/osta_udf.h:111:
+	uint8_t partitionMapLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7940: FILE: fs/udf/osta_udf.h:112:
+	uint8_t reserved1[2];

CHECK:CAMELCASE: Avoid CamelCase: <partIdent>
#7941: FILE: fs/udf/osta_udf.h:113:
+	regid partIdent;

CHECK:CAMELCASE: Avoid CamelCase: <virtualPartitionMap>
#7956: FILE: fs/udf/osta_udf.h:119:
+struct virtualPartitionMap {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7957: FILE: fs/udf/osta_udf.h:120:
+	uint8_t partitionMapType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7958: FILE: fs/udf/osta_udf.h:121:
+	uint8_t partitionMapLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7959: FILE: fs/udf/osta_udf.h:122:
+	uint8_t reserved1[2];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7963: FILE: fs/udf/osta_udf.h:126:
+	uint8_t reserved2[24];

CHECK:CAMELCASE: Avoid CamelCase: <sparablePartitionMap>
#7980: FILE: fs/udf/osta_udf.h:130:
+struct sparablePartitionMap {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7981: FILE: fs/udf/osta_udf.h:131:
+	uint8_t partitionMapType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7982: FILE: fs/udf/osta_udf.h:132:
+	uint8_t partitionMapLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7983: FILE: fs/udf/osta_udf.h:133:
+	uint8_t reserved1[2];

CHECK:CAMELCASE: Avoid CamelCase: <packetLength>
#7987: FILE: fs/udf/osta_udf.h:137:
+	__le16 packetLength;

CHECK:CAMELCASE: Avoid CamelCase: <numSparingTables>
#7988: FILE: fs/udf/osta_udf.h:138:
+	uint8_t numSparingTables;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7988: FILE: fs/udf/osta_udf.h:138:
+	uint8_t numSparingTables;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#7989: FILE: fs/udf/osta_udf.h:139:
+	uint8_t reserved2[1];

CHECK:CAMELCASE: Avoid CamelCase: <sizeSparingTable>
#7990: FILE: fs/udf/osta_udf.h:140:
+	__le32 sizeSparingTable;

CHECK:CAMELCASE: Avoid CamelCase: <locSparingTable>
#7991: FILE: fs/udf/osta_udf.h:141:
+	__le32 locSparingTable[4];

CHECK:CAMELCASE: Avoid CamelCase: <metadataPartitionMap>
#8010: FILE: fs/udf/osta_udf.h:145:
+struct metadataPartitionMap {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8011: FILE: fs/udf/osta_udf.h:146:
+	uint8_t partitionMapType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8012: FILE: fs/udf/osta_udf.h:147:
+	uint8_t partitionMapLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8013: FILE: fs/udf/osta_udf.h:148:
+	uint8_t reserved1[2];

CHECK:CAMELCASE: Avoid CamelCase: <metadataFileLoc>
#8017: FILE: fs/udf/osta_udf.h:152:
+	__le32 metadataFileLoc;

CHECK:CAMELCASE: Avoid CamelCase: <metadataMirrorFileLoc>
#8018: FILE: fs/udf/osta_udf.h:153:
+	__le32 metadataMirrorFileLoc;

CHECK:CAMELCASE: Avoid CamelCase: <metadataBitmapFileLoc>
#8019: FILE: fs/udf/osta_udf.h:154:
+	__le32 metadataBitmapFileLoc;

CHECK:CAMELCASE: Avoid CamelCase: <allocUnitSize>
#8020: FILE: fs/udf/osta_udf.h:155:
+	__le32 allocUnitSize;

CHECK:CAMELCASE: Avoid CamelCase: <alignUnitSize>
#8021: FILE: fs/udf/osta_udf.h:156:
+	__le16 alignUnitSize;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8022: FILE: fs/udf/osta_udf.h:157:
+	uint8_t flags;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8023: FILE: fs/udf/osta_udf.h:158:
+	uint8_t reserved2[5];

CHECK:CAMELCASE: Avoid CamelCase: <virtualAllocationTable15>
#8033: FILE: fs/udf/osta_udf.h:162:
+struct virtualAllocationTable15 {

CHECK:CAMELCASE: Avoid CamelCase: <VirtualSector>
#8034: FILE: fs/udf/osta_udf.h:163:
+	__le32 VirtualSector[0];

CHECK:CAMELCASE: Avoid CamelCase: <vatIdent>
#8035: FILE: fs/udf/osta_udf.h:164:
+	regid vatIdent;

CHECK:CAMELCASE: Avoid CamelCase: <previousVATICBLoc>
#8036: FILE: fs/udf/osta_udf.h:165:
+	__le32 previousVATICBLoc;

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __packed over __attribute__((packed))
#8037: FILE: fs/udf/osta_udf.h:166:
+} __attribute__ ((packed));

CHECK:CAMELCASE: Avoid CamelCase: <virtualAllocationTable20>
#8056: FILE: fs/udf/osta_udf.h:171:
+struct virtualAllocationTable20 {

CHECK:CAMELCASE: Avoid CamelCase: <lengthHeader>
#8057: FILE: fs/udf/osta_udf.h:172:
+	__le16 lengthHeader;

CHECK:CAMELCASE: Avoid CamelCase: <lengthImpUse>
#8058: FILE: fs/udf/osta_udf.h:173:
+	__le16 lengthImpUse;

CHECK:CAMELCASE: Avoid CamelCase: <minReadRevision>
#8063: FILE: fs/udf/osta_udf.h:178:
+	__le16 minReadRevision;

CHECK:CAMELCASE: Avoid CamelCase: <minWriteRevision>
#8064: FILE: fs/udf/osta_udf.h:179:
+	__le16 minWriteRevision;

CHECK:CAMELCASE: Avoid CamelCase: <maxWriteRevision>
#8065: FILE: fs/udf/osta_udf.h:180:
+	__le16 maxWriteRevision;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8067: FILE: fs/udf/osta_udf.h:182:
+	uint8_t impUse[0];

CHECK:CAMELCASE: Avoid CamelCase: <vatEntry>
#8068: FILE: fs/udf/osta_udf.h:183:
+	__le32 vatEntry[0];

CHECK:CAMELCASE: Avoid CamelCase: <sparingEntry>
#8078: FILE: fs/udf/osta_udf.h:189:
+struct sparingEntry {

CHECK:CAMELCASE: Avoid CamelCase: <origLocation>
#8079: FILE: fs/udf/osta_udf.h:190:
+	__le32 origLocation;

CHECK:CAMELCASE: Avoid CamelCase: <mappedLocation>
#8080: FILE: fs/udf/osta_udf.h:191:
+	__le32 mappedLocation;

CHECK:CAMELCASE: Avoid CamelCase: <sparingTable>
#8090: FILE: fs/udf/osta_udf.h:194:
+struct sparingTable {

CHECK:CAMELCASE: Avoid CamelCase: <sparingIdent>
#8092: FILE: fs/udf/osta_udf.h:196:
+	regid sparingIdent;

CHECK:CAMELCASE: Avoid CamelCase: <reallocationTableLen>
#8093: FILE: fs/udf/osta_udf.h:197:
+	__le16 reallocationTableLen;

CHECK:CAMELCASE: Avoid CamelCase: <sequenceNum>
#8095: FILE: fs/udf/osta_udf.h:199:
+	__le32 sequenceNum;

CHECK:CAMELCASE: Avoid CamelCase: <mapEntry>
#8098: FILE: fs/udf/osta_udf.h:201:
+	 mapEntry[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8112: FILE: fs/udf/osta_udf.h:212:
+	uint8_t impUse[4];

CHECK:CAMELCASE: Avoid CamelCase: <freeEaSpace>
#8124: FILE: fs/udf/osta_udf.h:222:
+struct freeEaSpace {

CHECK:CAMELCASE: Avoid CamelCase: <headerChecksum>
#8125: FILE: fs/udf/osta_udf.h:223:
+	__le16 headerChecksum;

CHECK:CAMELCASE: Avoid CamelCase: <freeEASpace>
#8126: FILE: fs/udf/osta_udf.h:224:
+	uint8_t freeEASpace[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8126: FILE: fs/udf/osta_udf.h:224:
+	uint8_t freeEASpace[0];

CHECK:CAMELCASE: Avoid CamelCase: <DVDCopyrightImpUse>
#8136: FILE: fs/udf/osta_udf.h:228:
+struct DVDCopyrightImpUse {

CHECK:CAMELCASE: Avoid CamelCase: <CGMSInfo>
#8138: FILE: fs/udf/osta_udf.h:230:
+	uint8_t CGMSInfo;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8138: FILE: fs/udf/osta_udf.h:230:
+	uint8_t CGMSInfo;

CHECK:CAMELCASE: Avoid CamelCase: <dataType>
#8139: FILE: fs/udf/osta_udf.h:231:
+	uint8_t dataType;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8139: FILE: fs/udf/osta_udf.h:231:
+	uint8_t dataType;

CHECK:CAMELCASE: Avoid CamelCase: <protectionSystemInfo>
#8140: FILE: fs/udf/osta_udf.h:232:
+	uint8_t protectionSystemInfo[4];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8140: FILE: fs/udf/osta_udf.h:232:
+	uint8_t protectionSystemInfo[4];

CHECK:CAMELCASE: Avoid CamelCase: <freeAppEASpace>
#8149: FILE: fs/udf/osta_udf.h:237:
+struct freeAppEASpace {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8151: FILE: fs/udf/osta_udf.h:239:
+	uint8_t freeEASpace[0];

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#8171: FILE: fs/udf/partition.c:32:
+			       uint16_t partition, uint32_t offset)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#8192: FILE: fs/udf/partition.c:47:
+uint32_t udf_get_pblock_virt15(struct super_block * sb, uint32_t block,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#8193: FILE: fs/udf/partition.c:48:
+			       uint16_t partition, uint32_t offset)

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#8238: FILE: fs/udf/partition.c:80:
+	if (!(bh = sb_bread(sb, loc))) {

CHECK:SPACING: No space is necessary after a cast
#8246: FILE: fs/udf/partition.c:86:
+	loc = le32_to_cpu(((__le32 *) bh->b_data)[index]);

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#8264: FILE: fs/udf/partition.c:100:
+inline uint32_t udf_get_pblock_virt20(struct super_block * sb, uint32_t block,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#8265: FILE: fs/udf/partition.c:101:
+				      uint16_t partition, uint32_t offset)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#8271: FILE: fs/udf/partition.c:106:
+uint32_t udf_get_pblock_spar15(struct super_block * sb, uint32_t block,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#8272: FILE: fs/udf/partition.c:107:
+			       uint16_t partition, uint32_t offset)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#8277: FILE: fs/udf/partition.c:111:
+	uint32_t packet =

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_spar_map[i]"
#8287: FILE: fs/udf/partition.c:116:
+		if (UDF_SB_TYPESPAR(sb, partition).s_spar_map[i] != NULL) {

Comparisons to NULL in the form (foo == NULL) or (foo != NULL)
are better written as (!foo) and (foo).

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->mapEntry[i].mappedLocation'
#8314: FILE: fs/udf/partition.c:132:
+				return le32_to_cpu(st->mapEntry[i].
+						   mappedLocation) + ((block +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_spar_map[j]->b_data'
#8361: FILE: fs/udf/partition.c:169:
+					st = (struct sparingTable *)sdata->
+					    s_spar_map[j]->b_data;

WARNING:DEEP_INDENTATION: Too many leading tabs - consider code refactoring
#8386: FILE: fs/udf/partition.c:182:
+						if (sdata->s_spar_map[j]) {

Indentation with 6 or more tabs usually indicate overly indented
code.

It is suggested to refactor excessive indentation of
if/else/for/do/while/switch statements.

See: https://lore.kernel.org/lkml/1328311239.21255.24.camel@joe2Laptop/

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_spar_map[j]'
#8390: FILE: fs/udf/partition.c:186:
+							    sdata->
+							    s_spar_map[j]->

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_spar_map[j]->b_data'
#8391: FILE: fs/udf/partition.c:187:
+							    s_spar_map[j]->
+							    b_data;

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->mapEntry[k].origLocation'
#8393: FILE: fs/udf/partition.c:189:
+							st->mapEntry[k].
+							    origLocation =

CHECK:SPACING: space preferred before that '+' (ctx:ExE)
#8400: FILE: fs/udf/partition.c:196:
+								       +
 								       ^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->reallocationTableLen'
#8403: FILE: fs/udf/partition.c:199:
+								       (st->
+									reallocationTableLen)

CHECK:SPACING: space preferred before that '*' (ctx:ExE)
#8404: FILE: fs/udf/partition.c:200:
+								       *
 								       ^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_spar_map[j]'
#8410: FILE: fs/udf/partition.c:206:
+							    (sdata->
+							     s_spar_map[j]);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->mapEntry[k].mappedLocation'
#8417: FILE: fs/udf/partition.c:211:
+					    le32_to_cpu(st->mapEntry[k].
+							mappedLocation) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_packet_len'
#8421: FILE: fs/udf/partition.c:215:
+							      i)) & (sdata->
+								     s_packet_len

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (32, 36)
#8429: FILE: fs/udf/partition.c:218:
+				} else
+				    if (le32_to_cpu

CHECK:BRACES: Unbalanced braces around else statement
#8429: FILE: fs/udf/partition.c:218:
+				} else

WARNING:TABSTOP: Statements should start on a tabstop
#8430: FILE: fs/udf/partition.c:219:
+				    if (le32_to_cpu

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'st->mapEntry[k].origLocation'
#8430: FILE: fs/udf/partition.c:219:
+				    if (le32_to_cpu
+					(st->mapEntry[k].origLocation) ==
+					packet) {

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->mapEntry[k].mappedLocation'
#8435: FILE: fs/udf/partition.c:224:
+					    le32_to_cpu(st->mapEntry[k].
+							mappedLocation) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_packet_len'
#8439: FILE: fs/udf/partition.c:228:
+							      i)) & (sdata->
+								     s_packet_len

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (32, 36)
#8444: FILE: fs/udf/partition.c:231:
+				} else
+				    if (le32_to_cpu

CHECK:BRACES: Unbalanced braces around else statement
#8444: FILE: fs/udf/partition.c:231:
+				} else

WARNING:TABSTOP: Statements should start on a tabstop
#8445: FILE: fs/udf/partition.c:232:
+				    if (le32_to_cpu

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'st->mapEntry[k].origLocation'
#8445: FILE: fs/udf/partition.c:232:
+				    if (le32_to_cpu
+					(st->mapEntry[k].origLocation) > packet)

WARNING:DEEP_INDENTATION: Too many leading tabs - consider code refactoring
#8469: FILE: fs/udf/partition.c:241:
+						if (sdata->s_spar_map[j]) {

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_spar_map[j]'
#8473: FILE: fs/udf/partition.c:245:
+							    sdata->
+							    s_spar_map[j]->

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_spar_map[j]->b_data'
#8474: FILE: fs/udf/partition.c:246:
+							    s_spar_map[j]->
+							    b_data;

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->mapEntry[k+1]'
#8480: FILE: fs/udf/partition.c:252:
+							memmove(&st->
+								mapEntry[k + 1],

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->mapEntry[k]'
#8482: FILE: fs/udf/partition.c:254:
+								&st->
+								mapEntry[k],

CHECK:SPACING: space preferred before that '+' (ctx:ExE)
#8494: FILE: fs/udf/partition.c:266:
+								       +
 								       ^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->reallocationTableLen'
#8497: FILE: fs/udf/partition.c:269:
+								       (st->
+									reallocationTableLen)

CHECK:SPACING: space preferred before that '*' (ctx:ExE)
#8498: FILE: fs/udf/partition.c:270:
+								       *
 								       ^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_spar_map[j]'
#8504: FILE: fs/udf/partition.c:276:
+							    (sdata->
+							     s_spar_map[j]);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->mapEntry[k].mappedLocation'
#8511: FILE: fs/udf/partition.c:281:
+					    le32_to_cpu(st->mapEntry[k].
+							mappedLocation) +

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sdata->s_packet_len'
#8515: FILE: fs/udf/partition.c:285:
+							      i)) & (sdata->
+								     s_packet_len

WARNING:INDENTED_LABEL: labels should not be indented
#8657: FILE: fs/udf/super.c:204:
+      out:

WARNING:INDENTED_LABEL: labels should not be indented
#8660: FILE: fs/udf/super.c:206:
+      out1:

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#8669: FILE: fs/udf/super.c:217:
+    module_exit(exit_udf_fs)$

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#8907: FILE: fs/udf/super.c:437:
+			printk(KERN_ERR "udf: bad mount option \"%s\" "

WARNING:SPLIT_STRING: quoted string split across lines
#8908: FILE: fs/udf/super.c:438:
+			printk(KERN_ERR "udf: bad mount option \"%s\" "
+			       "or missing value\n", p);

Quoted strings that appear as messages in userspace and can be
grepped, should not be split across multiple lines.

See: https://lore.kernel.org/lkml/20120203052727.GA15035@leaf/

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (16, 20)
#9012: FILE: fs/udf/super.c:562:
+		} else
+		    if (!strncmp

CHECK:BRACES: Unbalanced braces around else statement
#9012: FILE: fs/udf/super.c:562:
+		} else

WARNING:TABSTOP: Statements should start on a tabstop
#9013: FILE: fs/udf/super.c:563:
+		    if (!strncmp

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (16, 20)
#9067: FILE: fs/udf/super.c:591:
+		} else
+		    if (!strncmp

CHECK:BRACES: Unbalanced braces around else statement
#9067: FILE: fs/udf/super.c:591:
+		} else

WARNING:TABSTOP: Statements should start on a tabstop
#9068: FILE: fs/udf/super.c:592:
+		    if (!strncmp

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (20, 16)
#9068: FILE: fs/udf/super.c:592:
+		    if (!strncmp
[...]
+		} else

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (16, 20)
#9070: FILE: fs/udf/super.c:594:
+		} else
+		    if (!strncmp

CHECK:BRACES: Unbalanced braces around else statement
#9070: FILE: fs/udf/super.c:594:
+		} else

WARNING:TABSTOP: Statements should start on a tabstop
#9071: FILE: fs/udf/super.c:595:
+		    if (!strncmp

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (16, 20)
#9078: FILE: fs/udf/super.c:599:
+		} else
+		    if (!strncmp

CHECK:BRACES: Unbalanced braces around else statement
#9078: FILE: fs/udf/super.c:599:
+		} else

WARNING:TABSTOP: Statements should start on a tabstop
#9079: FILE: fs/udf/super.c:600:
+		    if (!strncmp

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (16, 20)
#9085: FILE: fs/udf/super.c:603:
+		} else
+		    if (!strncmp

CHECK:BRACES: Unbalanced braces around else statement
#9085: FILE: fs/udf/super.c:603:
+		} else

WARNING:TABSTOP: Statements should start on a tabstop
#9086: FILE: fs/udf/super.c:604:
+		    if (!strncmp

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#9127: FILE: fs/udf/super.c:665:
+			if (last[i] < 0 || !(bh = sb_bread(sb, last[i]))) {

CHECK:SPACING: No space is necessary after a cast
#9136: FILE: fs/udf/super.c:669:
+				    le16_to_cpu(((tag *) bh->b_data)->tagIdent);

CHECK:SPACING: No space is necessary after a cast
#9138: FILE: fs/udf/super.c:671:
+				    le32_to_cpu(((tag *) bh->b_data)->

CHECK:BRACES: Unbalanced braces around else statement
#9177: FILE: fs/udf/super.c:692:
+				} else

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9182: FILE: fs/udf/super.c:697:
+			} else if (ident == TAG_IDENT_FE
+				   || ident == TAG_IDENT_EFE) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#9191: FILE: fs/udf/super.c:701:
+				if (last[i] < 256

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9192: FILE: fs/udf/super.c:702:
+				if (last[i] < 256
+				    || !(bh = sb_bread(sb, last[i] - 256))) {

CHECK:SPACING: No space is necessary after a cast
#9201: FILE: fs/udf/super.c:706:
+					    le16_to_cpu(((tag *) bh->b_data)->

CHECK:SPACING: No space is necessary after a cast
#9204: FILE: fs/udf/super.c:709:
+					    le32_to_cpu(((tag *) bh->b_data)->

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#9222: FILE: fs/udf/super.c:720:
+					if (last[i] < 312 + UDF_SB_SESSION(sb)

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9223: FILE: fs/udf/super.c:721:
+					if (last[i] < 312 + UDF_SB_SESSION(sb)
+					    || !(bh =

CHECK:SPACING: No space is necessary after a cast
#9236: FILE: fs/udf/super.c:729:
+						    le16_to_cpu(((tag *) bh->

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'bh->b_data'
#9237: FILE: fs/udf/super.c:730:
+						    le16_to_cpu(((tag *) bh->
+								 b_data)->

CHECK:SPACING: No space is necessary after a cast
#9240: FILE: fs/udf/super.c:733:
+						    le32_to_cpu(((tag *) bh->

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'bh->b_data'
#9241: FILE: fs/udf/super.c:734:
+						    le32_to_cpu(((tag *) bh->
+								 b_data)->

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#9277: FILE: fs/udf/super.c:758:
+		if ((bh = sb_bread(sb, 312 + UDF_SB_SESSION(sb)))) {

CHECK:SPACING: No space is necessary after a cast
#9278: FILE: fs/udf/super.c:759:
+			ident = le16_to_cpu(((tag *) bh->b_data)->tagIdent);

CHECK:SPACING: No space is necessary after a cast
#9280: FILE: fs/udf/super.c:761:
+			    le32_to_cpu(((tag *) bh->b_data)->tagLocation);

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9307: FILE: fs/udf/super.c:781:
+								   TAG_IDENT_FE
+								   && ident !=

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#9319: FILE: fs/udf/super.c:794:
+udf_find_fileset(struct super_block *sb, kernel_lb_addr * fileset,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#9320: FILE: fs/udf/super.c:795:
+		 kernel_lb_addr * root)

CHECK:CAMELCASE: Avoid CamelCase: <udf_CS0toUTF8>
#9481: FILE: fs/udf/super.c:911:
+		if (udf_CS0toUTF8(&outstr, &instr)) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#9500: FILE: fs/udf/super.c:926:
+		 kernel_lb_addr * root)

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9572: FILE: fs/udf/super.c:976:
+			     PD_PARTITION_CONTENTS_NSR02)
+			    || !strcmp(p->partitionContents.ident,

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'p->partitionContentsUse'
#9588: FILE: fs/udf/super.c:982:
+				    (struct partitionHeaderDesc *)(p->
+								   partitionContentsUse);

ERROR:OPEN_BRACE: that open brace { should be on the previous line
#9591: FILE: fs/udf/super.c:985:
+					kernel_lb_addr loc =
+					    { le32_to_cpu(phd->

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'phd->unallocSpaceTable'
#9592: FILE: fs/udf/super.c:986:
+					    { le32_to_cpu(phd->
+							  unallocSpaceTable.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'unallocSpaceTable.extPosition'
#9593: FILE: fs/udf/super.c:987:
+							  unallocSpaceTable.
+							  extPosition), i };

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_table'
#9596: FILE: fs/udf/super.c:990:
+					UDF_SB_PARTMAPS(sb)[i].s_uspace.
+					    s_table = udf_iget(sb, loc);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_table->i_ino'
#9603: FILE: fs/udf/super.c:997:
+					     UDF_SB_PARTMAPS(sb)[i].s_uspace.
+					     s_table->i_ino);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_bitmap'
#9619: FILE: fs/udf/super.c:1002:
+					if (UDF_SB_PARTMAPS(sb)[i].s_uspace.
+					    s_bitmap != NULL) {

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_bitmap"
#9619: FILE: fs/udf/super.c:1002:
+					    s_bitmap != NULL) {

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_bitmap->s_extLength'
#9621: FILE: fs/udf/super.c:1004:
+						UDF_SB_PARTMAPS(sb)[i].s_uspace.
+						    s_bitmap->s_extLength =

CHECK:CAMELCASE: Avoid CamelCase: <s_extLength>
#9621: FILE: fs/udf/super.c:1004:
+						    s_bitmap->s_extLength =

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'phd->unallocSpaceBitmap'
#9623: FILE: fs/udf/super.c:1006:
+						    le32_to_cpu(phd->
+								unallocSpaceBitmap.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'unallocSpaceBitmap.extLength'
#9624: FILE: fs/udf/super.c:1007:
+								unallocSpaceBitmap.
+								extLength);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_bitmap->s_extPosition'
#9626: FILE: fs/udf/super.c:1009:
+						UDF_SB_PARTMAPS(sb)[i].s_uspace.
+						    s_bitmap->s_extPosition =

CHECK:CAMELCASE: Avoid CamelCase: <s_extPosition>
#9626: FILE: fs/udf/super.c:1009:
+						    s_bitmap->s_extPosition =

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'phd->unallocSpaceBitmap'
#9628: FILE: fs/udf/super.c:1011:
+						    le32_to_cpu(phd->
+								unallocSpaceBitmap.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'unallocSpaceBitmap.extPosition'
#9629: FILE: fs/udf/super.c:1012:
+								unallocSpaceBitmap.
+								extPosition);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_bitmap->s_extPosition'
#9637: FILE: fs/udf/super.c:1020:
+						     s_uspace.s_bitmap->
+						     s_extPosition);

ERROR:OPEN_BRACE: that open brace { should be on the previous line
#9656: FILE: fs/udf/super.c:1029:
+					kernel_lb_addr loc =
+					    { le32_to_cpu(phd->freedSpaceTable.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'phd->freedSpaceTable.extPosition'
#9657: FILE: fs/udf/super.c:1030:
+					    { le32_to_cpu(phd->freedSpaceTable.
+							  extPosition), i };

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_table'
#9660: FILE: fs/udf/super.c:1033:
+					UDF_SB_PARTMAPS(sb)[i].s_fspace.
+					    s_table = udf_iget(sb, loc);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_table->i_ino'
#9667: FILE: fs/udf/super.c:1040:
+					     UDF_SB_PARTMAPS(sb)[i].s_fspace.
+					     s_table->i_ino);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_bitmap'
#9683: FILE: fs/udf/super.c:1045:
+					if (UDF_SB_PARTMAPS(sb)[i].s_fspace.
+					    s_bitmap != NULL) {

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_bitmap"
#9683: FILE: fs/udf/super.c:1045:
+					    s_bitmap != NULL) {

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_bitmap->s_extLength'
#9685: FILE: fs/udf/super.c:1047:
+						UDF_SB_PARTMAPS(sb)[i].s_fspace.
+						    s_bitmap->s_extLength =

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'phd->freedSpaceBitmap'
#9687: FILE: fs/udf/super.c:1049:
+						    le32_to_cpu(phd->
+								freedSpaceBitmap.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'freedSpaceBitmap.extLength'
#9688: FILE: fs/udf/super.c:1050:
+								freedSpaceBitmap.
+								extLength);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_bitmap->s_extPosition'
#9690: FILE: fs/udf/super.c:1052:
+						UDF_SB_PARTMAPS(sb)[i].s_fspace.
+						    s_bitmap->s_extPosition =

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'phd->freedSpaceBitmap'
#9692: FILE: fs/udf/super.c:1054:
+						    le32_to_cpu(phd->
+								freedSpaceBitmap.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'freedSpaceBitmap.extPosition'
#9693: FILE: fs/udf/super.c:1055:
+								freedSpaceBitmap.
+								extPosition);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_bitmap->s_extPosition'
#9701: FILE: fs/udf/super.c:1063:
+						     s_fspace.s_bitmap->
+						     s_extPosition);

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#9732: FILE: fs/udf/super.c:1083:
+		    kernel_lb_addr * fileset)

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9764: FILE: fs/udf/super.c:1095:
+	     i < UDF_SB_NUMPARTS(sb)
+	     && offset < le32_to_cpu(lvd->mapTableLength);

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around lvd->partitionMaps[offset]
#9766: FILE: fs/udf/super.c:1097:
+	     ((struct genericPartitionMap *)&(lvd->partitionMaps[offset]))->

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around lvd->partitionMaps[offset]
#9770: FILE: fs/udf/super.c:1101:
+		     &(lvd->partitionMaps[offset]))->partitionMapType;

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'lvd->partitionMaps'
#9774: FILE: fs/udf/super.c:1105:
+			    (struct genericPartitionMap1 *)&(lvd->
+							     partitionMaps

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'lvd->partitionMaps[offset]'
#9783: FILE: fs/udf/super.c:1114:
+			    (struct udfPartitionMap2 *)&(lvd->
+							 partitionMaps[offset]);

CHECK:SPACING: No space is necessary after a cast
#9788: FILE: fs/udf/super.c:1119:
+				    (((__le16 *) upm2->partIdent.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'upm2->partIdent.identSuffix'
#9789: FILE: fs/udf/super.c:1120:
+				    (((__le16 *) upm2->partIdent.
+				      identSuffix)[0]) == 0x0150) {

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (32, 36)
#9794: FILE: fs/udf/super.c:1125:
+				} else
+				    if (le16_to_cpu

CHECK:BRACES: Unbalanced braces around else statement
#9794: FILE: fs/udf/super.c:1125:
+				} else

WARNING:TABSTOP: Statements should start on a tabstop
#9795: FILE: fs/udf/super.c:1126:
+				    if (le16_to_cpu

CHECK:SPACING: No space is necessary after a cast
#9796: FILE: fs/udf/super.c:1127:
+					(((__le16 *) upm2->partIdent.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'upm2->partIdent.identSuffix'
#9797: FILE: fs/udf/super.c:1128:
+					(((__le16 *) upm2->partIdent.
+					  identSuffix)[0]) == 0x0200) {

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (24, 28)
#9811: FILE: fs/udf/super.c:1134:
+			} else
+			    if (!strncmp

CHECK:BRACES: Unbalanced braces around else statement
#9811: FILE: fs/udf/super.c:1134:
+			} else

WARNING:TABSTOP: Statements should start on a tabstop
#9812: FILE: fs/udf/super.c:1135:
+			    if (!strncmp

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'lvd->partitionMaps'
#9834: FILE: fs/udf/super.c:1143:
+				    (struct sparablePartitionMap *)&(lvd->
+								     partitionMaps

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'spm->locSparingTable[j]'
#9843: FILE: fs/udf/super.c:1152:
+					    le32_to_cpu(spm->
+							locSparingTable[j]);

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_spar_map[j]"
#9848: FILE: fs/udf/super.c:1157:
+					    s_spar_map[j] != NULL) {

WARNING:DEEP_INDENTATION: Too many leading tabs - consider code refactoring
#9853: FILE: fs/udf/super.c:1162:
+						if (ident != 0

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9854: FILE: fs/udf/super.c:1163:
+						if (ident != 0
+						    || strncmp(st->sparingIdent.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'st->sparingIdent.ident'
#9855: FILE: fs/udf/super.c:1164:
+						    || strncmp(st->sparingIdent.
+							       ident,

CHECK:SPACING: No space is necessary after a cast
#9899: FILE: fs/udf/super.c:1195:
+		long_ad *la = (long_ad *) & (lvd->logicalVolContentsUse[0]);

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#9899: FILE: fs/udf/super.c:1195:
+		long_ad *la = (long_ad *) & (lvd->logicalVolContentsUse[0]);
 		                          ^

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around lvd->logicalVolContentsUse[0]
#9899: FILE: fs/udf/super.c:1195:
+		long_ad *la = (long_ad *) & (lvd->logicalVolContentsUse[0]);

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#9956: FILE: fs/udf/super.c:1253:
+		     kernel_lb_addr * fileset)

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'vdp->nextVolDescSeqExt.extLocation'
#10059: FILE: fs/udf/super.c:1293:
+				    le32_to_cpu(vdp->nextVolDescSeqExt.
+						extLocation);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'vdp->nextVolDescSeqExt.extLength'
#10062: FILE: fs/udf/super.c:1296:
+				    le32_to_cpu(vdp->nextVolDescSeqExt.
+						extLength);

CHECK:BRACES: braces {} should be used on all arms of this statement
#10095: FILE: fs/udf/super.c:1329:
+			if (next_e) {
[...]
+			} else
[...]

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#10098: FILE: fs/udf/super.c:1332:
+				next_s = next_e = 0;

CHECK:BRACES: Unbalanced braces around else statement
#10099: FILE: fs/udf/super.c:1333:
+			} else

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#10153: FILE: fs/udf/super.c:1381:
+	else if ((block = udf_vrs(sb, silent)) == -1) {

CHECK:BRACES: Unbalanced braces around else statement
#10161: FILE: fs/udf/super.c:1387:
+	} else

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#10167: FILE: fs/udf/super.c:1391:
+static int udf_load_partition(struct super_block *sb, kernel_lb_addr * fileset)

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'anchor->reserveVolDescSeqExt.extLocation'
#10199: FILE: fs/udf/super.c:1422:
+			    le32_to_cpu(anchor->reserveVolDescSeqExt.
+					extLocation);

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#10214: FILE: fs/udf/super.c:1434:
+			    (udf_process_sequence(sb, main_s, main_e, fileset)
+			     && udf_process_sequence(sb, reserve_s, reserve_e,

WARNING:FUNCTION_ARGUMENTS: arguments for function declarations should follow identifier
#10230: FILE: fs/udf/super.c:1448:
+		switch UDF_SB_PARTTYPE

This warning is emitted due to any of the following reasons:

  1. Arguments for the function declaration do not follow
     the identifier name.  Example::

       void foo
       (int bar, int baz)

     This should be corrected to::

       void foo(int bar, int baz)

  2. Some arguments for the function definition do not
     have an identifier name.  Example::

       void foo(int)

     All arguments should have identifier names.

ERROR:OPEN_BRACE: open brace '{' following function definitions go on the next line
#10230: FILE: fs/udf/super.c:1448:
+		switch UDF_SB_PARTTYPE
+			(sb, i) {

WARNING:LONG_LINE_STRING: line length of 104 exceeds 100 columns
#10251: FILE: fs/udf/super.c:1463:
+					    ("Unable to determine Lastblock (For Virtual Partition)\n");

A string starts before but extends beyond the maximum line length.
To use a different maximum line length, the --max-line-length=n option
may be added while invoking checkpatch.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#breaking-long-lines-and-strings

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#10265: FILE: fs/udf/super.c:1472:
+					    UDF_SB_PARTVSN(sb, j)
+					    && UDF_SB_PARTNUM(sb,

CHECK:SPACING: No space is necessary after a cast
#10272: FILE: fs/udf/super.c:1477:
+						    UDF_SB_LASTBLOCK(sb) -

CHECK:SPACING: No space is necessary after a cast
#10355: FILE: fs/udf/super.c:1543:
+		    cpu_to_le16(udf_crc((char *)UDF_SB_LVID(sb) + sizeof(tag),

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'descTag.descCRCLength'
#10357: FILE: fs/udf/super.c:1545:
+					le16_to_cpu(UDF_SB_LVID(sb)->descTag.
+						    descCRCLength), 0));

CHECK:SPACING: No space is necessary after a cast
#10365: FILE: fs/udf/super.c:1551:
+				    ((uint8_t *) &

CHECK:SPACING: No space is necessary after a cast
#10397: FILE: fs/udf/super.c:1574:
+		if (UDF_SB_UDFREV(sb) >

CHECK:SPACING: No space is necessary after a cast
#10401: FILE: fs/udf/super.c:1578:
+		if (UDF_SB_UDFREV(sb) >

CHECK:SPACING: No space is necessary after a cast
#10411: FILE: fs/udf/super.c:1586:
+		    cpu_to_le16(udf_crc((char *)UDF_SB_LVID(sb) + sizeof(tag),

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'descTag.descCRCLength'
#10413: FILE: fs/udf/super.c:1588:
+					le16_to_cpu(UDF_SB_LVID(sb)->descTag.
+						    descCRCLength), 0));

CHECK:SPACING: No space is necessary after a cast
#10421: FILE: fs/udf/super.c:1594:
+				    ((uint8_t *) &

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#10494: FILE: fs/udf/super.c:1706:
+		uint16_t minUDFReadRev =

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#10496: FILE: fs/udf/super.c:1708:
+		uint16_t minUDFWriteRev =

WARNING:INDENTED_LABEL: labels should not be indented
#10587: FILE: fs/udf/super.c:1777:
+      error_out:

WARNING:TYPO_SPELLING: 'iput' may be misspelled - perhaps 'input'?
#10607: FILE: fs/udf/super.c:1783:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_uspace.
 			^^^^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_table'
#10608: FILE: fs/udf/super.c:1784:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_uspace.
+			     s_table);

WARNING:TYPO_SPELLING: 'iput' may be misspelled - perhaps 'input'?
#10611: FILE: fs/udf/super.c:1787:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_fspace.
 			^^^^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_table'
#10612: FILE: fs/udf/super.c:1788:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_fspace.
+			     s_table);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_crit([subsystem]dev, ... then dev_crit(dev, ... then pr_crit(...  to printk(KERN_CRIT ...
#10648: FILE: fs/udf/super.c:1828:
+	printk(KERN_CRIT "UDF-fs error (device %s): %s: %s\n",

WARNING:TYPO_SPELLING: 'iput' may be misspelled - perhaps 'input'?
#10697: FILE: fs/udf/super.c:1866:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_uspace.
 			^^^^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_table'
#10698: FILE: fs/udf/super.c:1867:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_uspace.
+			     s_table);

WARNING:TYPO_SPELLING: 'iput' may be misspelled - perhaps 'input'?
#10701: FILE: fs/udf/super.c:1870:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_fspace.
 			^^^^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_table'
#10702: FILE: fs/udf/super.c:1871:
+			iput(UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_fspace.
+			     s_table);

CHECK:SPACING: No space is necessary after a cast
#10767: FILE: fs/udf/super.c:1967:
+	ptr = (uint8_t *) bh->b_data;

CHECK:SPACING: No space is necessary after a cast
#10797: FILE: fs/udf/super.c:1986:
+			ptr = (uint8_t *) bh->b_data;

WARNING:INDENTED_LABEL: labels should not be indented
#10803: FILE: fs/udf/super.c:1991:
+      out:

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_bitmap'
#10855: FILE: fs/udf/super.c:2046:
+							      (sb)].s_uspace.
+					  s_bitmap);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_bitmap'
#10867: FILE: fs/udf/super.c:2054:
+							      (sb)].s_fspace.
+					  s_bitmap);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_uspace.s_table'
#10882: FILE: fs/udf/super.c:2065:
+							     (sb)].s_uspace.
+					 s_table);

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 's_fspace.s_table'
#10894: FILE: fs/udf/super.c:2073:
+							     (sb)].s_fspace.
+					 s_table);

CHECK:BRACES: Unbalanced braces around else statement
#10974: FILE: fs/udf/symlink.c:86:
+	else {

WARNING:INDENTED_LABEL: labels should not be indented
#10983: FILE: fs/udf/symlink.c:103:
+      out:

CHECK:BRACES: braces {} should be used on all arms of this statement
#11024: FILE: fs/udf/truncate.c:44:
+		if (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {
[...]
-		}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#11030: FILE: fs/udf/truncate.c:48:
+		} else

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_warn([subsystem]dev, ... then dev_warn(dev, ... then pr_warn(...  to printk(KERN_WARNING ...
#11077: FILE: fs/udf/truncate.c:100:
+				printk(KERN_WARNING

WARNING:LINE_CONTINUATIONS: Avoid line continuations in quoted strings
#11078: FILE: fs/udf/truncate.c:101:
+				       "udf_truncate_tail_extent():\

WARNING:LONG_LINE: line length of 200 exceeds 100 columns
#11079: FILE: fs/udf/truncate.c:102:
+ Too long extent after EOF in inode %u: i_size: %Ld lbcount: %Ld extent %u+%u\n", (unsigned)inode->i_ino, (long long)inode->i_size, (long long)lbcount, (unsigned)eloc.logicalBlockNum, (unsigned)elen);

The line has exceeded the specified maximum length.
To use a different maximum line length, the --max-line-length=n option
may be added while invoking checkpatch.

Earlier, the default line length was 80 columns.  Commit bdc48fa11e46
("checkpatch/coding-style: deprecate 80-column warning") increased the
limit to 100 columns.  This is not a hard limit either and it's
preferable to stay within 80 columns whenever possible.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#breaking-long-lines-and-strings

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#11079: FILE: fs/udf/truncate.c:102:
+ Too long extent after EOF in inode %u: i_size: %Ld lbcount: %Ld extent %u+%u\n", (unsigned)inode->i_ino, (long long)inode->i_size, (long long)lbcount, (unsigned)eloc.logicalBlockNum, (unsigned)elen);$

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#11079: FILE: fs/udf/truncate.c:102:
+ Too long extent after EOF in inode %u: i_size: %Ld lbcount: %Ld extent %u+%u\n", (unsigned)inode->i_ino, (long long)inode->i_size, (long long)lbcount, (unsigned)eloc.logicalBlockNum, (unsigned)elen);

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#11079: FILE: fs/udf/truncate.c:102:
+ Too long extent after EOF in inode %u: i_size: %Ld lbcount: %Ld extent %u+%u\n", (unsigned)inode->i_ino, (long long)inode->i_size, (long long)lbcount, (unsigned)eloc.logicalBlockNum, (unsigned)elen);

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#11079: FILE: fs/udf/truncate.c:102:
+ Too long extent after EOF in inode %u: i_size: %Ld lbcount: %Ld extent %u+%u\n", (unsigned)inode->i_ino, (long long)inode->i_size, (long long)lbcount, (unsigned)eloc.logicalBlockNum, (unsigned)elen);

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#11143: FILE: fs/udf/truncate.c:161:
+			if (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT)
+			    || UDF_SB_UDFREV(inode->i_sb) >= 0x0201)

WARNING:DEEP_INDENTATION: Too many leading tabs - consider code refactoring
#11223: FILE: fs/udf/truncate.c:234:
+						if (!UDF_QUERY_FLAG

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#11225: FILE: fs/udf/truncate.c:236:
+						    (sb, UDF_FLAG_STRICT)
+						    || UDF_SB_UDFREV(sb) >=

CHECK:SPACING: No space is necessary after a cast
#11225: FILE: fs/udf/truncate.c:236:
+						    || UDF_SB_UDFREV(sb) >=

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'epos.bh->b_data'
#11228: FILE: fs/udf/truncate.c:239:
+							udf_update_tag(epos.bh->
+								       b_data,

CHECK:SPACING: space preferred before that '+' (ctx:ExE)
#11230: FILE: fs/udf/truncate.c:241:
+								       +
 								       ^

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'epos.bh->b_data'
#11238: FILE: fs/udf/truncate.c:247:
+							udf_update_tag(epos.bh->
+								       b_data,

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'sb->s_blocksize_bits'
#11259: FILE: fs/udf/truncate.c:265:
+							    1) >> sb->
+					    s_blocksize_bits;

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#11302: FILE: fs/udf/truncate.c:289:
+				if (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT)
+				    || UDF_SB_UDFREV(sb) >= 0x0201)

CHECK:SPACING: No space is necessary after a cast
#11302: FILE: fs/udf/truncate.c:289:
+				    || UDF_SB_UDFREV(sb) >= 0x0201)

ERROR:OPEN_BRACE: that open brace { should be on the previous line
#11331: FILE: fs/udf/truncate.c:310:
+			if ((!epos.bh
+			     && epos.offset ==
+			     udf_file_entry_alloc_offset(inode)) || (epos.bh
+								     && epos.
+								     offset ==
+								     sizeof
+								     (struct
+								      allocExtDesc)))
+			{

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#11332: FILE: fs/udf/truncate.c:311:
+			if ((!epos.bh
+			     && epos.offset ==

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#11334: FILE: fs/udf/truncate.c:313:
+			     udf_file_entry_alloc_offset(inode)) || (epos.bh
+								     && epos.

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'epos.offset'
#11335: FILE: fs/udf/truncate.c:314:
+								     && epos.
+								     offset ==

WARNING:MULTILINE_DEREFERENCE: Avoid multiple line dereference - prefer 'inode->i_size'
#11361: FILE: fs/udf/truncate.c:335:
+					((inode->
+					  i_size & (sb->s_blocksize - 1)) !=

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#11435: FILE: fs/udf/udfdecl.h:72:
+	uint8_t u_name[UDF_NAME_LEN - 2];

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11450: FILE: fs/udf/udfdecl.h:87:
+extern int udf_write_fi(struct inode *inode, struct fileIdentDesc *,

Function prototypes don't need to be declared extern in .h
files.  It's assumed by the compiler and is unnecessary.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct fileIdentDesc *' should also have an identifier name
#11450: FILE: fs/udf/udfdecl.h:87:
+extern int udf_write_fi(struct inode *inode, struct fileIdentDesc *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct fileIdentDesc *' should also have an identifier name
#11450: FILE: fs/udf/udfdecl.h:87:
+extern int udf_write_fi(struct inode *inode, struct fileIdentDesc *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct udf_fileident_bh *' should also have an identifier name
#11450: FILE: fs/udf/udfdecl.h:87:
+extern int udf_write_fi(struct inode *inode, struct fileIdentDesc *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint8_t *' should also have an identifier name
#11450: FILE: fs/udf/udfdecl.h:87:
+extern int udf_write_fi(struct inode *inode, struct fileIdentDesc *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint8_t *' should also have an identifier name
#11450: FILE: fs/udf/udfdecl.h:87:
+extern int udf_write_fi(struct inode *inode, struct fileIdentDesc *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11456: FILE: fs/udf/udfdecl.h:92:
+extern int udf_ioctl(struct inode *, struct file *, unsigned int,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11456: FILE: fs/udf/udfdecl.h:92:
+extern int udf_ioctl(struct inode *, struct file *, unsigned int,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct file *' should also have an identifier name
#11456: FILE: fs/udf/udfdecl.h:92:
+extern int udf_ioctl(struct inode *, struct file *, unsigned int,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'unsigned int' should also have an identifier name
#11456: FILE: fs/udf/udfdecl.h:92:
+extern int udf_ioctl(struct inode *, struct file *, unsigned int,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'unsigned long' should also have an identifier name
#11456: FILE: fs/udf/udfdecl.h:92:
+extern int udf_ioctl(struct inode *, struct file *, unsigned int,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11465: FILE: fs/udf/udfdecl.h:99:
+extern struct buffer_head *udf_expand_dir_adinicb(struct inode *, int *, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11465: FILE: fs/udf/udfdecl.h:99:
+extern struct buffer_head *udf_expand_dir_adinicb(struct inode *, int *, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int *' should also have an identifier name
#11465: FILE: fs/udf/udfdecl.h:99:
+extern struct buffer_head *udf_expand_dir_adinicb(struct inode *, int *, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int *' should also have an identifier name
#11465: FILE: fs/udf/udfdecl.h:99:
+extern struct buffer_head *udf_expand_dir_adinicb(struct inode *, int *, int *);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11466: FILE: fs/udf/udfdecl.h:100:
+extern struct buffer_head *udf_bread(struct inode *, int, int, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11466: FILE: fs/udf/udfdecl.h:100:
+extern struct buffer_head *udf_bread(struct inode *, int, int, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11466: FILE: fs/udf/udfdecl.h:100:
+extern struct buffer_head *udf_bread(struct inode *, int, int, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11466: FILE: fs/udf/udfdecl.h:100:
+extern struct buffer_head *udf_bread(struct inode *, int, int, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int *' should also have an identifier name
#11466: FILE: fs/udf/udfdecl.h:100:
+extern struct buffer_head *udf_bread(struct inode *, int, int, int *);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11481: FILE: fs/udf/udfdecl.h:108:
+extern int udf_extend_file(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11481: FILE: fs/udf/udfdecl.h:108:
+extern int udf_extend_file(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position *' should also have an identifier name
#11481: FILE: fs/udf/udfdecl.h:108:
+extern int udf_extend_file(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_long_ad *' should also have an identifier name
#11481: FILE: fs/udf/udfdecl.h:108:
+extern int udf_extend_file(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'sector_t' should also have an identifier name
#11481: FILE: fs/udf/udfdecl.h:108:
+extern int udf_extend_file(struct inode *, struct extent_position *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11483: FILE: fs/udf/udfdecl.h:110:
+extern int8_t inode_bmap(struct inode *, sector_t, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11483: FILE: fs/udf/udfdecl.h:110:
+extern int8_t inode_bmap(struct inode *, sector_t, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'sector_t' should also have an identifier name
#11483: FILE: fs/udf/udfdecl.h:110:
+extern int8_t inode_bmap(struct inode *, sector_t, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position *' should also have an identifier name
#11483: FILE: fs/udf/udfdecl.h:110:
+extern int8_t inode_bmap(struct inode *, sector_t, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr *' should also have an identifier name
#11483: FILE: fs/udf/udfdecl.h:110:
+extern int8_t inode_bmap(struct inode *, sector_t, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t *' should also have an identifier name
#11483: FILE: fs/udf/udfdecl.h:110:
+extern int8_t inode_bmap(struct inode *, sector_t, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'sector_t *' should also have an identifier name
#11483: FILE: fs/udf/udfdecl.h:110:
+extern int8_t inode_bmap(struct inode *, sector_t, struct extent_position *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11485: FILE: fs/udf/udfdecl.h:112:
+extern int8_t udf_add_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11485: FILE: fs/udf/udfdecl.h:112:
+extern int8_t udf_add_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position *' should also have an identifier name
#11485: FILE: fs/udf/udfdecl.h:112:
+extern int8_t udf_add_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr' should also have an identifier name
#11485: FILE: fs/udf/udfdecl.h:112:
+extern int8_t udf_add_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11485: FILE: fs/udf/udfdecl.h:112:
+extern int8_t udf_add_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11485: FILE: fs/udf/udfdecl.h:112:
+extern int8_t udf_add_aext(struct inode *, struct extent_position *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11487: FILE: fs/udf/udfdecl.h:114:
+extern int8_t udf_write_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11487: FILE: fs/udf/udfdecl.h:114:
+extern int8_t udf_write_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position *' should also have an identifier name
#11487: FILE: fs/udf/udfdecl.h:114:
+extern int8_t udf_write_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr' should also have an identifier name
#11487: FILE: fs/udf/udfdecl.h:114:
+extern int8_t udf_write_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11487: FILE: fs/udf/udfdecl.h:114:
+extern int8_t udf_write_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11487: FILE: fs/udf/udfdecl.h:114:
+extern int8_t udf_write_aext(struct inode *, struct extent_position *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11489: FILE: fs/udf/udfdecl.h:116:
+extern int8_t udf_delete_aext(struct inode *, struct extent_position,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11489: FILE: fs/udf/udfdecl.h:116:
+extern int8_t udf_delete_aext(struct inode *, struct extent_position,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position' should also have an identifier name
#11489: FILE: fs/udf/udfdecl.h:116:
+extern int8_t udf_delete_aext(struct inode *, struct extent_position,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr' should also have an identifier name
#11489: FILE: fs/udf/udfdecl.h:116:
+extern int8_t udf_delete_aext(struct inode *, struct extent_position,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11489: FILE: fs/udf/udfdecl.h:116:
+extern int8_t udf_delete_aext(struct inode *, struct extent_position,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11491: FILE: fs/udf/udfdecl.h:118:
+extern int8_t udf_next_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11491: FILE: fs/udf/udfdecl.h:118:
+extern int8_t udf_next_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position *' should also have an identifier name
#11491: FILE: fs/udf/udfdecl.h:118:
+extern int8_t udf_next_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr *' should also have an identifier name
#11491: FILE: fs/udf/udfdecl.h:118:
+extern int8_t udf_next_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t *' should also have an identifier name
#11491: FILE: fs/udf/udfdecl.h:118:
+extern int8_t udf_next_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11491: FILE: fs/udf/udfdecl.h:118:
+extern int8_t udf_next_aext(struct inode *, struct extent_position *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11493: FILE: fs/udf/udfdecl.h:120:
+extern int8_t udf_current_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11493: FILE: fs/udf/udfdecl.h:120:
+extern int8_t udf_current_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position *' should also have an identifier name
#11493: FILE: fs/udf/udfdecl.h:120:
+extern int8_t udf_current_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr *' should also have an identifier name
#11493: FILE: fs/udf/udfdecl.h:120:
+extern int8_t udf_current_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t *' should also have an identifier name
#11493: FILE: fs/udf/udfdecl.h:120:
+extern int8_t udf_current_aext(struct inode *, struct extent_position *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11493: FILE: fs/udf/udfdecl.h:120:
+extern int8_t udf_current_aext(struct inode *, struct extent_position *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11503: FILE: fs/udf/udfdecl.h:126:
+extern struct genericFormat *udf_add_extendedattr(struct inode *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11503: FILE: fs/udf/udfdecl.h:126:
+extern struct genericFormat *udf_add_extendedattr(struct inode *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11503: FILE: fs/udf/udfdecl.h:126:
+extern struct genericFormat *udf_add_extendedattr(struct inode *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11503: FILE: fs/udf/udfdecl.h:126:
+extern struct genericFormat *udf_add_extendedattr(struct inode *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint8_t' should also have an identifier name
#11503: FILE: fs/udf/udfdecl.h:126:
+extern struct genericFormat *udf_add_extendedattr(struct inode *, uint32_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11505: FILE: fs/udf/udfdecl.h:128:
+extern struct genericFormat *udf_get_extendedattr(struct inode *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11505: FILE: fs/udf/udfdecl.h:128:
+extern struct genericFormat *udf_get_extendedattr(struct inode *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11505: FILE: fs/udf/udfdecl.h:128:
+extern struct genericFormat *udf_get_extendedattr(struct inode *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint8_t' should also have an identifier name
#11505: FILE: fs/udf/udfdecl.h:128:
+extern struct genericFormat *udf_get_extendedattr(struct inode *, uint32_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11507: FILE: fs/udf/udfdecl.h:130:
+extern struct buffer_head *udf_read_tagged(struct super_block *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11507: FILE: fs/udf/udfdecl.h:130:
+extern struct buffer_head *udf_read_tagged(struct super_block *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11507: FILE: fs/udf/udfdecl.h:130:
+extern struct buffer_head *udf_read_tagged(struct super_block *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11507: FILE: fs/udf/udfdecl.h:130:
+extern struct buffer_head *udf_read_tagged(struct super_block *, uint32_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t *' should also have an identifier name
#11507: FILE: fs/udf/udfdecl.h:130:
+extern struct buffer_head *udf_read_tagged(struct super_block *, uint32_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11509: FILE: fs/udf/udfdecl.h:132:
+extern struct buffer_head *udf_read_ptagged(struct super_block *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11509: FILE: fs/udf/udfdecl.h:132:
+extern struct buffer_head *udf_read_ptagged(struct super_block *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr' should also have an identifier name
#11509: FILE: fs/udf/udfdecl.h:132:
+extern struct buffer_head *udf_read_ptagged(struct super_block *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11509: FILE: fs/udf/udfdecl.h:132:
+extern struct buffer_head *udf_read_ptagged(struct super_block *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t *' should also have an identifier name
#11509: FILE: fs/udf/udfdecl.h:132:
+extern struct buffer_head *udf_read_ptagged(struct super_block *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11523: FILE: fs/udf/udfdecl.h:143:
+extern uint32_t udf_get_pblock(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11523: FILE: fs/udf/udfdecl.h:143:
+extern uint32_t udf_get_pblock(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11523: FILE: fs/udf/udfdecl.h:143:
+extern uint32_t udf_get_pblock(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t' should also have an identifier name
#11523: FILE: fs/udf/udfdecl.h:143:
+extern uint32_t udf_get_pblock(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11523: FILE: fs/udf/udfdecl.h:143:
+extern uint32_t udf_get_pblock(struct super_block *, uint32_t, uint16_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11525: FILE: fs/udf/udfdecl.h:145:
+extern uint32_t udf_get_pblock_virt15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11525: FILE: fs/udf/udfdecl.h:145:
+extern uint32_t udf_get_pblock_virt15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11525: FILE: fs/udf/udfdecl.h:145:
+extern uint32_t udf_get_pblock_virt15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t' should also have an identifier name
#11525: FILE: fs/udf/udfdecl.h:145:
+extern uint32_t udf_get_pblock_virt15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11525: FILE: fs/udf/udfdecl.h:145:
+extern uint32_t udf_get_pblock_virt15(struct super_block *, uint32_t, uint16_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11527: FILE: fs/udf/udfdecl.h:147:
+extern uint32_t udf_get_pblock_virt20(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11527: FILE: fs/udf/udfdecl.h:147:
+extern uint32_t udf_get_pblock_virt20(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11527: FILE: fs/udf/udfdecl.h:147:
+extern uint32_t udf_get_pblock_virt20(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t' should also have an identifier name
#11527: FILE: fs/udf/udfdecl.h:147:
+extern uint32_t udf_get_pblock_virt20(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11527: FILE: fs/udf/udfdecl.h:147:
+extern uint32_t udf_get_pblock_virt20(struct super_block *, uint32_t, uint16_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11529: FILE: fs/udf/udfdecl.h:149:
+extern uint32_t udf_get_pblock_spar15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11529: FILE: fs/udf/udfdecl.h:149:
+extern uint32_t udf_get_pblock_spar15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11529: FILE: fs/udf/udfdecl.h:149:
+extern uint32_t udf_get_pblock_spar15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t' should also have an identifier name
#11529: FILE: fs/udf/udfdecl.h:149:
+extern uint32_t udf_get_pblock_spar15(struct super_block *, uint32_t, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11529: FILE: fs/udf/udfdecl.h:149:
+extern uint32_t udf_get_pblock_spar15(struct super_block *, uint32_t, uint16_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11536: FILE: fs/udf/udfdecl.h:155:
+extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11536: FILE: fs/udf/udfdecl.h:155:
+extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'const uint8_t *' should also have an identifier name
#11536: FILE: fs/udf/udfdecl.h:155:
+extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint8_t *' should also have an identifier name
#11536: FILE: fs/udf/udfdecl.h:155:
+extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11536: FILE: fs/udf/udfdecl.h:155:
+extern int udf_put_filename(struct super_block *, const uint8_t *, uint8_t *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11544: FILE: fs/udf/udfdecl.h:162:
+extern struct inode *udf_new_inode(struct inode *, int, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11544: FILE: fs/udf/udfdecl.h:162:
+extern struct inode *udf_new_inode(struct inode *, int, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11544: FILE: fs/udf/udfdecl.h:162:
+extern struct inode *udf_new_inode(struct inode *, int, int *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int *' should also have an identifier name
#11544: FILE: fs/udf/udfdecl.h:162:
+extern struct inode *udf_new_inode(struct inode *, int, int *);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11555: FILE: fs/udf/udfdecl.h:170:
+extern void udf_free_blocks(struct super_block *, struct inode *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11555: FILE: fs/udf/udfdecl.h:170:
+extern void udf_free_blocks(struct super_block *, struct inode *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11555: FILE: fs/udf/udfdecl.h:170:
+extern void udf_free_blocks(struct super_block *, struct inode *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr' should also have an identifier name
#11555: FILE: fs/udf/udfdecl.h:170:
+extern void udf_free_blocks(struct super_block *, struct inode *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11555: FILE: fs/udf/udfdecl.h:170:
+extern void udf_free_blocks(struct super_block *, struct inode *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11555: FILE: fs/udf/udfdecl.h:170:
+extern void udf_free_blocks(struct super_block *, struct inode *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11557: FILE: fs/udf/udfdecl.h:172:
+extern int udf_prealloc_blocks(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11557: FILE: fs/udf/udfdecl.h:172:
+extern int udf_prealloc_blocks(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11557: FILE: fs/udf/udfdecl.h:172:
+extern int udf_prealloc_blocks(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t' should also have an identifier name
#11557: FILE: fs/udf/udfdecl.h:172:
+extern int udf_prealloc_blocks(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11557: FILE: fs/udf/udfdecl.h:172:
+extern int udf_prealloc_blocks(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11557: FILE: fs/udf/udfdecl.h:172:
+extern int udf_prealloc_blocks(struct super_block *, struct inode *, uint16_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11559: FILE: fs/udf/udfdecl.h:174:
+extern int udf_new_block(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct super_block *' should also have an identifier name
#11559: FILE: fs/udf/udfdecl.h:174:
+extern int udf_new_block(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11559: FILE: fs/udf/udfdecl.h:174:
+extern int udf_new_block(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint16_t' should also have an identifier name
#11559: FILE: fs/udf/udfdecl.h:174:
+extern int udf_new_block(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t' should also have an identifier name
#11559: FILE: fs/udf/udfdecl.h:174:
+extern int udf_new_block(struct super_block *, struct inode *, uint16_t,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int *' should also have an identifier name
#11559: FILE: fs/udf/udfdecl.h:174:
+extern int udf_new_block(struct super_block *, struct inode *, uint16_t,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct inode *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'loff_t *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct udf_fileident_bh *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct fileIdentDesc *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct extent_position *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'kernel_lb_addr *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint32_t *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'sector_t *' should also have an identifier name
#11570: FILE: fs/udf/udfdecl.h:181:
+extern struct fileIdentDesc *udf_fileident_read(struct inode *, loff_t *,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11576: FILE: fs/udf/udfdecl.h:187:
+extern struct fileIdentDesc *udf_get_fileident(void *buffer, int bufsize,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11578: FILE: fs/udf/udfdecl.h:189:
+extern long_ad *udf_get_filelongad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint8_t *' should also have an identifier name
#11578: FILE: fs/udf/udfdecl.h:189:
+extern long_ad *udf_get_filelongad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11578: FILE: fs/udf/udfdecl.h:189:
+extern long_ad *udf_get_filelongad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int *' should also have an identifier name
#11578: FILE: fs/udf/udfdecl.h:189:
+extern long_ad *udf_get_filelongad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11578: FILE: fs/udf/udfdecl.h:189:
+extern long_ad *udf_get_filelongad(uint8_t *, int, int *, int);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#11579: FILE: fs/udf/udfdecl.h:190:
+extern short_ad *udf_get_fileshortad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'uint8_t *' should also have an identifier name
#11579: FILE: fs/udf/udfdecl.h:190:
+extern short_ad *udf_get_fileshortad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11579: FILE: fs/udf/udfdecl.h:190:
+extern short_ad *udf_get_fileshortad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int *' should also have an identifier name
#11579: FILE: fs/udf/udfdecl.h:190:
+extern short_ad *udf_get_fileshortad(uint8_t *, int, int *, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#11579: FILE: fs/udf/udfdecl.h:190:
+extern short_ad *udf_get_fileshortad(uint8_t *, int, int *, int);

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#11670: FILE: fs/udf/udftime.c:86:
+time_t *udf_stamp_to_time(time_t * dest, long *dest_usec, kernel_timestamp src)

CHECK:BRACES: Unbalanced braces around else statement
#11687: FILE: fs/udf/udftime.c:98:
+	} else

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#11717: FILE: fs/udf/udftime.c:119:
+kernel_timestamp *udf_time_to_stamp(kernel_timestamp * dest, struct timespec ts)

WARNING:UNNECESSARY_INT: Prefer 'long' over 'long int' as the int is unnecessary
#11741: FILE: fs/udf/udftime.c:154:
+	for (y = 11; days < (long int)ip[y]; --y)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#11768: FILE: fs/udf/unicode.c:32:
+static int udf_char_to_ustr(struct ustr *dest, const uint8_t * src, int strlen)

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!dest'
#11771: FILE: fs/udf/unicode.c:34:
+	if ((!dest) || (!src) || (!strlen) || (strlen > UDF_NAME_LEN - 2))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!src'
#11771: FILE: fs/udf/unicode.c:34:
+	if ((!dest) || (!src) || (!strlen) || (strlen > UDF_NAME_LEN - 2))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!strlen'
#11771: FILE: fs/udf/unicode.c:34:
+	if ((!dest) || (!src) || (!strlen) || (strlen > UDF_NAME_LEN - 2))

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#11780: FILE: fs/udf/unicode.c:46:
+int udf_build_ustr(struct ustr *dest, dstring * ptr, int size)

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!dest'
#11785: FILE: fs/udf/unicode.c:50:
+	if ((!dest) || (!ptr) || (!size))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!ptr'
#11785: FILE: fs/udf/unicode.c:50:
+	if ((!dest) || (!ptr) || (!size))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!size'
#11785: FILE: fs/udf/unicode.c:50:
+	if ((!dest) || (!ptr) || (!size))

CHECK:CAMELCASE: Avoid CamelCase: <u_cmpID>
#11794: FILE: fs/udf/unicode.c:55:
+	dest->u_cmpID = ptr[0];

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#11804: FILE: fs/udf/unicode.c:64:
+static int udf_build_ustr_exact(struct ustr *dest, dstring * ptr, int exactsize)

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!dest'
#11807: FILE: fs/udf/unicode.c:66:
+	if ((!dest) || (!ptr) || (!exactsize))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!ptr'
#11807: FILE: fs/udf/unicode.c:66:
+	if ((!dest) || (!ptr) || (!exactsize))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around '!exactsize'
#11807: FILE: fs/udf/unicode.c:66:
+	if ((!dest) || (!ptr) || (!exactsize))

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'cmp_id != 8'
#11836: FILE: fs/udf/unicode.c:118:
+	if ((cmp_id != 8) && (cmp_id != 16)) {

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'cmp_id != 16'
#11836: FILE: fs/udf/unicode.c:118:
+	if ((cmp_id != 8) && (cmp_id != 16)) {

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#11837: FILE: fs/udf/unicode.c:119:
+		printk(KERN_ERR "udf: unknown compression code (%d) stri=%s\n",

CHECK:SPACING: No space is necessary after a cast
#11863: FILE: fs/udf/unicode.c:133:
+			utf_o->u_name[utf_o->u_len++] = (uint8_t) c;

CHECK:SPACING: No space is necessary after a cast
#11866: FILE: fs/udf/unicode.c:136:
+			    (uint8_t) (0xc0 | (c >> 6));

CHECK:SPACING: No space is necessary after a cast
#11868: FILE: fs/udf/unicode.c:138:
+			    (uint8_t) (0x80 | (c & 0x3f));

CHECK:SPACING: No space is necessary after a cast
#11871: FILE: fs/udf/unicode.c:141:
+			    (uint8_t) (0xe0 | (c >> 12));

CHECK:SPACING: No space is necessary after a cast
#11873: FILE: fs/udf/unicode.c:143:
+			    (uint8_t) (0x80 | ((c >> 6) & 0x3f));

CHECK:SPACING: No space is necessary after a cast
#11875: FILE: fs/udf/unicode.c:145:
+			    (uint8_t) (0x80 | (c & 0x3f));

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#11888: FILE: fs/udf/unicode.c:176:
+static int udf_UTF8toCS0(dstring * ocu, struct ustr *utf, int length)

CHECK:CAMELCASE: Avoid CamelCase: <udf_UTF8toCS0>
#11888: FILE: fs/udf/unicode.c:176:
+static int udf_UTF8toCS0(dstring * ocu, struct ustr *utf, int length)

WARNING:INDENTED_LABEL: labels should not be indented
#11897: FILE: fs/udf/unicode.c:185:
+      try_again:

CHECK:SPACING: No space is necessary after a cast
#11905: FILE: fs/udf/unicode.c:190:
+		c = (uint8_t) utf->u_name[i];

CHECK:BRACES: braces {} should be used on all arms of this statement
#11925: FILE: fs/udf/unicode.c:201:
+				if ((c & 0xe0U) == 0xc0U) {
[...]
-				}
[...]
+				} else if ((c & 0xf0U) == 0xe0U) {
[...]
-				}
[...]
+				} else if ((c & 0xf8U) == 0xf0U) {
[...]
-				}
[...]

CHECK:BRACES: Unbalanced braces around else statement
#11954: FILE: fs/udf/unicode.c:216:
+				} else

WARNING:CONSTANT_COMPARISON: Comparisons should place the constant on the right side of the test
#11967: FILE: fs/udf/unicode.c:226:
+			if (0xffU == max_val) {

Comparisons with a constant or upper case identifier on the left
side of the test should be avoided.

CHECK:SPACING: No space is necessary after a cast
#11970: FILE: fs/udf/unicode.c:228:
+				ocu[0] = (uint8_t) 0x10U;

WARNING:BRACES: braces {} are not necessary for single statement blocks
#11979: FILE: fs/udf/unicode.c:234:
+		if (max_val == 0xffffU) {
+			ocu[++u_len] = (uint8_t) (utf_char >> 8);
 		}

CHECK:SPACING: No space is necessary after a cast
#11980: FILE: fs/udf/unicode.c:235:
+			ocu[++u_len] = (uint8_t) (utf_char >> 8);

CHECK:SPACING: No space is necessary after a cast
#11983: FILE: fs/udf/unicode.c:237:
+		ocu[++u_len] = (uint8_t) (utf_char & 0xffU);

WARNING:INDENTED_LABEL: labels should not be indented
#11991: FILE: fs/udf/unicode.c:241:
+	      error_out:

CHECK:SPACING: No space is necessary after a cast
#11997: FILE: fs/udf/unicode.c:246:
+	ocu[length - 1] = (uint8_t) u_len + 1;

CHECK:CAMELCASE: Avoid CamelCase: <udf_CS0toNLS>
#12002: FILE: fs/udf/unicode.c:250:
+static int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'cmp_id != 8'
#12023: FILE: fs/udf/unicode.c:271:
+	if ((cmp_id != 8) && (cmp_id != 16)) {

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'cmp_id != 16'
#12023: FILE: fs/udf/unicode.c:271:
+	if ((cmp_id != 8) && (cmp_id != 16)) {

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#12024: FILE: fs/udf/unicode.c:272:
+		printk(KERN_ERR "udf: unknown compression code (%d) stri=%s\n",

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12049: FILE: fs/udf/unicode.c:291:
+static int udf_NLStoCS0(struct nls_table *nls, dstring * ocu, struct ustr *uni,

CHECK:CAMELCASE: Avoid CamelCase: <udf_NLStoCS0>
#12049: FILE: fs/udf/unicode.c:291:
+static int udf_NLStoCS0(struct nls_table *nls, dstring * ocu, struct ustr *uni,

WARNING:INDENTED_LABEL: labels should not be indented
#12059: FILE: fs/udf/unicode.c:302:
+      try_again:

CHECK:SPACING: No space is necessary after a cast
#12074: FILE: fs/udf/unicode.c:311:
+			ocu[0] = (uint8_t) 0x10U;

CHECK:SPACING: No space is necessary after a cast
#12082: FILE: fs/udf/unicode.c:316:
+			ocu[++u_len] = (uint8_t) (uni_char >> 8);

CHECK:SPACING: No space is necessary after a cast
#12083: FILE: fs/udf/unicode.c:317:
+		ocu[++u_len] = (uint8_t) (uni_char & 0xffU);

CHECK:SPACING: No space is necessary after a cast
#12088: FILE: fs/udf/unicode.c:321:
+	ocu[length - 1] = (uint8_t) u_len + 1;

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12093: FILE: fs/udf/unicode.c:325:
+int udf_get_filename(struct super_block *sb, uint8_t * sname, uint8_t * dname,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12093: FILE: fs/udf/unicode.c:325:
+int udf_get_filename(struct super_block *sb, uint8_t * sname, uint8_t * dname,

WARNING:BRACES: braces {} are not necessary for single statement blocks
#12101: FILE: fs/udf/unicode.c:331:
+	if (udf_build_ustr_exact(&unifilename, sname, flen)) {
 		return 0;
 	}

CHECK:BRACES: braces {} should be used on all arms of this statement
#12110: FILE: fs/udf/unicode.c:335:
+	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
[...]
-	}
[...]
+		if (!udf_CS0toNLS
[...]

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'udf_get_filename', this function's name, in a string
#12112: FILE: fs/udf/unicode.c:337:
+			udf_debug("Failed in udf_get_filename: sname = %s\n",

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'udf_get_filename', this function's name, in a string
#12125: FILE: fs/udf/unicode.c:344:
+			udf_debug("Failed in udf_get_filename: sname = %s\n",

CHECK:BRACES: Unbalanced braces around else statement
#12131: FILE: fs/udf/unicode.c:348:
+	} else

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#12137: FILE: fs/udf/unicode.c:351:
+	if ((len =

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12146: FILE: fs/udf/unicode.c:359:
+int udf_put_filename(struct super_block *sb, const uint8_t * sname,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12147: FILE: fs/udf/unicode.c:360:
+		     uint8_t * dname, int flen)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#12147: FILE: fs/udf/unicode.c:360:
+		     uint8_t * dname, int flen)

WARNING:BRACES: braces {} are not necessary for single statement blocks
#12154: FILE: fs/udf/unicode.c:365:
+	if (!(udf_char_to_ustr(&unifilename, sname, flen))) {
 		return 0;
 	}

CHECK:BRACES: braces {} should be used on all arms of this statement
#12162: FILE: fs/udf/unicode.c:369:
+	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
[...]
-	}
[...]
+		    (namelen =
[...]

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#12163: FILE: fs/udf/unicode.c:370:
+		if (!

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#12174: FILE: fs/udf/unicode.c:376:
+		if (!

CHECK:BRACES: Unbalanced braces around else statement
#12182: FILE: fs/udf/unicode.c:382:
+	} else

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12191: FILE: fs/udf/unicode.c:393:
+static int udf_translate_to_linux(uint8_t * newName, uint8_t * udfName,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12191: FILE: fs/udf/unicode.c:393:
+static int udf_translate_to_linux(uint8_t * newName, uint8_t * udfName,

CHECK:CAMELCASE: Avoid CamelCase: <newName>
#12191: FILE: fs/udf/unicode.c:393:
+static int udf_translate_to_linux(uint8_t * newName, uint8_t * udfName,

CHECK:CAMELCASE: Avoid CamelCase: <udfName>
#12191: FILE: fs/udf/unicode.c:393:
+static int udf_translate_to_linux(uint8_t * newName, uint8_t * udfName,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#12191: FILE: fs/udf/unicode.c:393:
+static int udf_translate_to_linux(uint8_t * newName, uint8_t * udfName,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#12192: FILE: fs/udf/unicode.c:394:
+				  int udfLen, uint8_t * fidName, int fidNameLen)

CHECK:CAMELCASE: Avoid CamelCase: <udfLen>
#12192: FILE: fs/udf/unicode.c:394:
+				  int udfLen, uint8_t * fidName, int fidNameLen)

CHECK:CAMELCASE: Avoid CamelCase: <fidName>
#12192: FILE: fs/udf/unicode.c:394:
+				  int udfLen, uint8_t * fidName, int fidNameLen)

CHECK:CAMELCASE: Avoid CamelCase: <fidNameLen>
#12192: FILE: fs/udf/unicode.c:394:
+				  int udfLen, uint8_t * fidName, int fidNameLen)

CHECK:CAMELCASE: Avoid CamelCase: <newIndex>
#12195: FILE: fs/udf/unicode.c:396:
+	int index, newIndex = 0, needsCRC = 0;

CHECK:CAMELCASE: Avoid CamelCase: <needsCRC>
#12195: FILE: fs/udf/unicode.c:396:
+	int index, newIndex = 0, needsCRC = 0;

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#12224: FILE: fs/udf/unicode.c:414:
+				while (index + 1 < udfLen
+				       && (udfName[index + 1] == '/'

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#12225: FILE: fs/udf/unicode.c:415:
+				       && (udfName[index + 1] == '/'
+					   || udfName[index + 1] == 0))

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#12231: FILE: fs/udf/unicode.c:419:
+			if (curr == EXT_MARK
+			    && (udfLen - index - 1) <= EXT_SIZE) {

CHECK:BRACES: Unbalanced braces around else statement
#12236: FILE: fs/udf/unicode.c:422:
+				else {

CHECK:CAMELCASE: Avoid CamelCase: <hasExt>
#12252: FILE: fs/udf/unicode.c:438:
+		if (hasExt) {

CHECK:CAMELCASE: Avoid CamelCase: <extIndex>
#12258: FILE: fs/udf/unicode.c:441:
+			     index < EXT_SIZE && extIndex + index + 1 < udfLen;

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#12271: FILE: fs/udf/unicode.c:449:
+					while (extIndex + index + 2 < udfLen
+					       && (index + 1 < EXT_SIZE

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#12272: FILE: fs/udf/unicode.c:450:
+					       && (index + 1 < EXT_SIZE
+						   &&

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#12276: FILE: fs/udf/unicode.c:454:
+						    '/'
+						    || udfName[extIndex +

CHECK:CAMELCASE: Avoid CamelCase: <localExtIndex>
#12301: FILE: fs/udf/unicode.c:477:
+			for (index = 0; index < localExtIndex; index++)

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000425781.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 102 errors, 381 warnings, 744 checks, 11847 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000425781.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
