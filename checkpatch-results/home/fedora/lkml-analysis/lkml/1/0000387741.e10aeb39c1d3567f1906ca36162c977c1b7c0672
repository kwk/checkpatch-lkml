WARNING:COMMIT_MESSAGE: Missing commit description - Add an appropriate one

The patch is missing a commit description.  A brief
description of the changes made by the patch should be added.

See: https://www.kernel.org/doc/html/latest/process/submitting-patches.html#describe-your-changes

WARNING:TYPO_SPELLING: 'acessing' may be misspelled - perhaps 'accessing'?
#81: FILE: Documentation/vm_pps.txt:28:
+1) SwapDaemon can collect the statistic of process acessing pages and by it
                                                    ^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

WARNING:TYPO_SPELLING: 'outputed' may be misspelled - perhaps 'outputted'?
#242: FILE: Documentation/vm_pps.txt:189:
+outputed to /proc/zoneinfo in mm/vmstat.c.
 ^^^^^^^^

WARNING:TYPO_SPELLING: 'scaning' may be misspelled - perhaps 'scanning'?
#247: FILE: Documentation/vm_pps.txt:194:
+mm_struct instances, during the process of scaning and reclamation, it
                                            ^^^^^^^

WARNING:TYPO_SPELLING: 'dealed' may be misspelled - perhaps 'dealt'?
#301: FILE: Documentation/vm_pps.txt:248:
+4) madvise API-flag can be dealed here.
                            ^^^^^^

WARNING:TYPO_SPELLING: 'ins't' may be misspelled - perhaps 'isn't'?
#349: FILE: Documentation/vm_pps.txt:296:
+*) In fact, it ins't exactly a ppspage, see <Data Definition>.
                ^^^^^

WARNING:TYPO_SPELLING: 'ins't' may be misspelled - perhaps 'isn't'?
#357: FILE: Documentation/vm_pps.txt:304:
+*) In fact, it ins't exactly a ppspage, see <Data Definition>.
                ^^^^^

WARNING:TYPO_SPELLING: 'contruction' may be misspelled - perhaps 'construction'?
#360: FILE: Documentation/vm_pps.txt:307:
+pps_page_(contruction/destruction) in memory.c. They're used to shift different
           ^^^^^^^^^^^

WARNING:TYPO_SPELLING: 'cann't' may be misspelled - perhaps 'can't'?
#399: FILE: Documentation/vm_pps.txt:346:
+   into two genres, one called 'nail' represents their swap entries cann't be
                                                                     ^^^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#434: FILE: fs/exec.c:332:
+	set_pte_at(mm, address, pte, pte_mkdirty(pte_mkwrite(mk_pte(page,
+			    vma->vm_page_prot))));

ERROR:SPACING: space prohibited before that close parenthesis ')'
#465: FILE: include/asm-i386/pgtable-2level.h:82:
+	((((pte).pte_low >> 1) & 0xf ) + (((pte).pte_low >> 8) << 4 ))

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:CORRUPTED_PATCH: patch seems to be corrupt (line wrapped?)
#476: FILE: include/asm-i386/pgtable-2level.h:89:
((offset) << 8) })

The patch seems to be corrupted or lines are wrapped.
Please regenerate the patch file before sending it to the maintainer.

WARNING:BLOCK_COMMENT_STYLE: Block comments use * on subsequent lines
#493: FILE: include/asm-i386/pgtable.h:124:
+#define _PAGE_UNMAPPED	0x020	/* a special PTE type, hold its page reference
+				   even it's unmapped, see more from

The comment style is incorrect.  The preferred style for multi-
line comments is::

  /*
  * This is the preferred style
  * for multi line comments.
  */

The networking comment style is a bit different, with the first line
not empty like the former::

  /* This is the preferred comment style
  * for files in net/ and drivers/net/
  */

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#commenting

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#494: FILE: include/asm-i386/pgtable.h:125:
+				   Documentation/vm_pps.txt. */

ERROR:OPEN_BRACE: open brace '{' following function definitions go on the next line
#505: FILE: include/asm-i386/pgtable.h:235:
+static inline int pte_unmapped(pte_t pte)	{ return ((pte).pte_low & 0x60)

The opening brace should be following the function definitions on the
next line.  For any non-functional block it should be on the same line
as the last construct.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#506: FILE: include/asm-i386/pgtable.h:236:
+    == _PAGE_UNMAPPED; }$

ERROR:OPEN_BRACE: open brace '{' following function definitions go on the next line
#507: FILE: include/asm-i386/pgtable.h:237:
+static inline int pte_swapped(pte_t pte)	{ return ((pte).pte_low & 0x60)

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#508: FILE: include/asm-i386/pgtable.h:238:
+    == _PAGE_SWAPPED; }$

ERROR:OPEN_BRACE: open brace '{' following function definitions go on the next line
#509: FILE: include/asm-i386/pgtable.h:239:
+static inline int pte_file(pte_t pte)		{ return ((pte).pte_low & 0x60)

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#510: FILE: include/asm-i386/pgtable.h:240:
+    == _PAGE_FILE; }$

ERROR:OPEN_BRACE: open brace '{' following function definitions go on the next line
#523: FILE: include/asm-i386/pgtable.h:253:
+static inline pte_t pte_mkunmapped(pte_t pte)	{ (pte).pte_low &=

WARNING:LONG_LINE_COMMENT: line length of 113 exceeds 100 columns
#539: FILE: include/linux/mm.h:173:
+									   see more from Documentation/vm_pps.txt

A comment starts before but extends beyond the maximum line length.
To use a different maximum line length, the --max-line-length=n option
may be added while invoking checkpatch.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#breaking-long-lines-and-strings

WARNING:BLOCK_COMMENT_STYLE: Block comments use * on subsequent lines
#539: FILE: include/linux/mm.h:173:
+#define VM_PURE_PRIVATE	0x08000000	/* Is the vma is only belonging to a mm,
+									   see more from Documentation/vm_pps.txt

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#548: FILE: include/linux/mm.h:1216:
+void enter_pps(struct mm_struct* mm, struct vm_area_struct* vma);

When using pointer data or a function that returns a pointer type,
the preferred use of * is adjacent to the data name or function name
and not adjacent to the type name.
Examples::

  char *linux_banner;
  unsigned long long memparse(char *ptr, char **retptr);
  char *match_strdup(substring_t *s);

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#548: FILE: include/linux/mm.h:1216:
+void enter_pps(struct mm_struct* mm, struct vm_area_struct* vma);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#549: FILE: include/linux/mm.h:1217:
+void leave_pps(struct vm_area_struct* vma, int migrate_flag);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#550: FILE: include/linux/mm.h:1218:
+void pps_page_construction(struct page* page, struct vm_area_struct* vma,

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#550: FILE: include/linux/mm.h:1218:
+void pps_page_construction(struct page* page, struct vm_area_struct* vma,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#551: FILE: include/linux/mm.h:1219:
+void pps_page_construction(struct page* page, struct vm_area_struct* vma,
+	unsigned long address);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#552: FILE: include/linux/mm.h:1220:
+void pps_page_destruction(struct page* ppspage, struct vm_area_struct* vma,

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#552: FILE: include/linux/mm.h:1220:
+void pps_page_destruction(struct page* ppspage, struct vm_area_struct* vma,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#553: FILE: include/linux/mm.h:1221:
+void pps_page_destruction(struct page* ppspage, struct vm_area_struct* vma,
+	unsigned long address, int migrate);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#612: FILE: include/linux/swap.h:230:
+extern int pps_relink_swp(struct page*, swp_entry_t, swp_entry_t**);

Function prototypes don't need to be declared extern in .h
files.  It's assumed by the compiler and is unnecessary.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct page*' should also have an identifier name
#612: FILE: include/linux/swap.h:230:
+extern int pps_relink_swp(struct page*, swp_entry_t, swp_entry_t**);

This warning is emitted due to any of the following reasons:

  1. Arguments for the function declaration do not follow
     the identifier name.  Example::

       void foo
       (int bar, int baz)

     This should be corrected to::

       void foo(int bar, int baz)

  2. Some arguments for the function definition do not
     have an identifier name.  Example::

       void foo(int)

     All arguments should have identifier names.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t' should also have an identifier name
#612: FILE: include/linux/swap.h:230:
+extern int pps_relink_swp(struct page*, swp_entry_t, swp_entry_t**);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t**' should also have an identifier name
#612: FILE: include/linux/swap.h:230:
+extern int pps_relink_swp(struct page*, swp_entry_t, swp_entry_t**);

ERROR:POINTER_LOCATION: "(foo*)" should be "(foo *)"
#621: FILE: include/linux/swap.h:242:
+extern void swap_free_batchly(swp_entry_t*);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#621: FILE: include/linux/swap.h:242:
+extern void swap_free_batchly(swp_entry_t*);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t*' should also have an identifier name
#621: FILE: include/linux/swap.h:242:
+extern void swap_free_batchly(swp_entry_t*);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#622: FILE: include/linux/swap.h:243:
+extern void swap_alloc_around_nail(swp_entry_t, int, swp_entry_t*);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t' should also have an identifier name
#622: FILE: include/linux/swap.h:243:
+extern void swap_alloc_around_nail(swp_entry_t, int, swp_entry_t*);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#622: FILE: include/linux/swap.h:243:
+extern void swap_alloc_around_nail(swp_entry_t, int, swp_entry_t*);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t*' should also have an identifier name
#622: FILE: include/linux/swap.h:243:
+extern void swap_alloc_around_nail(swp_entry_t, int, swp_entry_t*);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#623: FILE: include/linux/swap.h:244:
+extern int swap_try_alloc_batchly(swp_entry_t, int, swp_entry_t*);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t' should also have an identifier name
#623: FILE: include/linux/swap.h:244:
+extern int swap_try_alloc_batchly(swp_entry_t, int, swp_entry_t*);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#623: FILE: include/linux/swap.h:244:
+extern int swap_try_alloc_batchly(swp_entry_t, int, swp_entry_t*);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t*' should also have an identifier name
#623: FILE: include/linux/swap.h:244:
+extern int swap_try_alloc_batchly(swp_entry_t, int, swp_entry_t*);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#624: FILE: include/linux/swap.h:245:
+extern int swap_alloc_batchly(int, swp_entry_t*, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#624: FILE: include/linux/swap.h:245:
+extern int swap_alloc_batchly(int, swp_entry_t*, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'swp_entry_t*' should also have an identifier name
#624: FILE: include/linux/swap.h:245:
+extern int swap_alloc_batchly(int, swp_entry_t*, int);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#624: FILE: include/linux/swap.h:245:
+extern int swap_alloc_batchly(int, swp_entry_t*, int);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#638: FILE: include/linux/swapops.h:53:
+	BUG_ON(!pte_swapped(pte));

BUG() or BUG_ON() should be avoided totally.
Use WARN() and WARN_ON() instead, and handle the "impossible"
error condition as gracefully as possible.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#bug-and-bug-on

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#647: FILE: include/linux/swapops.h:67:
+	BUG_ON(!pte_swapped(__swp_entry_to_pte(arch_entry)));

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#693: FILE: mm/memory.c:631:
+	struct pglist_data* node_data;

CHECK:BRACES: braces {} should be used on all arms of this statement
#709: FILE: mm/memory.c:677:
+			if (vma->vm_flags & VM_PURE_PRIVATE) {
[...]
+			} else
[...]

The placement of braces is stylistically incorrect.
The preferred way is to put the opening brace last on the line,
and put the closing brace first::

  if (x is true) {
          we do y
  }

This applies for all non-functional blocks.
However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus::

  int function(int x)
  {
          body of function
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

ERROR:SPACING: space required after that ',' (ctx:VxV)
#711: FILE: mm/memory.c:679:
+					pps_page_destruction(page,vma,addr,0);
 					                         ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#711: FILE: mm/memory.c:679:
+					pps_page_destruction(page,vma,addr,0);
 					                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#711: FILE: mm/memory.c:679:
+					pps_page_destruction(page,vma,addr,0);
 					                                  ^

CHECK:BRACES: Unbalanced braces around else statement
#716: FILE: mm/memory.c:684:
+			} else

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#735: FILE: mm/memory.c:705:
+			struct page* page = pfn_to_page(pte_pfn(ptent));

WARNING:LINE_SPACING: Missing a blank line after declarations
#736: FILE: mm/memory.c:706:
+			struct page* page = pfn_to_page(pte_pfn(ptent));
+			BUG_ON(page == ZERO_PAGE(addr));

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#736: FILE: mm/memory.c:706:
+			BUG_ON(page == ZERO_PAGE(addr));

WARNING:LINE_SPACING: Missing a blank line after declarations
#743: FILE: mm/memory.c:713:
+				swp_entry_t entry;
+				entry.val = page_private(page);

CHECK:BRACES: braces {} should be used on all arms of this statement
#778: FILE: mm/memory.c:1782:
+		if (!(vma->vm_flags & VM_PURE_PRIVATE)) {
[...]
+		} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#781: FILE: mm/memory.c:1785:
+		} else

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#799: FILE: mm/memory.c:2151:
+static pte_t* pte_offsetof_base(struct vm_area_struct* vma, pte_t* base,

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#799: FILE: mm/memory.c:2151:
+static pte_t* pte_offsetof_base(struct vm_area_struct* vma, pte_t* base,

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#799: FILE: mm/memory.c:2151:
+static pte_t* pte_offsetof_base(struct vm_area_struct* vma, pte_t* base,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#800: FILE: mm/memory.c:2152:
+static pte_t* pte_offsetof_base(struct vm_area_struct* vma, pte_t* base,
+		unsigned long base_addr, int offset_index)

WARNING:LINE_SPACING: Missing a blank line after declarations
#803: FILE: mm/memory.c:2155:
+	unsigned long offset_addr;
+	offset_addr = base_addr + offset_index * PAGE_SIZE;

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#809: FILE: mm/memory.c:2161:
+^I// ^Ireturn NULL;$

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#819: FILE: mm/memory.c:2171:
+	vm_area_struct *vma, pte_t* pte, pmd_t* pmd)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#819: FILE: mm/memory.c:2171:
+	vm_area_struct *vma, pte_t* pte, pmd_t* pmd)

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#819: FILE: mm/memory.c:2171:
+	vm_area_struct *vma, pte_t* pte, pmd_t* pmd)
 	               ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#821: FILE: mm/memory.c:2173:
+	struct zone* zone;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#822: FILE: mm/memory.c:2174:
+	struct page* page;

CHECK:CAMELCASE: Avoid CamelCase: <swapType>
#825: FILE: mm/memory.c:2177:
+	int swapType = swp_type(entry);

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

CHECK:CAMELCASE: Avoid CamelCase: <swapOffset>
#826: FILE: mm/memory.c:2178:
+	int swapOffset = swp_offset(entry);

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "!next"
#855: FILE: mm/memory.c:2207:
+		if (next == NULL)

Comparisons to NULL in the form (foo == NULL) or (foo != NULL)
are better written as (!foo) and (foo).

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "!prev"
#902: FILE: mm/memory.c:2254:
+		if (prev == NULL)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#956: FILE: mm/memory.c:2315:
+	struct pglist_data* node_data;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#975: FILE: mm/memory.c:2354:
+		struct zone* zone = page_zone(page);

WARNING:LINE_SPACING: Missing a blank line after declarations
#976: FILE: mm/memory.c:2355:
+		struct zone* zone = page_zone(page);
+		spin_lock_irq(&zone->lru_lock);

CHECK:BRACES: Unbalanced braces around else statement
#1027: FILE: mm/memory.c:2411:
+	} else

CHECK:BRACES: braces {} should be used on all arms of this statement
#1036: FILE: mm/memory.c:2464:
+		if (!(vma->vm_flags & VM_PURE_PRIVATE)) {
[...]
+		} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#1039: FILE: mm/memory.c:2467:
+		} else

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1053: FILE: mm/memory.c:2736:
+static int do_unmapped_page(struct mm_struct *mm, struct vm_area_struct *vma,
+		unsigned long address, pte_t *page_table, pmd_t *pmd,

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1056: FILE: mm/memory.c:2739:
+	spinlock_t* ptl = pte_lockptr(mm, pmd);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1059: FILE: mm/memory.c:2742:
+	struct page* page;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1061: FILE: mm/memory.c:2744:
+	struct pglist_data* node_data;

WARNING:LINE_SPACING: Missing a blank line after declarations
#1062: FILE: mm/memory.c:2745:
+	struct pglist_data* node_data;
+	BUG_ON(!(vma->vm_flags & VM_PURE_PRIVATE));

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1062: FILE: mm/memory.c:2745:
+	BUG_ON(!(vma->vm_flags & VM_PURE_PRIVATE));

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1139: FILE: mm/memory.c:3117:
+static void migrate_back_pte_range(struct mm_struct* mm, pmd_t *pmd, struct

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#1140: FILE: mm/memory.c:3118:
+		vm_area_struct *vma, unsigned long addr, unsigned long end)
 		               ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1142: FILE: mm/memory.c:3120:
+	struct page* page;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1146: FILE: mm/memory.c:3124:
+	spinlock_t* ptl;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1147: FILE: mm/memory.c:3125:
+	struct pglist_data* node_data;

CHECK:BRACES: braces {} should be used on all arms of this statement
#1152: FILE: mm/memory.c:3130:
+		if (pte_present(*pte)) {
[...]
+		} else if (pte_unmapped(*pte)) {
[...]
+		} else if (pte_swapped(*pte))
[...]

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1161: FILE: mm/memory.c:3139:
+			BUG_ON(page == ZERO_PAGE(addr));

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1184: FILE: mm/memory.c:3162:
+static void migrate_back_pmd_range(struct mm_struct* mm, pud_t *pud, struct

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#1185: FILE: mm/memory.c:3163:
+		vm_area_struct *vma, unsigned long addr, unsigned long end)
 		               ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1199: FILE: mm/memory.c:3177:
+static void migrate_back_pud_range(struct mm_struct* mm, pgd_t *pgd, struct

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#1200: FILE: mm/memory.c:3178:
+		vm_area_struct *vma, unsigned long addr, unsigned long end)
 		               ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1216: FILE: mm/memory.c:3193:
+static void migrate_back_legacy_linux(struct mm_struct* mm, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1219: FILE: mm/memory.c:3195:
+	pgd_t* pgd;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1233: FILE: mm/memory.c:3209:
+void enter_pps(struct mm_struct* mm, struct vm_area_struct* vma)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1233: FILE: mm/memory.c:3209:
+void enter_pps(struct mm_struct* mm, struct vm_area_struct* vma)

WARNING:LINE_CONTINUATIONS: Avoid unnecessary line continuations
#1235: FILE: mm/memory.c:3211:
+	int condition = VM_READ | VM_WRITE | VM_EXEC | \

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "!vma->vm_file"
#1240: FILE: mm/memory.c:3216:
+	if (!(vma->vm_flags & ~condition) && vma->vm_file == NULL) {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1254: FILE: mm/memory.c:3230:
+void leave_pps(struct vm_area_struct* vma, int migrate_flag)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1256: FILE: mm/memory.c:3232:
+	struct mm_struct* mm = vma->vm_mm;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1265: FILE: mm/memory.c:3241:
+void pps_page_construction(struct page* page, struct vm_area_struct* vma,

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1265: FILE: mm/memory.c:3241:
+void pps_page_construction(struct page* page, struct vm_area_struct* vma,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1266: FILE: mm/memory.c:3242:
+void pps_page_construction(struct page* page, struct vm_area_struct* vma,
+	unsigned long address)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1268: FILE: mm/memory.c:3244:
+	struct pglist_data* node_data = NODE_DATA(page_to_nid(page));

WARNING:LINE_SPACING: Missing a blank line after declarations
#1269: FILE: mm/memory.c:3245:
+	struct pglist_data* node_data = NODE_DATA(page_to_nid(page));
+	atomic_inc(&node_data->nr_pps_total);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1275: FILE: mm/memory.c:3251:
+void pps_page_destruction(struct page* ppspage, struct vm_area_struct* vma,

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1275: FILE: mm/memory.c:3251:
+void pps_page_destruction(struct page* ppspage, struct vm_area_struct* vma,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1276: FILE: mm/memory.c:3252:
+void pps_page_destruction(struct page* ppspage, struct vm_area_struct* vma,
+	unsigned long address, int migrate)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1278: FILE: mm/memory.c:3254:
+	struct pglist_data* node_data = NODE_DATA(page_to_nid(page));

WARNING:LINE_SPACING: Missing a blank line after declarations
#1279: FILE: mm/memory.c:3255:
+	struct pglist_data* node_data = NODE_DATA(page_to_nid(page));
+	atomic_dec(&node_data->nr_pps_total);

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#1293: FILE: mm/mempolicy.c:1169:
+	unsigned target = vma->vm_flags & VM_PURE_PRIVATE ? (off >> 6) % nnodes

CHECK:SPACING: No space is necessary after a cast
#1294: FILE: mm/mempolicy.c:1170:
+		: (unsigned) off % nnodes;

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#1294: FILE: mm/mempolicy.c:1170:
+		: (unsigned) off % nnodes;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1320: FILE: mm/mincore.c:118:
+			struct page* page = pfn_to_page(pte_pfn(pte));

WARNING:LINE_SPACING: Missing a blank line after declarations
#1321: FILE: mm/mincore.c:119:
+			struct page* page = pfn_to_page(pte_pfn(pte));
+			if (PagePPS(page))

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1439: FILE: mm/rmap.c:663:
+	BUG_ON(vma->vm_flags & VM_PURE_PRIVATE);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1449: FILE: mm/rmap.c:723:
+		BUG_ON(!pte_swapped(*pte));

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1461: FILE: mm/swap_state.c:139:
+int pps_relink_swp(struct page* page, swp_entry_t entry, swp_entry_t** thrash)

ERROR:POINTER_LOCATION: "foo** bar" should be "foo **bar"
#1461: FILE: mm/swap_state.c:139:
+int pps_relink_swp(struct page* page, swp_entry_t entry, swp_entry_t** thrash)

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1463: FILE: mm/swap_state.c:141:
+	BUG_ON(!PageLocked(page));

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1509: FILE: mm/swapfile.c:504:
+static int pps_test_swap_type(struct mm_struct* mm, pmd_t* pmd, pte_t* pte, int

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1509: FILE: mm/swapfile.c:504:
+static int pps_test_swap_type(struct mm_struct* mm, pmd_t* pmd, pte_t* pte, int

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1509: FILE: mm/swapfile.c:504:
+static int pps_test_swap_type(struct mm_struct* mm, pmd_t* pmd, pte_t* pte, int

ERROR:POINTER_LOCATION: "foo** bar" should be "foo **bar"
#1510: FILE: mm/swapfile.c:505:
+		type, struct page** ret_page)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1512: FILE: mm/swapfile.c:507:
+	spinlock_t* ptl = pte_lockptr(mm, pmd);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1514: FILE: mm/swapfile.c:509:
+	struct page* page;

CHECK:BRACES: braces {} should be used on all arms of this statement
#1518: FILE: mm/swapfile.c:513:
+	if (pte_none(*pte))
[...]
+	else if (!pte_present(*pte) && pte_swapped(*pte)) { // SwappedPTE.
[...]
+	} else { // UnmappedPTE and (Present, Untouched)PTE.
[...]

CHECK:BRACES: braces {} should be used on all arms of this statement
#1528: FILE: mm/swapfile.c:523:
+		if (!PagePPS(page)) { // The page is a readahead page.
[...]
+		} else if (PageSwapCache(page)) {
[...]
+		} else
[...]

CHECK:BRACES: braces {} should be used on all arms of this statement
#1529: FILE: mm/swapfile.c:524:
+			if (PageSwapCache(page)) {
[...]
+			} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#1535: FILE: mm/swapfile.c:530:
+			} else

CHECK:BRACES: braces {} should be used on all arms of this statement
#1539: FILE: mm/swapfile.c:534:
+			if (swp_type(entry) == type) {
[...]
+			} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#1542: FILE: mm/swapfile.c:537:
+			} else

CHECK:BRACES: Unbalanced braces around else statement
#1544: FILE: mm/swapfile.c:539:
+		} else

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1551: FILE: mm/swapfile.c:546:
+static int pps_swapoff_scan_ptes(struct mm_struct* mm, struct vm_area_struct*

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1552: FILE: mm/swapfile.c:547:
+		vma, pmd_t* pmd, unsigned long addr, unsigned long end, int type)

CHECK:SPACING: No space is necessary after a cast
#1555: FILE: mm/swapfile.c:550:
+	struct page* page = (struct page*) 0xffffffff;

ERROR:POINTER_LOCATION: "(foo*)" should be "(foo *)"
#1555: FILE: mm/swapfile.c:550:
+	struct page* page = (struct page*) 0xffffffff;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1555: FILE: mm/swapfile.c:550:
+	struct page* page = (struct page*) 0xffffffff;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1557: FILE: mm/swapfile.c:552:
+	struct pglist_data* node_data;

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "!page"
#1562: FILE: mm/swapfile.c:557:
+			if (page == NULL) {

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1571: FILE: mm/swapfile.c:566:
+					BUG();

CHECK:BRACES: braces {} should be used on all arms of this statement
#1577: FILE: mm/swapfile.c:572:
+				if (!PageSwapCache(page))
[...]
+				else {
[...]

CHECK:BRACES: Unbalanced braces around else statement
#1579: FILE: mm/swapfile.c:574:
+				else {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1599: FILE: mm/swapfile.c:594:
+static int pps_swapoff_pmd_range(struct mm_struct* mm, struct vm_area_struct*

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1600: FILE: mm/swapfile.c:595:
+		vma, pud_t* pud, unsigned long addr, unsigned long end, int type)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1604: FILE: mm/swapfile.c:599:
+	pmd_t* pmd = pmd_offset(pud, addr);

WARNING:LINE_SPACING: Missing a blank line after declarations
#1605: FILE: mm/swapfile.c:600:
+	pmd_t* pmd = pmd_offset(pud, addr);
+	do {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1616: FILE: mm/swapfile.c:611:
+static int pps_swapoff_pud_range(struct mm_struct* mm, struct vm_area_struct*

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1617: FILE: mm/swapfile.c:612:
+		vma, pgd_t* pgd, unsigned long addr, unsigned long end, int type)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1621: FILE: mm/swapfile.c:616:
+	pud_t* pud = pud_offset(pgd, addr);

WARNING:LINE_SPACING: Missing a blank line after declarations
#1622: FILE: mm/swapfile.c:617:
+	pud_t* pud = pud_offset(pgd, addr);
+	do {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1633: FILE: mm/swapfile.c:628:
+static int pps_swapoff_pgd_range(struct mm_struct* mm, struct vm_area_struct*

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1640: FILE: mm/swapfile.c:635:
+	pgd_t* pgd = pgd_offset(mm, addr);

WARNING:LINE_SPACING: Missing a blank line after declarations
#1641: FILE: mm/swapfile.c:636:
+	pgd_t* pgd = pgd_offset(mm, addr);
+	do {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1654: FILE: mm/swapfile.c:649:
+	struct vm_area_struct* vma;

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#1659: FILE: mm/swapfile.c:654:
+	prev = mm = &init_mm;

Multiple assignments on a single line makes the code unnecessarily
complicated. So on a single line assign value to a single variable
only, this makes the code more readable and helps avoid typos.

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "vma"
#1671: FILE: mm/swapfile.c:666:
+		for (vma = mm->mmap; vma != NULL; vma = vma->vm_next) {

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1732: FILE: mm/swapfile.c:1990:
+static inline unsigned long scan_swap_map_batchly(struct swap_info_struct *si,
+		int type, int count, swp_entry_t avail_swps[SERIES_BOUND])

CHECK:BRACES: braces {} should be used on all arms of this statement
#1749: FILE: mm/swapfile.c:2007:
+			if (si->swap_map[offset])
[...]
+			else if (offset == last_in_cluster) {
[...]

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1753: FILE: mm/swapfile.c:2011:
+				si->cluster_next = offset-SWAPFILE_CLUSTER+1;
 				                         ^

CHECK:SPACING: spaces preferred around that '+' (ctx:VxV)
#1753: FILE: mm/swapfile.c:2011:
+				si->cluster_next = offset-SWAPFILE_CLUSTER+1;
 				                                          ^

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (8, 0)
#1768: FILE: mm/swapfile.c:2026:
+	if (offset > si->highest_bit)
+lowest:		offset = si->lowest_bit;

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (0, 16)
#1770: FILE: mm/swapfile.c:2028:
+checks:	if (!(si->flags & SWP_WRITEOK))
+		goto no_page;

WARNING:LINE_SPACING: Missing a blank line after declarations
#1776: FILE: mm/swapfile.c:2034:
+		int i;
+		for (i = 0; !si->swap_map[offset] && (result != count) &&

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1777: FILE: mm/swapfile.c:2035:
+		for (i = 0; !si->swap_map[offset] && (result != count) &&
+				offset <= si->highest_bit; offset++, i++) {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1818: FILE: mm/swapfile.c:2076:
+	struct swap_info_struct* p;

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1824: FILE: mm/swapfile.c:2082:
+		BUG_ON(p->swap_map[swp_offset(entries[i])] != 1);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1836: FILE: mm/swapfile.c:2094:
+	struct swap_info_struct* si;

WARNING:LINE_SPACING: Missing a blank line after declarations
#1837: FILE: mm/swapfile.c:2095:
+	struct swap_info_struct* si;
+	spin_lock(&swap_lock);

WARNING:LINE_SPACING: Missing a blank line after declarations
#1867: FILE: mm/swapfile.c:2125:
+	struct swap_info_struct *si = &swap_info[swp_type(nail_swp)];
+	spin_lock(&swap_lock);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1870: FILE: mm/swapfile.c:2128:
+	BUG_ON(nail_swp.val == 0);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1889: FILE: mm/swapfile.c:2147:
+	for (i = max_t(int, offset - 32, si->lowest_bit); i <= min_t(int,
+			offset + 32, si->highest_bit) && count != 0; i++) {

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1900: FILE: mm/swapfile.c:2158:
+			si->lowest_bit = swp_offset(avail_swps[result-1]) + 1;
 			                                             ^

WARNING:LINE_SPACING: Missing a blank line after declarations
#1920: FILE: mm/swapfile.c:2178:
+	struct swap_info_struct *si = &swap_info[swp_type(central_swp)];
+	BUG_ON(central_swp.val == 0);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1920: FILE: mm/swapfile.c:2178:
+	BUG_ON(central_swp.val == 0);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1932: FILE: mm/swapfile.c:2190:
+	for (i = max_t(int, offset - 32, si->lowest_bit); i <= min_t(int,
+			offset + 32, si->highest_bit) && count != 0; i++) {

ERROR:INITIALISED_STATIC: do not initialise statics to 0
#1980: FILE: mm/vmscan.c:1105:
+static int accelerate_kppsd = 0;

Static variables should not be initialized explicitly to zero.
Your compiler (or rather your loader) automatically does
it for you.

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1985: FILE: mm/vmscan.c:1110:
+	pte_t* ptes[SERIES_LENGTH];

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#1987: FILE: mm/vmscan.c:1112:
+	struct page* pages[SERIES_LENGTH];

WARNING:TYPO_SPELLING: 'cann't' may be misspelled - perhaps 'can't'?
#2001: FILE: mm/vmscan.c:1126:
+ * can be freed after snapshot, but PresentPTE cann't shift to UnmappedPTE and
                                                ^^^^^^

WARNING:TYPO_SPELLING: 'cann't' may be misspelled - perhaps 'can't'?
#2002: FILE: mm/vmscan.c:1127:
+ * page cann't be (re-)allocated swap entry.
         ^^^^^^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2004: FILE: mm/vmscan.c:1129:
+static int get_series_stage(struct series_t* series, pte_t* pte, unsigned long

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2004: FILE: mm/vmscan.c:1129:
+static int get_series_stage(struct series_t* series, pte_t* pte, unsigned long

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2007: FILE: mm/vmscan.c:1132:
+	struct page* page = NULL;

WARNING:LINE_SPACING: Missing a blank line after declarations
#2009: FILE: mm/vmscan.c:1134:
+	unsigned long flags;
+	series->addrs[index] = addr;

WARNING:BRACES: braces {} are not necessary for any arm of this statement
#2016: FILE: mm/vmscan.c:1141:
+		if (pte_young(series->orig_ptes[index])) {
[...]
+		} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#2018: FILE: mm/vmscan.c:1143:
+		} else

WARNING:UNNECESSARY_ELSE: else is not generally useful after a break or return
#2033: FILE: mm/vmscan.c:1158:
+			return 5;
+		} else {

CHECK:BRACES: Unbalanced braces around else statement
#2047: FILE: mm/vmscan.c:1172:
+	} else // NullPTE

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2051: FILE: mm/vmscan.c:1176:
+static void find_series(struct series_t* series, pte_t** start, unsigned long*

ERROR:POINTER_LOCATION: "foo** bar" should be "foo **bar"
#2051: FILE: mm/vmscan.c:1176:
+static void find_series(struct series_t* series, pte_t** start, unsigned long*

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2059: FILE: mm/vmscan.c:1184:
+	for (i = 1; i < SERIES_LENGTH && *addr < end; i++, (*start)++,
+		*addr += PAGE_SIZE) {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2069: FILE: mm/vmscan.c:1194:
+	struct mm_struct* mm;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2071: FILE: mm/vmscan.c:1196:
+	struct vm_area_struct* vma[DFTLB_CAPACITY];

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2072: FILE: mm/vmscan.c:1197:
+	pmd_t* pmd[DFTLB_CAPACITY];

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2080: FILE: mm/vmscan.c:1205:
+void flush_tlb_tasks(void* data)

WARNING:LINE_SPACING: Missing a blank line after declarations
#2086: FILE: mm/vmscan.c:1211:
+	int i;
+	for (i = 0; i < dftlb_tasks.vma_index; i++) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#2086: FILE: mm/vmscan.c:1211:
+	for (i = 0; i < dftlb_tasks.vma_index; i++) {
+		// smp::local_flush_tlb_range(dftlb_tasks.{vma, start, end});
+	}

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2096: FILE: mm/vmscan.c:1221:
+	spinlock_t* ptl = pte_lockptr(dftlb_tasks.mm, dftlb_tasks.pmd[0]);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2098: FILE: mm/vmscan.c:1223:
+	struct page* page;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2099: FILE: mm/vmscan.c:1224:
+	struct vm_area_struct* vma;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2100: FILE: mm/vmscan.c:1225:
+	struct pglist_data* node_data = NULL;

ERROR:OPEN_BRACE: that open brace { should be on the previous line
#2113: FILE: mm/vmscan.c:1238:
+			if (node_data != NULL && node_data !=
+					NODE_DATA(numa_addr_to_nid(vma, addr)))
+			{

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "node_data"
#2113: FILE: mm/vmscan.c:1238:
+			if (node_data != NULL && node_data !=

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2117: FILE: mm/vmscan.c:1242:
+				atomic_add(unmapped_pte,
+						&node_data->nr_unmapped_pte);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2119: FILE: mm/vmscan.c:1244:
+				atomic_sub(present_pte,
+						&node_data->nr_present_pte);

WARNING:BRACES: braces {} are not necessary for any arm of this statement
#2125: FILE: mm/vmscan.c:1250:
+			if (vma->vm_flags & VM_PURE_PRIVATE) {
[...]
+			} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#2127: FILE: mm/vmscan.c:1252:
+			} else

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2132: FILE: mm/vmscan.c:1257:
+			if (cmpxchg(&pte->pte_low, pte_orig.pte_low,
+						pte_unmapped.pte_low) !=

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2161: FILE: mm/vmscan.c:1286:
+static void start_dftlb(struct mm_struct* mm)

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2164: FILE: mm/vmscan.c:1289:
+	BUG_ON(dftlb_tasks.vma_index != 0);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2165: FILE: mm/vmscan.c:1290:
+	BUG_ON(dftlb_tasks.vma[0] != NULL);

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "dftlb_tasks.vma[0]"
#2165: FILE: mm/vmscan.c:1290:
+	BUG_ON(dftlb_tasks.vma[0] != NULL);

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "dftlb_tasks.vma[0]"
#2173: FILE: mm/vmscan.c:1298:
+	if (dftlb_tasks.vma_index != 0 || dftlb_tasks.vma[0] != NULL) {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2185: FILE: mm/vmscan.c:1310:
+static void fill_in_tlb_tasks(struct vm_area_struct* vma, pmd_t* pmd, unsigned

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2185: FILE: mm/vmscan.c:1310:
+static void fill_in_tlb_tasks(struct vm_area_struct* vma, pmd_t* pmd, unsigned

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "dftlb_tasks.vma[dftlb_tasks.vma_index]"
#2195: FILE: mm/vmscan.c:1320:
+	if (dftlb_tasks.vma[dftlb_tasks.vma_index] != NULL &&

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2196: FILE: mm/vmscan.c:1321:
+	if (dftlb_tasks.vma[dftlb_tasks.vma_index] != NULL &&
+			dftlb_tasks.vma[dftlb_tasks.vma_index] == vma &&

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "dftlb_tasks.vma[dftlb_tasks.vma_index]"
#2201: FILE: mm/vmscan.c:1326:
+		if (dftlb_tasks.vma[dftlb_tasks.vma_index] != NULL)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2212: FILE: mm/vmscan.c:1337:
+static void pps_stage1(spinlock_t* ptl, struct vm_area_struct* vma, unsigned

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2212: FILE: mm/vmscan.c:1337:
+static void pps_stage1(spinlock_t* ptl, struct vm_area_struct* vma, unsigned

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2213: FILE: mm/vmscan.c:1338:
+		long addr, struct series_t* series)

WARNING:LINE_SPACING: Missing a blank line after declarations
#2216: FILE: mm/vmscan.c:1341:
+	int i;
+	spin_lock(ptl);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2219: FILE: mm/vmscan.c:1344:
+		ptep_clear_flush_young(vma, addr + i * PAGE_SIZE,
+				series->ptes[i]);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2223: FILE: mm/vmscan.c:1348:
+static void pps_stage2(struct vm_area_struct* vma, pmd_t* pmd, struct series_t*

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2223: FILE: mm/vmscan.c:1348:
+static void pps_stage2(struct vm_area_struct* vma, pmd_t* pmd, struct series_t*

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2227: FILE: mm/vmscan.c:1352:
+	fill_in_tlb_tasks(vma, pmd, series->addrs[0],
+			series->addrs[series->series_length - 1] + PAGE_SIZE);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2231: FILE: mm/vmscan.c:1356:
+static int calc_realloc(struct series_t* series, swp_entry_t nail_swp, int

WARNING:LINE_SPACING: Missing a blank line after declarations
#2238: FILE: mm/vmscan.c:1363:
+	swp_entry_t temp;
+	for (i = 0; realloc_pages[i] != -1; i++) {

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#2244: FILE: mm/vmscan.c:1369:
+				// provide an overload close function.
+				&& swp_type(temp) == swap_type &&

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2253: FILE: mm/vmscan.c:1378:
+static int realloc_around_nails(struct series_t* series, swp_entry_t nail_swp,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2254: FILE: mm/vmscan.c:1379:
+static int realloc_around_nails(struct series_t* series, swp_entry_t nail_swp,
+		int realloc_pages[SERIES_BOUND],

ERROR:POINTER_LOCATION: "foo** bar" should be "foo **bar"
#2256: FILE: mm/vmscan.c:1381:
+		swp_entry_t** thrash_cursor, int* boost, int tryit)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2256: FILE: mm/vmscan.c:1381:
+		swp_entry_t** thrash_cursor, int* boost, int tryit)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2262: FILE: mm/vmscan.c:1387:
+	need_count = calc_realloc(series, nail_swp, realloc_pages,
+			remain_pages);

CHECK:BRACES: braces {} should be used on all arms of this statement
#2266: FILE: mm/vmscan.c:1391:
+	if (tryit) {
[...]
+	} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#2269: FILE: mm/vmscan.c:1394:
+	} else

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2273: FILE: mm/vmscan.c:1398:
+		if (!pps_relink_swp(series->pages[remain_pages[(*boost)++]],
+					avail_swps[i], thrash_cursor)) {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2284: FILE: mm/vmscan.c:1409:
+static void pps_stage3(struct series_t* series,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2285: FILE: mm/vmscan.c:1410:
+static void pps_stage3(struct series_t* series,
+		swp_entry_t nail_swps[SERIES_BOUND + 1],

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2290: FILE: mm/vmscan.c:1415:
+	swp_entry_t* thrash_cursor = &thrash[0];

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2300: FILE: mm/vmscan.c:1425:
+		remain = realloc_around_nails(series, nail_swps[i],
+				realloc_cursor, rotate_cursor, &thrash_cursor,

WARNING:LINE_SPACING: Missing a blank line after declarations
#2312: FILE: mm/vmscan.c:1437:
+		swp_entry_t entry = series->swps[*(realloc_cursor + i)];
+		if (entry.val == 0)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2315: FILE: mm/vmscan.c:1440:
+		remain = realloc_around_nails(series, entry, realloc_cursor,
+				rotate_cursor, &thrash_cursor, &boost, 1);

CHECK:SPACING: No space is necessary after a cast
#2321: FILE: mm/vmscan.c:1446:
+	swap_alloc_batchly(i, avail_swps, (int) 0xf0000000);

WARNING:TYPECAST_INT_CONSTANT: Unnecessary typecast of c90 int constant - '(int) 0xf0000000' could be '0xf0000000'
#2321: FILE: mm/vmscan.c:1446:
+	swap_alloc_batchly(i, avail_swps, (int) 0xf0000000);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2324: FILE: mm/vmscan.c:1449:
+		if (!pps_relink_swp(series->pages[*(realloc_cursor + j)],
+					avail_swps[i], &thrash_cursor)) {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2343: FILE: mm/vmscan.c:1468:
+static void pps_stage4(struct page* page)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2346: FILE: mm/vmscan.c:1471:
+	struct address_space* mapping = &swapper_space;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2381: FILE: mm/vmscan.c:1506:
+static int pps_stage5(spinlock_t* ptl, struct vm_area_struct* vma, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2381: FILE: mm/vmscan.c:1506:
+static int pps_stage5(spinlock_t* ptl, struct vm_area_struct* vma, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2382: FILE: mm/vmscan.c:1507:
+		mm_struct* mm, struct series_t* series, int index, struct

CHECK:SPACING: spaces preferred around that '*' (ctx:VxW)
#2382: FILE: mm/vmscan.c:1507:
+		mm_struct* mm, struct series_t* series, int index, struct
 		         ^

WARNING:LINE_SPACING: Missing a blank line after declarations
#2383: FILE: mm/vmscan.c:1508:
+		mm_struct* mm, struct series_t* series, int index, struct
+		pagevec* freed_pvec)

CHECK:SPACING: spaces preferred around that '*' (ctx:VxW)
#2383: FILE: mm/vmscan.c:1508:
+		pagevec* freed_pvec)
 		       ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2387: FILE: mm/vmscan.c:1512:
+	struct page* page = series->pages[index];

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2388: FILE: mm/vmscan.c:1513:
+	struct pglist_data* node_data = NODE_DATA(page_to_nid(page));

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2394: FILE: mm/vmscan.c:1519:
+	BUG_ON(PageWriteback(page));

WARNING:MEMORY_BARRIER: memory barrier without comment
#2398: FILE: mm/vmscan.c:1523:
+	smp_rmb();

CHECK:BRACES: braces {} should be used on all arms of this statement
#2411: FILE: mm/vmscan.c:1536:
+	if (PagePPS(page)) {
[...]
+	} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#2416: FILE: mm/vmscan.c:1541:
+	} else

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2432: FILE: mm/vmscan.c:1557:
+static void find_series_pgdata(struct series_t* series, pte_t** start, unsigned

ERROR:POINTER_LOCATION: "foo** bar" should be "foo **bar"
#2432: FILE: mm/vmscan.c:1557:
+static void find_series_pgdata(struct series_t* series, pte_t** start, unsigned

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2433: FILE: mm/vmscan.c:1558:
+		long* addr, unsigned long end)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2444: FILE: mm/vmscan.c:1569:
+static unsigned long pps_shrink_pgdata(struct scan_control* sc, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2445: FILE: mm/vmscan.c:1570:
+		series_t* series, struct mm_struct* mm, struct vm_area_struct*

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2445: FILE: mm/vmscan.c:1570:
+		series_t* series, struct mm_struct* mm, struct vm_area_struct*

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2446: FILE: mm/vmscan.c:1571:
+		vma, struct pagevec* freed_pvec, spinlock_t* ptl)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2446: FILE: mm/vmscan.c:1571:
+		vma, struct pagevec* freed_pvec, spinlock_t* ptl)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2450: FILE: mm/vmscan.c:1575:
+	struct pglist_data* node_data = NODE_DATA(sc->reclaim_node);

ERROR:SWITCH_CASE_INDENT_LEVEL: switch and case should be at the same indent
#2456: FILE: mm/vmscan.c:1581:
+		switch (series->stages[i]) {
+			case -1 ... 2:
[...]
+			case 5:
[...]
+			case 4:
+			case 6:
[...]
+			case 3:

switch should be at the same indent as case.
Example::

  switch (suffix) {
  case 'G':
  case 'g':
          mem <<= 30;
          break;
  case 'M':
  case 'm':
          mem <<= 20;
          break;
  case 'K':
  case 'k':
          mem <<= 10;
          fallthrough;
  default:
          break;
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

WARNING:PREFER_FALLTHROUGH: Prefer 'fallthrough;' over fallthrough comment
#2462: FILE: mm/vmscan.c:1587:
+				// Fall through!

Use the `fallthrough;` pseudo keyword instead of
`/* fallthrough */` like comments.

WARNING:TYPO_SPELLING: 'serieses' may be misspelled - perhaps 'series'?
#2483: FILE: mm/vmscan.c:1608:
+	 * A) don't destroy the continuity of the remain serieses.
 	                                                 ^^^^^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2516: FILE: mm/vmscan.c:1641:
+		nail_swps[nr_nail++] = swp_entry(node_data->last_nail_swp_type,
+				node_data->last_nail_swp_offset);

WARNING:LINE_SPACING: Missing a blank line after declarations
#2535: FILE: mm/vmscan.c:1660:
+		pte_t pte = *series->ptes[i];
+		if (pte_none(pte))

CHECK:BRACES: braces {} should be used on all arms of this statement
#2535: FILE: mm/vmscan.c:1660:
+		if (pte_none(pte))
[...]
+		else if ((!pte_present(pte) && pte_unmapped(pte)) ||
[...]
+		} else if (pte_swapped(pte)) {
[...]

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2538: FILE: mm/vmscan.c:1663:
+		else if ((!pte_present(pte) && pte_unmapped(pte)) ||
+				pte_present(pte)) {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2539: FILE: mm/vmscan.c:1664:
+			struct page* page = pfn_to_page(pte_pfn(pte));

WARNING:LINE_SPACING: Missing a blank line after declarations
#2540: FILE: mm/vmscan.c:1665:
+			struct page* page = pfn_to_page(pte_pfn(pte));
+			nail_swps[0].val = page_private(page);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2559: FILE: mm/vmscan.c:1684:
+static unsigned long shrink_pvma_scan_ptes(struct scan_control* sc, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2560: FILE: mm/vmscan.c:1685:
+		mm_struct* mm, struct vm_area_struct* vma, pmd_t* pmd, unsigned

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2560: FILE: mm/vmscan.c:1685:
+		mm_struct* mm, struct vm_area_struct* vma, pmd_t* pmd, unsigned

CHECK:SPACING: spaces preferred around that '*' (ctx:VxW)
#2560: FILE: mm/vmscan.c:1685:
+		mm_struct* mm, struct vm_area_struct* vma, pmd_t* pmd, unsigned
 		         ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2563: FILE: mm/vmscan.c:1688:
+	spinlock_t* ptl = pte_lockptr(mm, pmd);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2564: FILE: mm/vmscan.c:1689:
+	pte_t* pte = pte_offset_map(pmd, addr);

WARNING:LINE_SPACING: Missing a blank line after declarations
#2568: FILE: mm/vmscan.c:1693:
+	struct pagevec freed_pvec;
+	pagevec_init(&freed_pvec, 1);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2574: FILE: mm/vmscan.c:1699:
+			BUG_ON(series.series_length == 0);

ERROR:SWITCH_CASE_INDENT_LEVEL: switch and case should be at the same indent
#2575: FILE: mm/vmscan.c:1700:
+			switch (series.series_stage) {
+				case 1: // PresentPTE -- untouched PTE.
[...]
+				case 2: // untouched PTE -- UnmappedPTE.
[...]
+				case 3 ... 5:

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2596: FILE: mm/vmscan.c:1721:
+			BUG_ON(series.series_length == 0);

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2607: FILE: mm/vmscan.c:1732:
+static unsigned long shrink_pvma_pmd_range(struct scan_control* sc, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2608: FILE: mm/vmscan.c:1733:
+		mm_struct* mm, struct vm_area_struct* vma, pud_t* pud, unsigned

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2608: FILE: mm/vmscan.c:1733:
+		mm_struct* mm, struct vm_area_struct* vma, pud_t* pud, unsigned

CHECK:SPACING: spaces preferred around that '*' (ctx:VxW)
#2608: FILE: mm/vmscan.c:1733:
+		mm_struct* mm, struct vm_area_struct* vma, pud_t* pud, unsigned
 		         ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2613: FILE: mm/vmscan.c:1738:
+	pmd_t* pmd = pmd_offset(pud, addr);

WARNING:LINE_SPACING: Missing a blank line after declarations
#2614: FILE: mm/vmscan.c:1739:
+	pmd_t* pmd = pmd_offset(pud, addr);
+	do {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2623: FILE: mm/vmscan.c:1748:
+static unsigned long shrink_pvma_pud_range(struct scan_control* sc, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2624: FILE: mm/vmscan.c:1749:
+		mm_struct* mm, struct vm_area_struct* vma, pgd_t* pgd, unsigned

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2624: FILE: mm/vmscan.c:1749:
+		mm_struct* mm, struct vm_area_struct* vma, pgd_t* pgd, unsigned

CHECK:SPACING: spaces preferred around that '*' (ctx:VxW)
#2624: FILE: mm/vmscan.c:1749:
+		mm_struct* mm, struct vm_area_struct* vma, pgd_t* pgd, unsigned
 		         ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2629: FILE: mm/vmscan.c:1754:
+	pud_t* pud = pud_offset(pgd, addr);

WARNING:LINE_SPACING: Missing a blank line after declarations
#2630: FILE: mm/vmscan.c:1755:
+	pud_t* pud = pud_offset(pgd, addr);
+	do {

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2639: FILE: mm/vmscan.c:1764:
+static unsigned long shrink_pvma_pgd_range(struct scan_control* sc, struct

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2640: FILE: mm/vmscan.c:1765:
+		mm_struct* mm, struct vm_area_struct* vma)

CHECK:SPACING: spaces preferred around that '*' (ctx:VxW)
#2640: FILE: mm/vmscan.c:1765:
+		mm_struct* mm, struct vm_area_struct* vma)
 		         ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2644: FILE: mm/vmscan.c:1769:
+	pgd_t* pgd;

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#2645: FILE: mm/vmscan.c:1770:
+#define sppr(from, to) \
+	pgd = pgd_offset(mm, from); \
+	do { \
+		next = pgd_addr_end(addr, to); \
+		if (pgd_none_or_clear_bad(pgd)) \
+			continue; \
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
+	} while (pgd++, from = next, from != to);

Macros with multiple statements should be enclosed in a
do - while block.  Same should also be the case for macros
starting with `if` to avoid logic defects::

  #define macrofun(a, b, c)                 \
    do {                                    \
            if (a == 5)                     \
                    do_this(b, c);          \
    } while (0)

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#macros-enums-and-rtl

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'from' - possible side-effects?
#2645: FILE: mm/vmscan.c:1770:
+#define sppr(from, to) \
+	pgd = pgd_offset(mm, from); \
+	do { \
+		next = pgd_addr_end(addr, to); \
+		if (pgd_none_or_clear_bad(pgd)) \
+			continue; \
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
+	} while (pgd++, from = next, from != to);

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'to' - possible side-effects?
#2645: FILE: mm/vmscan.c:1770:
+#define sppr(from, to) \
+	pgd = pgd_offset(mm, from); \
+	do { \
+		next = pgd_addr_end(addr, to); \
+		if (pgd_none_or_clear_bad(pgd)) \
+			continue; \
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
+	} while (pgd++, from = next, from != to);

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#2645: FILE: mm/vmscan.c:1770:
+#define sppr(from, to) \
+	pgd = pgd_offset(mm, from); \
+	do { \
+		next = pgd_addr_end(addr, to); \
+		if (pgd_none_or_clear_bad(pgd)) \
+			continue; \
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
+	} while (pgd++, from = next, from != to);

Macro definition should not end with a semicolon. The macro
invocation style should be consistent with function calls.
This can prevent any unexpected code paths::

  #define MAC do_something;

If this macro is used within a if else statement, like::

  if (some_condition)
          MAC;

  else
          do_something;

Then there would be a compilation error, because when the macro is
expanded there are two trailing semicolons, so the else branch gets
orphaned.

See: https://lore.kernel.org/lkml/1399671106.2912.21.camel@joe-AO725/

ERROR:SPACING: spaces required around that '+=' (ctx:VxV)
#2651: FILE: mm/vmscan.c:1776:
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
 		            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#2651: FILE: mm/vmscan.c:1776:
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
 		                                      ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#2651: FILE: mm/vmscan.c:1776:
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
 		                                         ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#2651: FILE: mm/vmscan.c:1776:
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
 		                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#2651: FILE: mm/vmscan.c:1776:
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
 		                                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#2651: FILE: mm/vmscan.c:1776:
+		nr_reclaimed+=shrink_pvma_pud_range(sc,mm,vma,pgd,from,next); \
 		                                                      ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2673: FILE: mm/vmscan.c:1798:
+static unsigned long shrink_private_vma(struct scan_control* sc)

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2675: FILE: mm/vmscan.c:1800:
+	struct vm_area_struct* vma;

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#2680: FILE: mm/vmscan.c:1805:
+	prev = mm = &init_mm;

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2695: FILE: mm/vmscan.c:1820:
+				struct pglist_data* node_data =

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "vma"
#2699: FILE: mm/vmscan.c:1824:
+			for (vma = mm->mmap; vma != NULL; vma = vma->vm_next) {

ERROR:SPACING: spaces required around that '+=' (ctx:VxV)
#2706: FILE: mm/vmscan.c:1831:
+				nr_reclaimed+=shrink_pvma_pgd_range(sc,mm,vma);
 				            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#2706: FILE: mm/vmscan.c:1831:
+				nr_reclaimed+=shrink_pvma_pgd_range(sc,mm,vma);
 				                                      ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#2706: FILE: mm/vmscan.c:1831:
+				nr_reclaimed+=shrink_pvma_pgd_range(sc,mm,vma);
 				                                         ^

ERROR:POINTER_LOCATION: "foo* bar" should be "foo *bar"
#2748: FILE: mm/vmscan.c:2484:
+static int kppsd(void* p)

WARNING:LINE_SPACING: Missing a blank line after declarations
#2753: FILE: mm/vmscan.c:2489:
+	DEFINE_WAIT(wait);
+	tsk->flags |= PF_MEMALLOC | PF_SWAPWRITE;

ERROR:CODE_INDENT: code indent should use tabs where possible
#2761: FILE: mm/vmscan.c:2497:
+ ^I^Iaccelerate_kppsd >>= 1;$

Code indent should use tabs instead of spaces.
Outside of comments, documentation and Kconfig,
spaces are never used for indentation.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2761: FILE: mm/vmscan.c:2497:
+ ^I^Iaccelerate_kppsd >>= 1;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#2761: FILE: mm/vmscan.c:2497:
+ ^I^Iaccelerate_kppsd >>= 1;$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2763: FILE: mm/vmscan.c:2499:
+		wait_event_timeout(kppsd_wait, accelerate_kppsd != 0,
+				msecs_to_jiffies(16000));

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2786: FILE: mm/vmstat.c:613:
+	seq_printf(m,
+			"\n------------------------"

WARNING:SPLIT_STRING: quoted string split across lines
#2787: FILE: mm/vmstat.c:614:
+			"\n------------------------"
+			"\n  nr_pps_total:       %i"

Quoted strings that appear as messages in userspace and can be
grepped, should not be split across multiple lines.

See: https://lore.kernel.org/lkml/20120203052727.GA15035@leaf/

WARNING:SPLIT_STRING: quoted string split across lines
#2788: FILE: mm/vmstat.c:615:
+			"\n  nr_pps_total:       %i"
+			"\n  nr_present_pte:     %i"

WARNING:SPLIT_STRING: quoted string split across lines
#2789: FILE: mm/vmstat.c:616:
+			"\n  nr_present_pte:     %i"
+			"\n  nr_unmapped_pte:    %i"

WARNING:SPLIT_STRING: quoted string split across lines
#2790: FILE: mm/vmstat.c:617:
+			"\n  nr_unmapped_pte:    %i"
+			"\n  nr_swapped_pte:     %i",

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000387741.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 155 errors, 96 warnings, 94 checks, 2588 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000387741.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
