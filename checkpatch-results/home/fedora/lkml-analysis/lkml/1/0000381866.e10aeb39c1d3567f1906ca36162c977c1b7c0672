WARNING:TYPO_SPELLING: 'wraper' may be misspelled - perhaps 'wrapper'?
#23: 
This patch adds DEFINE_SPUFS_ATTRIBUTE(), a wraper around
                                            ^^^^^^

Some words may have been misspelled.  Consider reviewing them.

WARNING:COMMIT_LOG_LONG_LINE: Possible unwrapped commit description (prefer a maximum 75 chars per line)
#28: 
support the coredump code. This patch hides one of those (the locked version)

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__get' - possible side-effects?
#53: FILE: arch/powerpc/platforms/cell/spufs/file.c:1088:
+#define DEFINE_SPUFS_ATTRIBUTE(__name, __get, __set, __fmt, __acquire)	\
+static u64 __##__get(void *data)					\
+{									\
+	struct spu_context *ctx = data;					\
+	u64 ret;							\
+									\
+	if (__acquire == SPU_ATTR_ACQUIRE) {				\
+		spu_acquire(ctx);					\
+		ret = __get(ctx);					\
+		spu_release(ctx);					\
+	} else if (__acquire == SPU_ATTR_ACQUIRE_SAVED)	{		\
+		spu_acquire_saved(ctx);					\
+		ret = __get(ctx);					\
+		spu_release_saved(ctx);					\
+	} else								\
+		ret = __get(ctx);					\
+									\
+	return ret;							\
+}									\
+DEFINE_SIMPLE_ATTRIBUTE(__name, __##__get, __set, __fmt);

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__acquire' - possible side-effects?
#53: FILE: arch/powerpc/platforms/cell/spufs/file.c:1088:
+#define DEFINE_SPUFS_ATTRIBUTE(__name, __get, __set, __fmt, __acquire)	\
+static u64 __##__get(void *data)					\
+{									\
+	struct spu_context *ctx = data;					\
+	u64 ret;							\
+									\
+	if (__acquire == SPU_ATTR_ACQUIRE) {				\
+		spu_acquire(ctx);					\
+		ret = __get(ctx);					\
+		spu_release(ctx);					\
+	} else if (__acquire == SPU_ATTR_ACQUIRE_SAVED)	{		\
+		spu_acquire_saved(ctx);					\
+		ret = __get(ctx);					\
+		spu_release_saved(ctx);					\
+	} else								\
+		ret = __get(ctx);					\
+									\
+	return ret;							\
+}									\
+DEFINE_SIMPLE_ATTRIBUTE(__name, __##__get, __set, __fmt);

CHECK:MACRO_ARG_PRECEDENCE: Macro argument '__acquire' may be better as '(__acquire)' to avoid precedence issues
#53: FILE: arch/powerpc/platforms/cell/spufs/file.c:1088:
+#define DEFINE_SPUFS_ATTRIBUTE(__name, __get, __set, __fmt, __acquire)	\
+static u64 __##__get(void *data)					\
+{									\
+	struct spu_context *ctx = data;					\
+	u64 ret;							\
+									\
+	if (__acquire == SPU_ATTR_ACQUIRE) {				\
+		spu_acquire(ctx);					\
+		ret = __get(ctx);					\
+		spu_release(ctx);					\
+	} else if (__acquire == SPU_ATTR_ACQUIRE_SAVED)	{		\
+		spu_acquire_saved(ctx);					\
+		ret = __get(ctx);					\
+		spu_release_saved(ctx);					\
+	} else								\
+		ret = __get(ctx);					\
+									\
+	return ret;							\
+}									\
+DEFINE_SIMPLE_ATTRIBUTE(__name, __##__get, __set, __fmt);

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#53: FILE: arch/powerpc/platforms/cell/spufs/file.c:1088:
+#define DEFINE_SPUFS_ATTRIBUTE(__name, __get, __set, __fmt, __acquire)	\
+static u64 __##__get(void *data)					\
+{									\
+	struct spu_context *ctx = data;					\
+	u64 ret;							\
+									\
+	if (__acquire == SPU_ATTR_ACQUIRE) {				\
+		spu_acquire(ctx);					\
+		ret = __get(ctx);					\
+		spu_release(ctx);					\
+	} else if (__acquire == SPU_ATTR_ACQUIRE_SAVED)	{		\
+		spu_acquire_saved(ctx);					\
+		ret = __get(ctx);					\
+		spu_release_saved(ctx);					\
+	} else								\
+		ret = __get(ctx);					\
+									\
+	return ret;							\
+}									\
+DEFINE_SIMPLE_ATTRIBUTE(__name, __##__get, __set, __fmt);

Macro definition should not end with a semicolon. The macro
invocation style should be consistent with function calls.
This can prevent any unexpected code paths::

  #define MAC do_something;

If this macro is used within a if else statement, like::

  if (some_condition)
          MAC;

  else
          do_something;

Then there would be a compilation error, because when the macro is
expanded there are two trailing semicolons, so the else branch gets
orphaned.

See: https://lore.kernel.org/lkml/1399671106.2912.21.camel@joe-AO725/

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000381866.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 0 errors, 3 warnings, 3 checks, 338 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000381866.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
