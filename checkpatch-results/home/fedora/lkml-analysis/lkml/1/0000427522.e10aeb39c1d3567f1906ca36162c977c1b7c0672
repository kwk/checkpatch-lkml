CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#95: FILE: fs/udf/balloc.c:64:
+	while (size & ~(BITS_PER_LONG-1)) {
 	                             ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#164: FILE: fs/udf/balloc.c:140:
+				   struct inode * inode,

When using pointer data or a function that returns a pointer type,
the preferred use of * is adjacent to the data name or function name
and not adjacent to the type name.
Examples::

  char *linux_banner;
  unsigned long long memparse(char *ptr, char **retptr);
  char *match_strdup(substring_t *s);

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:CAMELCASE: Avoid CamelCase: <logicalBlockNum>
#177: FILE: fs/udf/balloc.c:156:
+	    (bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum)) {

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

CHECK:CAMELCASE: Avoid CamelCase: <partitionReferenceNum>
#177: FILE: fs/udf/balloc.c:156:
+	    (bloc.logicalBlockNum + count) > UDF_SB_PARTLEN(sb, bloc.partitionReferenceNum)) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#236: FILE: fs/udf/balloc.c:210:
+				      struct inode * inode,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#238: FILE: fs/udf/balloc.c:212:
+				      uint16_t partition,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#239: FILE: fs/udf/balloc.c:213:
+				      uint32_t first_block,

CHECK:CAMELCASE: Avoid CamelCase: <spaceBitmapDesc>
#249: FILE: fs/udf/balloc.c:231:
+		     (sizeof(struct spaceBitmapDesc) << 3) +

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#289: FILE: fs/udf/balloc.c:274:
+				struct inode * inode,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#291: FILE: fs/udf/balloc.c:276:
+				uint16_t partition,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#292: FILE: fs/udf/balloc.c:277:
+				uint32_t goal, int *err)

WARNING:LONG_LINE: line length of 103 exceeds 100 columns
#394: FILE: fs/udf/balloc.c:368:
+	for (i = 0; i < 7 && bit > (group_start << 3) && udf_test_bit(bit - 1, bh->b_data); i++, bit--)

The line has exceeded the specified maximum length.
To use a different maximum line length, the --max-line-length=n option
may be added while invoking checkpatch.

Earlier, the default line length was 80 columns.  Commit bdc48fa11e46
("checkpatch/coding-style: deprecate 80-column warning") increased the
limit to 100 columns.  This is not a hard limit either and it's
preferable to stay within 80 columns whenever possible.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#breaking-long-lines-and-strings

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#434: FILE: fs/udf/balloc.c:409:
+				  struct inode * inode,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#435: FILE: fs/udf/balloc.c:410:
+				  struct inode * table,

WARNING:LONG_LINE: line length of 102 exceeds 100 columns
#507: FILE: fs/udf/balloc.c:466:
+				eloc.logicalBlockNum -= ((0x3FFFFFFF - elen) >> sb->s_blocksize_bits);

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#605: FILE: fs/udf/balloc.c:534:
+			if (!(epos.bh = udf_tread(sb, udf_get_lb_pblock(sb, epos.block, 0)))) {

Do not use assignments in if condition.
Example::

  if ((foo = bar(...)) < BAZ) {

should be written as::

  foo = bar(...);
  if (foo < BAZ) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#711: FILE: fs/udf/balloc.c:621:
+				     struct inode * inode,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#713: FILE: fs/udf/balloc.c:623:
+				     uint32_t first_block,

WARNING:LONG_LINE: line length of 114 exceeds 100 columns
#740: FILE: fs/udf/balloc.c:659:
+		if (inode && DQUOT_PREALLOC_BLOCK(inode, alloc_count > block_count ? block_count : alloc_count)) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#774: FILE: fs/udf/balloc.c:686:
+			       struct inode * inode,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#776: FILE: fs/udf/balloc.c:688:
+			       uint32_t goal, int *err)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#853: FILE: fs/udf/balloc.c:789:
+			    struct inode * inode,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#904: FILE: fs/udf/balloc.c:817:
+			       struct inode * inode,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#905: FILE: fs/udf/balloc.c:818:
+			       uint16_t partition, uint32_t first_block,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#953: FILE: fs/udf/balloc.c:843:
+			 struct inode * inode,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#954: FILE: fs/udf/balloc.c:844:
+			 uint16_t partition, uint32_t goal, int *err)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1030: FILE: fs/udf/dir.c:98:
+static int do_udf_readdir(struct inode * dir, struct file *filp,
                                                            ^^^^

Some words may have been misspelled.  Consider reviewing them.

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1030: FILE: fs/udf/dir.c:98:
+static int do_udf_readdir(struct inode * dir, struct file *filp,

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#1072: FILE: fs/udf/dir.c:141:
+		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {

CHECK:CAMELCASE: Avoid CamelCase: <fileCharacteristics>
#1154: FILE: fs/udf/dir.c:200:
+		if ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1207: FILE: fs/udf/directory.c:22:
+static uint8_t * udf_filead_read(struct inode *dir, uint8_t *tmpad, uint8_t ad_size,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1257: FILE: fs/udf/directory.c:70:
+struct fileIdentDesc * udf_fileident_read(struct inode *dir, loff_t *nf_pos,

CHECK:CAMELCASE: Avoid CamelCase: <fileIdentDesc>
#1257: FILE: fs/udf/directory.c:70:
+struct fileIdentDesc * udf_fileident_read(struct inode *dir, loff_t *nf_pos,

CHECK:CAMELCASE: Avoid CamelCase: <extendedFileEntry>
#1280: FILE: fs/udf/directory.c:86:
+					sizeof(struct extendedFileEntry) :

CHECK:CAMELCASE: Avoid CamelCase: <fileEntry>
#1281: FILE: fs/udf/directory.c:87:
+					sizeof(struct fileEntry)),

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around fibh->eoffset
#1282: FILE: fs/udf/directory.c:88:
+				       dir->i_sb->s_blocksize, &(fibh->eoffset));

Parentheses are not required in the following cases:

  1. Function pointer uses::

      (foo->bar)();

    could be::

      foo->bar();

  2. Comparisons in if::

      if ((foo->bar) && (foo->baz))
      if ((foo == bar))

    could be::

      if (foo->bar && foo->baz)
      if (foo == bar)

  3. addressof/dereference single Lvalues::

      &(foo->bar)
      *(foo->bar)

    could be::

      &foo->bar
      *foo->bar

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around fibh->eoffset
#1347: FILE: fs/udf/directory.c:144:
+			       &(fibh->eoffset));

ERROR:SPACING: space prohibited after that '-' (ctx:WxW)
#1382: FILE: fs/udf/directory.c:175:
+		if (sizeof(struct fileIdentDesc) > - fibh->soffset) {
 		                                   ^

CHECK:CAMELCASE: Avoid CamelCase: <lengthOfImpUse>
#1392: FILE: fs/udf/directory.c:183:
+				  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1409: FILE: fs/udf/directory.c:195:
+struct fileIdentDesc * udf_get_fileident(void * buffer, int bufsize, int * offset)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1409: FILE: fs/udf/directory.c:195:
+struct fileIdentDesc * udf_get_fileident(void * buffer, int bufsize, int * offset)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1409: FILE: fs/udf/directory.c:195:
+struct fileIdentDesc * udf_get_fileident(void * buffer, int bufsize, int * offset)

WARNING:BRACES: braces {} are not necessary for single statement blocks
#1425: FILE: fs/udf/directory.c:209:
+	if (*offset > 0 && *offset < bufsize) {
 		ptr += *offset;
 	}

The placement of braces is stylistically incorrect.
The preferred way is to put the opening brace last on the line,
and put the closing brace first::

  if (x is true) {
          we do y
  }

This applies for all non-functional blocks.
However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus::

  int function(int x)
  {
          body of function
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

CHECK:CAMELCASE: Avoid CamelCase: <descTag>
#1432: FILE: fs/udf/directory.c:213:
+	if (le16_to_cpu(fi->descTag.tagIdent) != TAG_IDENT_FID) {

CHECK:CAMELCASE: Avoid CamelCase: <tagIdent>
#1432: FILE: fs/udf/directory.c:213:
+	if (le16_to_cpu(fi->descTag.tagIdent) != TAG_IDENT_FID) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1461: FILE: fs/udf/directory.c:238:
+static extent_ad * udf_get_fileextent(void * buffer, int bufsize, int * offset)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1461: FILE: fs/udf/directory.c:238:
+static extent_ad * udf_get_fileextent(void * buffer, int bufsize, int * offset)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1461: FILE: fs/udf/directory.c:238:
+static extent_ad * udf_get_fileextent(void * buffer, int bufsize, int * offset)

CHECK:CAMELCASE: Avoid CamelCase: <extendedAttr>
#1486: FILE: fs/udf/directory.c:257:
+	ptr = (uint8_t *)(fe->extendedAttr) + le32_to_cpu(fe->lengthExtendedAttr);

CHECK:CAMELCASE: Avoid CamelCase: <lengthExtendedAttr>
#1486: FILE: fs/udf/directory.c:257:
+	ptr = (uint8_t *)(fe->extendedAttr) + le32_to_cpu(fe->lengthExtendedAttr);

CHECK:CAMELCASE: Avoid CamelCase: <lengthAllocDescs>
#1490: FILE: fs/udf/directory.c:259:
+	if ((*offset > 0) && (*offset < le32_to_cpu(fe->lengthAllocDescs))) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#1490: FILE: fs/udf/directory.c:259:
+	if ((*offset > 0) && (*offset < le32_to_cpu(fe->lengthAllocDescs))) {
 		ptr += *offset;
 	}

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1500: FILE: fs/udf/directory.c:270:
+short_ad * udf_get_fileshortad(uint8_t *ptr, int maxoffset, int *offset, int inc)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1500: FILE: fs/udf/directory.c:270:
+short_ad * udf_get_fileshortad(uint8_t *ptr, int maxoffset, int *offset, int inc)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1522: FILE: fs/udf/directory.c:289:
+long_ad * udf_get_filelongad(uint8_t *ptr, int maxoffset, int * offset, int inc)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#1522: FILE: fs/udf/directory.c:289:
+long_ad * udf_get_filelongad(uint8_t *ptr, int maxoffset, int * offset, int inc)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1522: FILE: fs/udf/directory.c:289:
+long_ad * udf_get_filelongad(uint8_t *ptr, int maxoffset, int * offset, int inc)

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1548: FILE: fs/udf/ecma_167.h:41:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1558: FILE: fs/udf/ecma_167.h:60:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1568: FILE: fs/udf/ecma_167.h:73:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1578: FILE: fs/udf/ecma_167.h:94:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <volStructDesc>
#1588: FILE: fs/udf/ecma_167.h:106:
+struct volStructDesc {

CHECK:CAMELCASE: Avoid CamelCase: <beginningExtendedAreaDesc>
#1598: FILE: fs/udf/ecma_167.h:125:
+struct beginningExtendedAreaDesc {

CHECK:CAMELCASE: Avoid CamelCase: <terminatingExtendedAreaDesc>
#1608: FILE: fs/udf/ecma_167.h:133:
+struct terminatingExtendedAreaDesc {

CHECK:CAMELCASE: Avoid CamelCase: <bootDesc>
#1618: FILE: fs/udf/ecma_167.h:141:
+struct bootDesc {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1628: FILE: fs/udf/ecma_167.h:162:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1635: FILE: fs/udf/ecma_167.h:167:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1643: FILE: fs/udf/ecma_167.h:173:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <NSRDesc>
#1653: FILE: fs/udf/ecma_167.h:196:
+struct NSRDesc {

CHECK:CAMELCASE: Avoid CamelCase: <primaryVolDesc>
#1665: FILE: fs/udf/ecma_167.h:205:
+struct primaryVolDesc {

CHECK:CAMELCASE: Avoid CamelCase: <anchorVolDescPtr>
#1675: FILE: fs/udf/ecma_167.h:234:
+struct anchorVolDescPtr {

CHECK:CAMELCASE: Avoid CamelCase: <volDescPtr>
#1685: FILE: fs/udf/ecma_167.h:242:
+struct volDescPtr {

CHECK:CAMELCASE: Avoid CamelCase: <impUseVolDesc>
#1695: FILE: fs/udf/ecma_167.h:250:
+struct impUseVolDesc {

CHECK:CAMELCASE: Avoid CamelCase: <partitionDesc>
#1705: FILE: fs/udf/ecma_167.h:258:
+struct partitionDesc {

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolDesc>
#1715: FILE: fs/udf/ecma_167.h:293:
+struct logicalVolDesc {

CHECK:CAMELCASE: Avoid CamelCase: <genericPartitionMap>
#1725: FILE: fs/udf/ecma_167.h:310:
+struct genericPartitionMap {

CHECK:CAMELCASE: Avoid CamelCase: <genericPartitionMap1>
#1735: FILE: fs/udf/ecma_167.h:322:
+struct genericPartitionMap1 {

CHECK:CAMELCASE: Avoid CamelCase: <genericPartitionMap2>
#1745: FILE: fs/udf/ecma_167.h:330:
+struct genericPartitionMap2 {

CHECK:CAMELCASE: Avoid CamelCase: <partitionMapLength>
#1748: FILE: fs/udf/ecma_167.h:332:
+	uint8_t		partitionMapLength;

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#1748: FILE: fs/udf/ecma_167.h:332:
+	uint8_t		partitionMapLength;

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceDesc>
#1755: FILE: fs/udf/ecma_167.h:337:
+struct unallocSpaceDesc {

CHECK:CAMELCASE: Avoid CamelCase: <terminatingDesc>
#1765: FILE: fs/udf/ecma_167.h:345:
+struct terminatingDesc {

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolIntegrityDesc>
#1773: FILE: fs/udf/ecma_167.h:351:
+struct logicalVolIntegrityDesc {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1783: FILE: fs/udf/ecma_167.h:369:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1791: FILE: fs/udf/ecma_167.h:375:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1799: FILE: fs/udf/ecma_167.h:381:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1807: FILE: fs/udf/ecma_167.h:387:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1815: FILE: fs/udf/ecma_167.h:393:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1824: FILE: fs/udf/ecma_167.h:400:
+typedef struct {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1833: FILE: fs/udf/ecma_167.h:407:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <fileSetDesc>
#1843: FILE: fs/udf/ecma_167.h:430:
+struct fileSetDesc {

CHECK:CAMELCASE: Avoid CamelCase: <partitionHeaderDesc>
#1853: FILE: fs/udf/ecma_167.h:453:
+struct partitionHeaderDesc {

CHECK:CAMELCASE: Avoid CamelCase: <allocExtDesc>
#1873: FILE: fs/udf/ecma_167.h:483:
+struct allocExtDesc {

WARNING:NEW_TYPEDEFS: do not add new typedefs
#1882: FILE: fs/udf/ecma_167.h:490:
+typedef struct {

CHECK:CAMELCASE: Avoid CamelCase: <indirectEntry>
#1892: FILE: fs/udf/ecma_167.h:543:
+struct indirectEntry {

CHECK:CAMELCASE: Avoid CamelCase: <terminalEntry>
#1901: FILE: fs/udf/ecma_167.h:550:
+struct terminalEntry {

CHECK:CAMELCASE: Avoid CamelCase: <extendedAttrHeaderDesc>
#1919: FILE: fs/udf/ecma_167.h:619:
+struct extendedAttrHeaderDesc {

CHECK:CAMELCASE: Avoid CamelCase: <genericFormat>
#1928: FILE: fs/udf/ecma_167.h:626:
+struct genericFormat {

CHECK:CAMELCASE: Avoid CamelCase: <charSetInfo>
#1938: FILE: fs/udf/ecma_167.h:635:
+struct charSetInfo {

CHECK:CAMELCASE: Avoid CamelCase: <altPerms>
#1948: FILE: fs/udf/ecma_167.h:646:
+struct altPerms {

CHECK:CAMELCASE: Avoid CamelCase: <fileTimesExtAttr>
#1958: FILE: fs/udf/ecma_167.h:657:
+struct fileTimesExtAttr {

CHECK:CAMELCASE: Avoid CamelCase: <infoTimesExtAttr>
#1968: FILE: fs/udf/ecma_167.h:674:
+struct infoTimesExtAttr {

CHECK:CAMELCASE: Avoid CamelCase: <deviceSpec>
#1978: FILE: fs/udf/ecma_167.h:685:
+struct deviceSpec {

CHECK:CAMELCASE: Avoid CamelCase: <impUseExtAttr>
#1988: FILE: fs/udf/ecma_167.h:697:
+struct impUseExtAttr {

CHECK:CAMELCASE: Avoid CamelCase: <appUseExtAttr>
#1998: FILE: fs/udf/ecma_167.h:708:
+struct appUseExtAttr {

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceEntry>
#2008: FILE: fs/udf/ecma_167.h:728:
+struct unallocSpaceEntry {

CHECK:CAMELCASE: Avoid CamelCase: <partitionIntegrityEntry>
#2028: FILE: fs/udf/ecma_167.h:744:
+struct partitionIntegrityEntry {

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolHeaderDesc>
#2038: FILE: fs/udf/ecma_167.h:767:
+struct logicalVolHeaderDesc {

CHECK:CAMELCASE: Avoid CamelCase: <pathComponent>
#2046: FILE: fs/udf/ecma_167.h:773:
+struct pathComponent {

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#2082: FILE: fs/udf/file.c:80:
+				     unsigned offset, unsigned to)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#2082: FILE: fs/udf/file.c:80:
+				     unsigned offset, unsigned to)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#2090: FILE: fs/udf/file.c:87:
+				    unsigned offset, unsigned to)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#2090: FILE: fs/udf/file.c:87:
+				    unsigned offset, unsigned to)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2165: FILE: fs/udf/file.c:184:
+int udf_ioctl(struct inode *inode, struct file *filp,
                                                 ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2173: FILE: fs/udf/file.c:190:
+	if (file_permission(filp, MAY_READ) != 0) {
 	                    ^^^^

WARNING:TYPO_SPELLING: 'iput' may be misspelled - perhaps 'input'?
#2338: FILE: fs/udf/ialloc.c:133:
+		iput(inode);
 		^^^^

CHECK:CAMELCASE: Avoid CamelCase: <fileIdent>
#2478: FILE: fs/udf/inode.c:255:
+				 sfi->fileIdent + le16_to_cpu(sfi->lengthOfImpUse))) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#2528: FILE: fs/udf/inode.c:329:
+static struct buffer_head * udf_getblk(struct inode *inode, long block,

CHECK:CAMELCASE: Avoid CamelCase: <extLength>
#2598: FILE: fs/udf/inode.c:393:
+		add = ((1 << 30) - sb->s_blocksize - (last_ext->extLength &

WARNING:LONG_LINE: line length of 103 exceeds 100 columns
#2599: FILE: fs/udf/inode.c:394:
+						      UDF_EXTENT_LENGTH_MASK)) >> sb->s_blocksize_bits;

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#2781: FILE: fs/udf/inode.c:602:
+		if ((etype = udf_next_aext(inode, &next_epos, &eloc, &elen, 0)) != -1) {

CHECK:CAMELCASE: Avoid CamelCase: <extLocation>
#2783: FILE: fs/udf/inode.c:604:
+			laarr[c + 1].extLocation = eloc;

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#2795: FILE: fs/udf/inode.c:614:
+	 * block in the extent corresponding to the requested block */

The comment style is incorrect.  The preferred style for multi-
line comments is::

  /*
  * This is the preferred style
  * for multi line comments.
  */

The networking comment style is a bit different, with the first line
not empty like the former::

  /* This is the preferred comment style
  * for files in net/ and drivers/net/
  */

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#commenting

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#2826: FILE: fs/udf/inode.c:638:
+	 * block, requested block, and blocks after requested block */

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#2837: FILE: fs/udf/inode.c:651:
+	 * the new number of extents is less than the old number */

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#2888: FILE: fs/udf/inode.c:692:
+			laarr[curr + 2] = laarr[curr + 1] = laarr[curr];

Multiple assignments on a single line makes the code unnecessarily
complicated. So on a single line assign value to a single variable
only, this makes the code more readable and helps avoid typos.

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#2966: FILE: fs/udf/inode.c:743:
+			length = currlength = (((laarr[c + 1].extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:LONG_LINE: line length of 112 exceeds 100 columns
#2967: FILE: fs/udf/inode.c:744:
+						inode->i_sb->s_blocksize - 1) >> inode->i_sb->s_blocksize_bits);

WARNING:LONG_LINE: line length of 105 exceeds 100 columns
#3009: FILE: fs/udf/inode.c:768:
+						   next, (UDF_DEFAULT_PREALLOC_BLOCKS > length ? length :

WARNING:CONSTANT_COMPARISON: Comparisons should place the constant on the right side of the test
#3009: FILE: fs/udf/inode.c:768:
+						   next, (UDF_DEFAULT_PREALLOC_BLOCKS > length ? length :

Comparisons with a constant or upper case identifier on the left
side of the test should be avoided.

WARNING:LONG_LINE: line length of 101 exceeds 100 columns
#3010: FILE: fs/udf/inode.c:769:
+							  UDF_DEFAULT_PREALLOC_BLOCKS) - currlength);

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#3011: FILE: fs/udf/inode.c:770:
+^I^Iif (numalloc) ^I{$

WARNING:LONG_LINE: line length of 107 exceeds 100 columns
#3041: FILE: fs/udf/inode.c:788:
+					    inode->i_sb->s_blocksize - 1) >> inode->i_sb->s_blocksize_bits;

WARNING:LONG_LINE: line length of 113 exceeds 100 columns
#3088: FILE: fs/udf/inode.c:818:
+			    ((laarr[i + 1].extLocation.logicalBlockNum - laarr[i].extLocation.logicalBlockNum) ==

WARNING:LONG_LINE: line length of 113 exceeds 100 columns
#3101: FILE: fs/udf/inode.c:825:
+								  (laarr[i].extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:LONG_LINE: line length of 124 exceeds 100 columns
#3102: FILE: fs/udf/inode.c:826:
+								  UDF_EXTENT_LENGTH_MASK) & ~(inode->i_sb->s_blocksize - 1);

WARNING:LONG_LINE: line length of 115 exceeds 100 columns
#3124: FILE: fs/udf/inode.c:836:
+						  inode->i_sb->s_blocksize - 1) & ~(inode->i_sb->s_blocksize - 1));

WARNING:LONG_LINE: line length of 104 exceeds 100 columns
#3137: FILE: fs/udf/inode.c:845:
+			   ((laarr[i + 1].extLength >> 30) == (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))) {

WARNING:LONG_LINE: line length of 105 exceeds 100 columns
#3142: FILE: fs/udf/inode.c:848:
+					 inode->i_sb->s_blocksize - 1) >> inode->i_sb->s_blocksize_bits);

WARNING:LONG_LINE: line length of 105 exceeds 100 columns
#3156: FILE: fs/udf/inode.c:856:
+							  (laarr[i].extLength & UDF_EXTENT_LENGTH_MASK) +

WARNING:LONG_LINE: line length of 114 exceeds 100 columns
#3157: FILE: fs/udf/inode.c:857:
+							  UDF_EXTENT_LENGTH_MASK) & ~(inode->i_sb->s_blocksize-1);

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#3157: FILE: fs/udf/inode.c:857:
+							  UDF_EXTENT_LENGTH_MASK) & ~(inode->i_sb->s_blocksize-1);
 							                                                      ^

WARNING:LONG_LINE: line length of 105 exceeds 100 columns
#3172: FILE: fs/udf/inode.c:863:
+					  inode->i_sb->s_blocksize - 1) & ~(inode->i_sb->s_blocksize-1));

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#3172: FILE: fs/udf/inode.c:863:
+					  inode->i_sb->s_blocksize - 1) & ~(inode->i_sb->s_blocksize-1));
 					                                                            ^

WARNING:LONG_LINE: line length of 105 exceeds 100 columns
#3187: FILE: fs/udf/inode.c:873:
+					 inode->i_sb->s_blocksize - 1) >> inode->i_sb->s_blocksize_bits);

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#3243: FILE: fs/udf/inode.c:913:
+			       int create, int * err)

WARNING:LONG_LINE: line length of 103 exceeds 100 columns
#3291: FILE: fs/udf/inode.c:961:
+			       inode->i_sb->s_blocksize - offset - udf_file_entry_alloc_offset(inode));

CHECK:CAMELCASE: Avoid CamelCase: <icbTag>
#3346: FILE: fs/udf/inode.c:1014:
+	if (le16_to_cpu(fe->icbTag.strategyType) == 4096) {

CHECK:CAMELCASE: Avoid CamelCase: <strategyType>
#3346: FILE: fs/udf/inode.c:1014:
+	if (le16_to_cpu(fe->icbTag.strategyType) == 4096) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#3367: FILE: fs/udf/inode.c:1026:
+				if (ie->indirectICB.extLength &&

CHECK:CAMELCASE: Avoid CamelCase: <indirectICB>
#3367: FILE: fs/udf/inode.c:1026:
+				if (ie->indirectICB.extLength &&

WARNING:LONG_LINE: line length of 107 exceeds 100 columns
#3419: FILE: fs/udf/inode.c:1086:
+		if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize - sizeof(struct extendedFileEntry))) {

CHECK:CAMELCASE: Avoid CamelCase: <accessTime>
#3484: FILE: fs/udf/inode.c:1135:
+				      lets_to_cpu(fe->accessTime))) {

CHECK:CAMELCASE: Avoid CamelCase: <modificationTime>
#3498: FILE: fs/udf/inode.c:1143:
+				      lets_to_cpu(fe->modificationTime))) {

CHECK:CAMELCASE: Avoid CamelCase: <attrTime>
#3512: FILE: fs/udf/inode.c:1151:
+				      lets_to_cpu(fe->attrTime))) {

CHECK:CAMELCASE: Avoid CamelCase: <logicalBlocksRecorded>
#3531: FILE: fs/udf/inode.c:1163:
+		inode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<

CHECK:CAMELCASE: Avoid CamelCase: <createTime>
#3566: FILE: fs/udf/inode.c:1183:
+				      lets_to_cpu(efe->createTime))) {

CHECK:CAMELCASE: Avoid CamelCase: <fileType>
#3596: FILE: fs/udf/inode.c:1204:
+	switch (fe->icbTag.fileType) {

WARNING:CONST_STRUCT: struct inode_operations should normally be const
#3600: FILE: fs/udf/inode.c:1206:
+			inode->i_op = (struct inode_operations *)&udf_dir_inode_operations;

Using const is generally a good idea.  Checkpatch reads
a list of frequently used structs that are always or
almost always constant.

The existing structs list can be viewed from
`scripts/const_structs.checkpatch`.

See: https://lore.kernel.org/lkml/alpine.DEB.2.10.1608281509480.3321@hadrien/

WARNING:CONST_STRUCT: struct inode_operations should normally be const
#3615: FILE: fs/udf/inode.c:1218:
+			inode->i_op = (struct inode_operations *)&udf_file_inode_operations;

WARNING:LINE_SPACING: Missing a blank line after declarations
#3669: FILE: fs/udf/inode.c:1247:
+		struct deviceSpec *dsea = (struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);
+		if (dsea) {

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:CAMELCASE: Avoid CamelCase: <majorDeviceIdent>
#3671: FILE: fs/udf/inode.c:1249:
+					   MKDEV(le32_to_cpu(dsea->majorDeviceIdent),

CHECK:CAMELCASE: Avoid CamelCase: <minorDeviceIdent>
#3672: FILE: fs/udf/inode.c:1250:
+						 le32_to_cpu(dsea->minorDeviceIdent)));

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#3690: FILE: fs/udf/inode.c:1263:
+		printk(KERN_ERR "udf:udf_alloc_i_data (ino %ld) no free memory\n",

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'udf_alloc_i_data', this function's name, in a string
#3690: FILE: fs/udf/inode.c:1263:
+		printk(KERN_ERR "udf:udf_alloc_i_data (ino %ld) no free memory\n",

Embedded function names are less appropriate to use as
refactoring can cause function renaming.  Prefer the use of
"%s", __func__ to embedded function names.

Note that this does not work with -f (--file) checkpatch option
as it depends on patch context providing the function name.

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#3901: FILE: fs/udf/inode.c:1545:
+struct inode * udf_iget(struct super_block *sb, kernel_lb_addr ino)

WARNING:LONG_LINE: line length of 105 exceeds 100 columns
#4106: FILE: fs/udf/inode.c:1734:
+				       le32_to_cpu(aed->lengthAllocDescs) + sizeof(struct allocExtDesc));

WARNING:LONG_LINE: line length of 107 exceeds 100 columns
#4136: FILE: fs/udf/inode.c:1757:
+		if (!(epos->bh = udf_tread(inode->i_sb, udf_get_lb_pblock(inode->i_sb, epos->block, 0)))) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#4136: FILE: fs/udf/inode.c:1757:
+		if (!(epos->bh = udf_tread(inode->i_sb, udf_get_lb_pblock(inode->i_sb, epos->block, 0)))) {

CHECK:LINE_SPACING: Please don't use multiple blank lines
#4158: FILE: fs/udf/inode.c:1776:
 
+

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#4348: FILE: fs/udf/inode.c:1929:
+		if ((etype = udf_next_aext(inode, pos, eloc, elen, 1)) == -1) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4414: FILE: fs/udf/misc.c:32:
+struct buffer_head * udf_tgetblk(struct super_block *sb, int block)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4424: FILE: fs/udf/misc.c:40:
+struct buffer_head * udf_tread(struct super_block *sb, int block)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4435: FILE: fs/udf/misc.c:48:
+struct genericFormat * udf_add_extendedattr(struct inode * inode,

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4435: FILE: fs/udf/misc.c:48:
+struct genericFormat * udf_add_extendedattr(struct inode * inode,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#4436: FILE: fs/udf/misc.c:49:
+					    uint32_t size, uint32_t type,

WARNING:BRACES: braces {} are not necessary for single statement blocks
#4466: FILE: fs/udf/misc.c:74:
+		if (UDF_I_LENALLOC(inode)) {
 			memmove(&ad[size], ad, UDF_I_LENALLOC(inode));
 		}

WARNING:LONG_LINE: line length of 110 exceeds 100 columns
#4477: FILE: fs/udf/misc.c:81:
+			    le32_to_cpu(eahd->descTag.tagLocation) != UDF_I_LOCATION(inode).logicalBlockNum) {

CHECK:CAMELCASE: Avoid CamelCase: <tagLocation>
#4477: FILE: fs/udf/misc.c:81:
+			    le32_to_cpu(eahd->descTag.tagLocation) != UDF_I_LOCATION(inode).logicalBlockNum) {

CHECK:CAMELCASE: Avoid CamelCase: <appAttrLocation>
#4496: FILE: fs/udf/misc.c:100:
+			if (le32_to_cpu(eahd->appAttrLocation) < UDF_I_LENEATTR(inode)) {

CHECK:CAMELCASE: Avoid CamelCase: <impAttrLocation>
#4505: FILE: fs/udf/misc.c:107:
+			if (le32_to_cpu(eahd->impAttrLocation) < UDF_I_LENEATTR(inode)) {

CHECK:CAMELCASE: Avoid CamelCase: <descCRC>
#4527: FILE: fs/udf/misc.c:126:
+		eahd->descTag.descCRC = cpu_to_le16(udf_crc((char *)eahd +

WARNING:BRACES: braces {} are not necessary for single statement blocks
#4539: FILE: fs/udf/misc.c:135:
+	if (loc & 0x02) {
 	}

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4547: FILE: fs/udf/misc.c:141:
+struct genericFormat * udf_get_extendedattr(struct inode *inode, uint32_t type, uint8_t subtype)

WARNING:LONG_LINE: line length of 102 exceeds 100 columns
#4565: FILE: fs/udf/misc.c:155:
+		    le32_to_cpu(eahd->descTag.tagLocation) != UDF_I_LOCATION(inode).logicalBlockNum) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4597: FILE: fs/udf/misc.c:188:
+struct buffer_head * udf_read_tagged(struct super_block *sb, uint32_t block,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#4598: FILE: fs/udf/misc.c:189:
+				     uint32_t location, uint16_t *ident)

CHECK:CAMELCASE: Avoid CamelCase: <descVersion>
#4638: FILE: fs/udf/misc.c:230:
+	    le16_to_cpu(tag_p->descVersion) != 0x0003U) {

CHECK:CAMELCASE: Avoid CamelCase: <descCRCLength>
#4651: FILE: fs/udf/misc.c:239:
+						   le16_to_cpu(tag_p->descCRCLength), 0)) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4666: FILE: fs/udf/misc.c:251:
+struct buffer_head * udf_read_ptagged(struct super_block *sb, kernel_lb_addr loc,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#4667: FILE: fs/udf/misc.c:252:
+				      uint32_t offset, uint16_t *ident)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u32' over 'uint32_t'
#4687: FILE: fs/udf/misc.c:275:
+		 uint32_t loc, int length)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#4707: FILE: fs/udf/namei.c:45:
+		 uint8_t *impuse, uint8_t *fileident)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4829: FILE: fs/udf/namei.c:140:
+static struct fileIdentDesc * udf_find_entry(struct inode *dir, struct dentry *dentry,

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#4873: FILE: fs/udf/namei.c:175:
+		if (!(fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block))) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#4948: FILE: fs/udf/namei.c:226:
+		if ((flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi))) {

WARNING:TYPO_SPELLING: 'nd' may be misspelled - perhaps 'and'?
#4970: FILE: fs/udf/namei.c:275:
+static struct dentry * udf_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
                                                                                               ^^

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#4970: FILE: fs/udf/namei.c:275:
+static struct dentry * udf_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)

WARNING:CONSIDER_KSTRTO: simple_strtoul is obsolete, use kstrtoul instead
#4989: FILE: fs/udf/namei.c:290:
+			.partitionReferenceNum = simple_strtoul(dentry->d_name.name + 3,

The simple_strtol(), simple_strtoll(), simple_strtoul(), and
simple_strtoull() functions explicitly ignore overflows, which
may lead to unexpected results in callers.  The respective kstrtol(),
kstrtoll(), kstrtoul(), and kstrtoull() functions tend to be the
correct replacements.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#simple-strtol-simple-strtoll-simple-strtoul-simple-strtoull

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (8, 8)
#5000: FILE: fs/udf/namei.c:299:
 	else
[...]
+	if (udf_find_entry(dir, dentry, &fibh, &cfi)) {

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5028: FILE: fs/udf/namei.c:319:
+static struct fileIdentDesc * udf_add_entry(struct inode *dir, struct dentry *dentry,

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5059: FILE: fs/udf/namei.c:347:
+		if (!(namelen = udf_put_filename(sb, dentry->d_name.name, name,

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5099: FILE: fs/udf/namei.c:375:
+		if (!(fibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block))) {

WARNING:CONST_STRUCT: struct inode_operations should normally be const
#5329: FILE: fs/udf/namei.c:584:
+	inode->i_op = (struct inode_operations *)&udf_file_inode_operations;

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5336: FILE: fs/udf/namei.c:589:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#5346: FILE: fs/udf/namei.c:601:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5364: FILE: fs/udf/namei.c:631:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#5374: FILE: fs/udf/namei.c:643:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

WARNING:CONST_STRUCT: struct inode_operations should normally be const
#5391: FILE: fs/udf/namei.c:676:
+	inode->i_op = (struct inode_operations *)&udf_dir_inode_operations;

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5395: FILE: fs/udf/namei.c:678:
+	if (!(fi = udf_add_entry(inode, NULL, &fibh, &cfi, &err))) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5405: FILE: fs/udf/namei.c:697:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5452: FILE: fs/udf/namei.c:752:
+		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {

CHECK:CAMELCASE: Avoid CamelCase: <lengthFileIdent>
#5482: FILE: fs/udf/namei.c:772:
+		if (cfi.lengthFileIdent && (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {

CHECK:CAMELCASE: Avoid CamelCase: <componentType>
#5634: FILE: fs/udf/namei.c:972:
+		if (pc->componentType == 5) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#5670: FILE: fs/udf/namei.c:1018:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5696: FILE: fs/udf/namei.c:1051:
+	if (!(fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err))) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#5714: FILE: fs/udf/namei.c:1070:
+	if (UDF_I_ALLOCTYPE(dir) == ICBTAG_FLAG_AD_IN_ICB) {
 		mark_inode_dirty(dir);
 	}

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5734: FILE: fs/udf/namei.c:1091:
+		       struct inode * new_dir, struct dentry * new_dentry)

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#5734: FILE: fs/udf/namei.c:1091:
+		       struct inode * new_dir, struct dentry * new_dentry)

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#5744: FILE: fs/udf/namei.c:1102:
+	if ((ofi = udf_find_entry(old_dir, old_dentry, &ofibh, &ocfi))) {

WARNING:BRACES: braces {} are not necessary for any arm of this statement
#5842: FILE: fs/udf/namei.c:1188:
+		if (UDF_I_ALLOCTYPE(old_inode) == ICBTAG_FLAG_AD_IN_ICB) {
[...]
-		}
[...]

CHECK:CAMELCASE: Avoid CamelCase: <UDFIdentSuffix>
#5895: FILE: fs/udf/osta_udf.h:68:
+struct UDFIdentSuffix {

CHECK:CAMELCASE: Avoid CamelCase: <impIdentSuffix>
#5904: FILE: fs/udf/osta_udf.h:75:
+struct impIdentSuffix {

CHECK:CAMELCASE: Avoid CamelCase: <appIdentSuffix>
#5912: FILE: fs/udf/osta_udf.h:81:
+struct appIdentSuffix {

CHECK:CAMELCASE: Avoid CamelCase: <logicalVolIntegrityDescImpUse>
#5920: FILE: fs/udf/osta_udf.h:87:
+struct logicalVolIntegrityDescImpUse {

CHECK:CAMELCASE: Avoid CamelCase: <impUseVolDescImpUse>
#5930: FILE: fs/udf/osta_udf.h:99:
+struct impUseVolDescImpUse {

CHECK:CAMELCASE: Avoid CamelCase: <udfPartitionMap2>
#5940: FILE: fs/udf/osta_udf.h:109:
+struct udfPartitionMap2 {

CHECK:CAMELCASE: Avoid CamelCase: <virtualPartitionMap>
#5950: FILE: fs/udf/osta_udf.h:119:
+struct virtualPartitionMap {

CHECK:CAMELCASE: Avoid CamelCase: <sparablePartitionMap>
#5960: FILE: fs/udf/osta_udf.h:130:
+struct sparablePartitionMap {

CHECK:CAMELCASE: Avoid CamelCase: <metadataPartitionMap>
#5970: FILE: fs/udf/osta_udf.h:145:
+struct metadataPartitionMap {

CHECK:CAMELCASE: Avoid CamelCase: <virtualAllocationTable15>
#5980: FILE: fs/udf/osta_udf.h:162:
+struct virtualAllocationTable15 {

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __packed over __attribute__((packed))
#5985: FILE: fs/udf/osta_udf.h:166:
+} __attribute__ ((packed));

CHECK:CAMELCASE: Avoid CamelCase: <virtualAllocationTable20>
#5992: FILE: fs/udf/osta_udf.h:171:
+struct virtualAllocationTable20 {

CHECK:CAMELCASE: Avoid CamelCase: <sparingEntry>
#6002: FILE: fs/udf/osta_udf.h:189:
+struct sparingEntry {

CHECK:CAMELCASE: Avoid CamelCase: <sparingTable>
#6009: FILE: fs/udf/osta_udf.h:194:
+struct sparingTable {

CHECK:CAMELCASE: Avoid CamelCase: <allocDescImpUse>
#6019: FILE: fs/udf/osta_udf.h:210:
+struct allocDescImpUse {

CHECK:CAMELCASE: Avoid CamelCase: <freeEaSpace>
#6029: FILE: fs/udf/osta_udf.h:222:
+struct freeEaSpace {

CHECK:CAMELCASE: Avoid CamelCase: <DVDCopyrightImpUse>
#6037: FILE: fs/udf/osta_udf.h:228:
+struct DVDCopyrightImpUse {

CHECK:CAMELCASE: Avoid CamelCase: <freeAppEASpace>
#6047: FILE: fs/udf/osta_udf.h:237:
+struct freeAppEASpace {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#6070: FILE: fs/udf/partition.c:32:
+			       uint16_t partition, uint32_t offset)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#6087: FILE: fs/udf/partition.c:46:
+			       uint16_t partition, uint32_t offset)

ERROR:SPACING: space required after that ',' (ctx:VxV)
#6097: FILE: fs/udf/partition.c:55:
+	if (block > UDF_SB_TYPEVIRT(sb,partition).s_num_entries) {
 	                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#6100: FILE: fs/udf/partition.c:57:
+			  block, UDF_SB_TYPEVIRT(sb,partition).s_num_entries);
 			                           ^

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6122: FILE: fs/udf/partition.c:72:
+	if (!(bh = sb_bread(sb, loc))) {

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#6148: FILE: fs/udf/partition.c:93:
+				      uint16_t partition, uint32_t offset)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u16' over 'uint16_t'
#6155: FILE: fs/udf/partition.c:99:
+			       uint16_t partition, uint32_t offset)

ERROR:SPACING: space required after that ',' (ctx:VxV)
#6166: FILE: fs/udf/partition.c:106:
+		if (UDF_SB_TYPESPAR(sb,partition).s_spar_map[i] != NULL) {
 		                      ^

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_spar_map[i]"
#6166: FILE: fs/udf/partition.c:106:
+		if (UDF_SB_TYPESPAR(sb,partition).s_spar_map[i] != NULL) {

Comparisons to NULL in the form (foo == NULL) or (foo != NULL)
are better written as (!foo) and (foo).

CHECK:CAMELCASE: Avoid CamelCase: <reallocationTableLen>
#6178: FILE: fs/udf/partition.c:113:
+		for (i = 0; i < le16_to_cpu(st->reallocationTableLen); i++) {

CHECK:CAMELCASE: Avoid CamelCase: <mapEntry>
#6179: FILE: fs/udf/partition.c:114:
+			if (le32_to_cpu(st->mapEntry[i].origLocation) >= 0xFFFFFFF0) {

CHECK:CAMELCASE: Avoid CamelCase: <origLocation>
#6179: FILE: fs/udf/partition.c:114:
+			if (le32_to_cpu(st->mapEntry[i].origLocation) >= 0xFFFFFFF0) {

ERROR:SPACING: space required after that ',' (ctx:VxV)
#6207: FILE: fs/udf/partition.c:138:
+		    old_block < UDF_SB_PARTROOT(sb,i) + UDF_SB_PARTLEN(sb,i)) {
 		                                  ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#6207: FILE: fs/udf/partition.c:138:
+		    old_block < UDF_SB_PARTROOT(sb,i) + UDF_SB_PARTLEN(sb,i)) {
 		                                                         ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#6216: FILE: fs/udf/partition.c:143:
+				if (UDF_SB_TYPESPAR(sb,i).s_spar_map[j] != NULL) {
 				                      ^

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_spar_map[j]"
#6216: FILE: fs/udf/partition.c:143:
+				if (UDF_SB_TYPESPAR(sb,i).s_spar_map[j] != NULL) {

WARNING:DEEP_INDENTATION: Too many leading tabs - consider code refactoring
#6235: FILE: fs/udf/partition.c:155:
+						if (sdata->s_spar_map[j]) {

Indentation with 6 or more tabs usually indicate overly indented
code.

It is suggested to refactor excessive indentation of
if/else/for/do/while/switch statements.

See: https://lore.kernel.org/lkml/1328311239.21255.24.camel@joe2Laptop/

WARNING:DEEP_INDENTATION: Too many leading tabs - consider code refactoring
#6268: FILE: fs/udf/partition.c:177:
+						if (sdata->s_spar_map[j]) {

CHECK:CAMELCASE: Avoid CamelCase: <Opt_novrs>
#6385: FILE: fs/udf/super.c:283:
+	{Opt_novrs,	"novrs"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_nostrict>
#6386: FILE: fs/udf/super.c:284:
+	{Opt_nostrict,	"nostrict"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_bs>
#6387: FILE: fs/udf/super.c:285:
+	{Opt_bs,	"bs=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_unhide>
#6388: FILE: fs/udf/super.c:286:
+	{Opt_unhide,	"unhide"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_undelete>
#6389: FILE: fs/udf/super.c:287:
+	{Opt_undelete,	"undelete"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_noadinicb>
#6390: FILE: fs/udf/super.c:288:
+	{Opt_noadinicb,	"noadinicb"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_adinicb>
#6391: FILE: fs/udf/super.c:289:
+	{Opt_adinicb,	"adinicb"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_shortad>
#6392: FILE: fs/udf/super.c:290:
+	{Opt_shortad,	"shortad"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_longad>
#6393: FILE: fs/udf/super.c:291:
+	{Opt_longad,	"longad"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_uforget>
#6394: FILE: fs/udf/super.c:292:
+	{Opt_uforget,	"uid=forget"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_uignore>
#6395: FILE: fs/udf/super.c:293:
+	{Opt_uignore,	"uid=ignore"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_gforget>
#6396: FILE: fs/udf/super.c:294:
+	{Opt_gforget,	"gid=forget"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_gignore>
#6397: FILE: fs/udf/super.c:295:
+	{Opt_gignore,	"gid=ignore"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_gid>
#6398: FILE: fs/udf/super.c:296:
+	{Opt_gid,	"gid=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_uid>
#6399: FILE: fs/udf/super.c:297:
+	{Opt_uid,	"uid=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_umask>
#6400: FILE: fs/udf/super.c:298:
+	{Opt_umask,	"umask=%o"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_session>
#6401: FILE: fs/udf/super.c:299:
+	{Opt_session,	"session=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_lastblock>
#6402: FILE: fs/udf/super.c:300:
+	{Opt_lastblock,	"lastblock=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_anchor>
#6403: FILE: fs/udf/super.c:301:
+	{Opt_anchor,	"anchor=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_volume>
#6404: FILE: fs/udf/super.c:302:
+	{Opt_volume,	"volume=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_partition>
#6405: FILE: fs/udf/super.c:303:
+	{Opt_partition,	"partition=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_fileset>
#6406: FILE: fs/udf/super.c:304:
+	{Opt_fileset,	"fileset=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_rootdir>
#6407: FILE: fs/udf/super.c:305:
+	{Opt_rootdir,	"rootdir=%u"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_utf8>
#6408: FILE: fs/udf/super.c:306:
+	{Opt_utf8,	"utf8"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_iocharset>
#6409: FILE: fs/udf/super.c:307:
+	{Opt_iocharset,	"iocharset=%s"},

CHECK:CAMELCASE: Avoid CamelCase: <Opt_err>
#6410: FILE: fs/udf/super.c:308:
+	{Opt_err,	NULL}

WARNING:SPLIT_STRING: quoted string split across lines
#6443: FILE: fs/udf/super.c:439:
 				printk(KERN_ERR "udf: bad mount option \"%s\" "
+				       "or missing value\n", p);

Quoted strings that appear as messages in userspace and can be
grepped, should not be split across multiple lines.

See: https://lore.kernel.org/lkml/20120203052727.GA15035@leaf/

CHECK:CAMELCASE: Avoid CamelCase: <stdIdent>
#6539: FILE: fs/udf/super.c:562:
+		if (vsd->stdIdent[0] == 0) {

ERROR:SWITCH_CASE_INDENT_LEVEL: switch and case should be at the same indent
#6550: FILE: fs/udf/super.c:567:
+			switch (vsd->structType) {
+				case 0:
[...]
+				case 1:
[...]
+				case 2:
[...]
+				case 3:
[...]
+				case 255:
[...]
+				default:

switch should be at the same indent as case.
Example::

  switch (suffix) {
  case 'G':
  case 'g':
          mem <<= 30;
          break;
  case 'M':
  case 'm':
          mem <<= 20;
          break;
  case 'K':
  case 'k':
          mem <<= 10;
          fallthrough;
  default:
          break;
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

CHECK:CAMELCASE: Avoid CamelCase: <structType>
#6550: FILE: fs/udf/super.c:567:
+			switch (vsd->structType) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6623: FILE: fs/udf/super.c:652:
+			if (last[i] < 0 || !(bh = sb_bread(sb, last[i]))) {

WARNING:LONG_LINE: line length of 109 exceeds 100 columns
#6645: FILE: fs/udf/super.c:664:
+				} else if (location == udf_variable_to_fixed(last[i]) - UDF_SB_SESSION(sb)) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6668: FILE: fs/udf/super.c:676:
+				if (last[i] < 256 || !(bh = sb_bread(sb, last[i] - 256))) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6692: FILE: fs/udf/super.c:689:
+					if (last[i] < 312 + UDF_SB_SESSION(sb) ||

WARNING:LONG_LINE: line length of 103 exceeds 100 columns
#6693: FILE: fs/udf/super.c:690:
+					    !(bh = sb_bread(sb, last[i] - 312 - UDF_SB_SESSION(sb)))) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6722: FILE: fs/udf/super.c:711:
+		if ((bh = sb_bread(sb, 312 + UDF_SB_SESSION(sb)))) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#6736: FILE: fs/udf/super.c:723:
+			if (!(bh = udf_read_tagged(sb, UDF_SB_ANCHOR(sb)[i],

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'ident != TAG_IDENT_AVDP'
#6747: FILE: fs/udf/super.c:728:
+				if ((ident != TAG_IDENT_AVDP) &&
+				    (i || (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE))) {

CHECK:CAMELCASE: Avoid CamelCase: <numOfBytes>
#6827: FILE: fs/udf/super.c:785:
+							((le32_to_cpu(sp->numOfBytes) +

CHECK:CAMELCASE: Avoid CamelCase: <recordingDateAndTime>
#6885: FILE: fs/udf/super.c:830:
+			      lets_to_cpu(pvoldesc->recordingDateAndTime))) {

CHECK:CAMELCASE: Avoid CamelCase: <typeAndTimezone>
#6893: FILE: fs/udf/super.c:836:
+			  ts.minute, ts.typeAndTimezone);

CHECK:CAMELCASE: Avoid CamelCase: <volIdent>
#6903: FILE: fs/udf/super.c:841:
+	if (!udf_build_ustr(&instr, pvoldesc->volIdent, 32)) {

CHECK:CAMELCASE: Avoid CamelCase: <udf_CS0toUTF8>
#6904: FILE: fs/udf/super.c:842:
+		if (udf_CS0toUTF8(&outstr, &instr)) {

CHECK:CAMELCASE: Avoid CamelCase: <volSetIdent>
#6913: FILE: fs/udf/super.c:849:
+	if (!udf_build_ustr(&instr, pvoldesc->volSetIdent, 128)) {

CHECK:CAMELCASE: Avoid CamelCase: <partitionNumber>
#6953: FILE: fs/udf/super.c:879:
+			  UDF_SB_PARTMAPS(sb)[i].s_partition_num, le16_to_cpu(p->partitionNumber));

CHECK:CAMELCASE: Avoid CamelCase: <partitionContents>
#6964: FILE: fs/udf/super.c:893:
+			    !strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR03)) {

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceTable>
#6971: FILE: fs/udf/super.c:897:
+				if (phd->unallocSpaceTable.extLength) {

WARNING:LONG_LINE: line length of 115 exceeds 100 columns
#6973: FILE: fs/udf/super.c:899:
+						.logicalBlockNum = le32_to_cpu(phd->unallocSpaceTable.extPosition),

CHECK:CAMELCASE: Avoid CamelCase: <extPosition>
#6973: FILE: fs/udf/super.c:899:
+						.logicalBlockNum = le32_to_cpu(phd->unallocSpaceTable.extPosition),

WARNING:LONG_LINE: line length of 101 exceeds 100 columns
#6982: FILE: fs/udf/super.c:907:
+						  i, UDF_SB_PARTMAPS(sb)[i].s_uspace.s_table->i_ino);

CHECK:CAMELCASE: Avoid CamelCase: <unallocSpaceBitmap>
#6986: FILE: fs/udf/super.c:909:
+				if (phd->unallocSpaceBitmap.extLength) {

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_uspace.s_bitmap"
#6990: FILE: fs/udf/super.c:911:
+					if (UDF_SB_PARTMAPS(sb)[i].s_uspace.s_bitmap != NULL) {

WARNING:LONG_LINE: line length of 118 exceeds 100 columns
#6998: FILE: fs/udf/super.c:918:
+							  i, UDF_SB_PARTMAPS(sb)[i].s_uspace.s_bitmap->s_extPosition);

CHECK:CAMELCASE: Avoid CamelCase: <s_extPosition>
#6998: FILE: fs/udf/super.c:918:
+							  i, UDF_SB_PARTMAPS(sb)[i].s_uspace.s_bitmap->s_extPosition);

CHECK:CAMELCASE: Avoid CamelCase: <freedSpaceTable>
#7006: FILE: fs/udf/super.c:923:
+				if (phd->freedSpaceTable.extLength) {

WARNING:LONG_LINE: line length of 113 exceeds 100 columns
#7008: FILE: fs/udf/super.c:925:
+						.logicalBlockNum = le32_to_cpu(phd->freedSpaceTable.extPosition),

WARNING:LONG_LINE: line length of 101 exceeds 100 columns
#7017: FILE: fs/udf/super.c:933:
+						  i, UDF_SB_PARTMAPS(sb)[i].s_fspace.s_table->i_ino);

CHECK:CAMELCASE: Avoid CamelCase: <freedSpaceBitmap>
#7021: FILE: fs/udf/super.c:935:
+				if (phd->freedSpaceBitmap.extLength) {

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_fspace.s_bitmap"
#7025: FILE: fs/udf/super.c:937:
+					if (UDF_SB_PARTMAPS(sb)[i].s_fspace.s_bitmap != NULL) {

WARNING:LONG_LINE: line length of 118 exceeds 100 columns
#7033: FILE: fs/udf/super.c:944:
+							  i, UDF_SB_PARTMAPS(sb)[i].s_fspace.s_bitmap->s_extPosition);

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7053: FILE: fs/udf/super.c:956:
+			  le16_to_cpu(p->partitionNumber), i, UDF_SB_PARTTYPE(sb,i),
 			                                                        ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7054: FILE: fs/udf/super.c:957:
+			  UDF_SB_PARTROOT(sb,i), UDF_SB_PARTLEN(sb,i));
 			                    ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7054: FILE: fs/udf/super.c:957:
+			  UDF_SB_PARTROOT(sb,i), UDF_SB_PARTLEN(sb,i));
 			                                          ^

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#7060: FILE: fs/udf/super.c:961:
+static int udf_load_logicalvol(struct super_block *sb, struct buffer_head * bh,

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7073: FILE: fs/udf/super.c:972:
+	for (i = 0,offset = 0;
 	          ^

CHECK:CAMELCASE: Avoid CamelCase: <mapTableLength>
#7074: FILE: fs/udf/super.c:973:
+	     i < UDF_SB_NUMPARTS(sb) && offset < le32_to_cpu(lvd->mapTableLength);

WARNING:LONG_LINE: line length of 112 exceeds 100 columns
#7075: FILE: fs/udf/super.c:974:
+	     i++, offset += ((struct genericPartitionMap *)&(lvd->partitionMaps[offset]))->partitionMapLength) {

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around lvd->partitionMaps[offset]
#7075: FILE: fs/udf/super.c:974:
+	     i++, offset += ((struct genericPartitionMap *)&(lvd->partitionMaps[offset]))->partitionMapLength) {

CHECK:CAMELCASE: Avoid CamelCase: <partitionMaps>
#7075: FILE: fs/udf/super.c:974:
+	     i++, offset += ((struct genericPartitionMap *)&(lvd->partitionMaps[offset]))->partitionMapLength) {

WARNING:LONG_LINE: line length of 102 exceeds 100 columns
#7094: FILE: fs/udf/super.c:984:
+			if (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL, strlen(UDF_ID_VIRTUAL))) {

CHECK:CAMELCASE: Avoid CamelCase: <partIdent>
#7094: FILE: fs/udf/super.c:984:
+			if (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL, strlen(UDF_ID_VIRTUAL))) {

WARNING:LONG_LINE: line length of 104 exceeds 100 columns
#7095: FILE: fs/udf/super.c:985:
+				if (le16_to_cpu(((__le16 *)upm2->partIdent.identSuffix)[0]) == 0x0150) {

CHECK:CAMELCASE: Avoid CamelCase: <identSuffix>
#7095: FILE: fs/udf/super.c:985:
+				if (le16_to_cpu(((__le16 *)upm2->partIdent.identSuffix)[0]) == 0x0150) {

WARNING:LONG_LINE: line length of 111 exceeds 100 columns
#7101: FILE: fs/udf/super.c:988:
+				} else if (le16_to_cpu(((__le16 *)upm2->partIdent.identSuffix)[0]) == 0x0200) {

WARNING:LONG_LINE: line length of 111 exceeds 100 columns
#7108: FILE: fs/udf/super.c:992:
+			} else if (!strncmp(upm2->partIdent.ident, UDF_ID_SPARABLE, strlen(UDF_ID_SPARABLE))) {

CHECK:CAMELCASE: Avoid CamelCase: <numSparingTables>
#7118: FILE: fs/udf/super.c:1000:
+				for (j = 0; j < spm->numSparingTables; j++) {

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7124: FILE: fs/udf/super.c:1004:
+					if (UDF_SB_TYPESPAR(sb,i).s_spar_map[j] != NULL) {
 					                      ^

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "s_spar_map[j]"
#7124: FILE: fs/udf/super.c:1004:
+					if (UDF_SB_TYPESPAR(sb,i).s_spar_map[j] != NULL) {

WARNING:LONG_LINE: line length of 126 exceeds 100 columns
#7129: FILE: fs/udf/super.c:1007:
+						    strncmp(st->sparingIdent.ident, UDF_ID_SPARING, strlen(UDF_ID_SPARING))) {

CHECK:CAMELCASE: Avoid CamelCase: <sparingIdent>
#7129: FILE: fs/udf/super.c:1007:
+						    strncmp(st->sparingIdent.ident, UDF_ID_SPARING, strlen(UDF_ID_SPARING))) {

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7148: FILE: fs/udf/super.c:1022:
+			  i, UDF_SB_PARTNUM(sb,i), type, UDF_SB_PARTVSN(sb,i));
 			                      ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7148: FILE: fs/udf/super.c:1022:
+			  i, UDF_SB_PARTNUM(sb,i), type, UDF_SB_PARTVSN(sb,i));
 			                                                  ^

CHECK:CAMELCASE: Avoid CamelCase: <volDescSeqNum>
#7243: FILE: fs/udf/super.c:1108:
+				if (vdsn >= vds[VDS_POS_PRIMARY_VOL_DESC].volDescSeqNum) {

WARNING:LONG_LINE: line length of 107 exceeds 100 columns
#7322: FILE: fs/udf/super.c:1171:
+				for (j = vds[i].block + 1; j <  vds[VDS_POS_TERMINATING_DESC].block; j++) {

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7347: FILE: fs/udf/super.c:1199:
+	else if ((block = udf_vrs(sb, silent)) == -1) {

WARNING:SPLIT_STRING: quoted string split across lines
#7349: FILE: fs/udf/super.c:1201:
+		udf_debug("Failed to read byte 32768. Assuming open disc. "
+			  "Skipping validity check\n");

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#7373: FILE: fs/udf/super.c:1222:
+		if (UDF_SB_ANCHOR(sb)[i] &&

ERROR:OPEN_BRACE: open brace '{' following function definitions go on the next line
#7403: FILE: fs/udf/super.c:1258:
+		switch UDF_SB_PARTTYPE(sb, i) {

The opening brace should be following the function definitions on the
next line.  For any non-functional block it should be on the same line
as the last construct.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7430: FILE: fs/udf/super.c:1276:
+					    UDF_SB_PARTVSN(sb,i) == UDF_SB_PARTVSN(sb,j) &&
 					                     ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7430: FILE: fs/udf/super.c:1276:
+					    UDF_SB_PARTVSN(sb,i) == UDF_SB_PARTVSN(sb,j) &&
 					                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7431: FILE: fs/udf/super.c:1277:
+					    UDF_SB_PARTNUM(sb,i) == UDF_SB_PARTNUM(sb,j)) {
 					                     ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7431: FILE: fs/udf/super.c:1277:
+					    UDF_SB_PARTNUM(sb,i) == UDF_SB_PARTNUM(sb,j)) {
 					                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7447: FILE: fs/udf/super.c:1290:
+				if (UDF_SB_PARTTYPE(sb,i) == UDF_VIRTUAL_MAP15) {
 				                      ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7453: FILE: fs/udf/super.c:1293:
+				} else if (UDF_SB_PARTTYPE(sb,i) == UDF_VIRTUAL_MAP20) {
 				                             ^

WARNING:LONG_LINE: line length of 122 exceeds 100 columns
#7465: FILE: fs/udf/super.c:1305:
+									       UDF_SB_TYPEVIRT(sb,i).s_start_offset) >> 2;

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7465: FILE: fs/udf/super.c:1305:
+									       UDF_SB_TYPEVIRT(sb,i).s_start_offset) >> 2;
 									                         ^

CHECK:SPACING: No space is necessary after a cast
#7511: FILE: fs/udf/super.c:1348:
+	if (UDF_SB_LVIDBH(sb) &&

CHECK:CAMELCASE: Avoid CamelCase: <integrityType>
#7512: FILE: fs/udf/super.c:1349:
+	    UDF_SB_LVID(sb)->integrityType == LVID_INTEGRITY_TYPE_OPEN) {

WARNING:LONG_LINE: line length of 101 exceeds 100 columns
#7521: FILE: fs/udf/super.c:1364:
+					    le16_to_cpu(UDF_SB_LVID(sb)->descTag.descCRCLength), 0));

CHECK:CAMELCASE: Avoid CamelCase: <minUDFReadRev>
#7595: FILE: fs/udf/super.c:1486:
+		if (minUDFReadRev > UDF_MAX_READ_VERSION) {

CHECK:CAMELCASE: Avoid CamelCase: <minUDFWriteRev>
#7605: FILE: fs/udf/super.c:1491:
+		} else if (minUDFWriteRev > UDF_MAX_WRITE_VERSION) {

WARNING:SPLIT_STRING: quoted string split across lines
#7640: FILE: fs/udf/super.c:1522:
+		udf_info("UDF %s (%s) Mounting volume '%s', "
+			 "timestamp %04u/%02u/%02u %02u:%02u (%x)\n",

CHECK:CAMELCASE: Avoid CamelCase: <numFiles>
#7776: FILE: fs/udf/super.c:1677:
+			(le32_to_cpu(UDF_SB_LVIDIU(sb)->numFiles) +

CHECK:CAMELCASE: Avoid CamelCase: <numDirs>
#7777: FILE: fs/udf/super.c:1678:
+			 le32_to_cpu(UDF_SB_LVIDIU(sb)->numDirs)) : 0) + buf->f_bfree;

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#7843: FILE: fs/udf/super.c:1751:
+static unsigned int udf_count_free_table(struct super_block *sb, struct inode * table)

WARNING:BRACES: braces {} are not necessary for single statement blocks
#7852: FILE: fs/udf/super.c:1765:
+	while ((etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {
 		accum += (elen >> table->i_sb->s_blocksize_bits);
+	}

CHECK:CAMELCASE: Avoid CamelCase: <numOfPartitions>
#7874: FILE: fs/udf/super.c:1780:
+		if (le32_to_cpu(UDF_SB_LVID(sb)->numOfPartitions) > UDF_SB_PARTITION(sb)) {

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7886: FILE: fs/udf/super.c:1790:
+	if (UDF_SB_PARTFLAGS(sb,UDF_SB_PARTITION(sb)) & UDF_PART_FLAG_UNALLOC_BITMAP) {
 	                       ^

WARNING:LONG_LINE: line length of 108 exceeds 100 columns
#7889: FILE: fs/udf/super.c:1792:
+					       UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_uspace.s_bitmap);

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7893: FILE: fs/udf/super.c:1794:
+	if (UDF_SB_PARTFLAGS(sb,UDF_SB_PARTITION(sb)) & UDF_PART_FLAG_FREED_BITMAP) {
 	                       ^

WARNING:LONG_LINE: line length of 108 exceeds 100 columns
#7896: FILE: fs/udf/super.c:1796:
+					       UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_fspace.s_bitmap);

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7903: FILE: fs/udf/super.c:1801:
+	if (UDF_SB_PARTFLAGS(sb,UDF_SB_PARTITION(sb)) & UDF_PART_FLAG_UNALLOC_TABLE) {
 	                       ^

WARNING:LONG_LINE: line length of 106 exceeds 100 columns
#7906: FILE: fs/udf/super.c:1803:
+					      UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_uspace.s_table);

ERROR:SPACING: space required after that ',' (ctx:VxV)
#7910: FILE: fs/udf/super.c:1805:
+	if (UDF_SB_PARTFLAGS(sb,UDF_SB_PARTITION(sb)) & UDF_PART_FLAG_FREED_TABLE) {
 	                       ^

WARNING:LONG_LINE: line length of 106 exceeds 100 columns
#7913: FILE: fs/udf/super.c:1807:
+					      UDF_SB_PARTMAPS(sb)[UDF_SB_PARTITION(sb)].s_fspace.s_table);

CHECK:CAMELCASE: Avoid CamelCase: <lengthComponentIdent>
#7944: FILE: fs/udf/symlink.c:46:
+				if (pc->lengthComponentIdent == 0) {

CHECK:CAMELCASE: Avoid CamelCase: <componentIdent>
#7953: FILE: fs/udf/symlink.c:61:
+				p += udf_get_filename(sb, pc->componentIdent, p,

WARNING:DEEP_INDENTATION: Too many leading tabs - consider code refactoring
#8146: FILE: fs/udf/truncate.c:172:
+						if (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT) ||

CHECK:SPACING: No space is necessary after a cast
#8147: FILE: fs/udf/truncate.c:173:
+						    UDF_SB_UDFREV(sb) >= 0x0201)

CHECK:SPACING: No space is necessary after a cast
#8200: FILE: fs/udf/truncate.c:209:
+				    UDF_SB_UDFREV(sb) >= 0x0201)

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#8234: FILE: fs/udf/truncate.c:240:
+					offset + ((inode->i_size & (sb->s_blocksize-1)) != 0));
 					                                           ^

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "UDF_SB_PARTMAPS"
#8259: FILE: fs/udf/udf_sb.h:53:
+	if (UDF_SB_PARTMAPS(X) != NULL) {\

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "Z.s_bitmap"
#8275: FILE: fs/udf/udf_sb.h:71:
+	if (UDF_SB_PARTMAPS(X)[(Y)].Z.s_bitmap != NULL) {\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8480: FILE: fs/udf/udftime.c:62:
+/*1970*/ SPY( 0, 0,0), SPY( 1, 0,0), SPY( 2, 0,0), SPY( 3, 1,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8480: FILE: fs/udf/udftime.c:62:
+/*1970*/ SPY( 0, 0,0), SPY( 1, 0,0), SPY( 2, 0,0), SPY( 3, 1,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8480: FILE: fs/udf/udftime.c:62:
+/*1970*/ SPY( 0, 0,0), SPY( 1, 0,0), SPY( 2, 0,0), SPY( 3, 1,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8480: FILE: fs/udf/udftime.c:62:
+/*1970*/ SPY( 0, 0,0), SPY( 1, 0,0), SPY( 2, 0,0), SPY( 3, 1,0),
                                                             ^

ERROR:SPACING: space prohibited after that open parenthesis '('
#8480: FILE: fs/udf/udftime.c:62:
+/*1970*/ SPY( 0, 0,0), SPY( 1, 0,0), SPY( 2, 0,0), SPY( 3, 1,0),

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8481: FILE: fs/udf/udftime.c:63:
+/*1974*/ SPY( 4, 1,0), SPY( 5, 1,0), SPY( 6, 1,0), SPY( 7, 2,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8481: FILE: fs/udf/udftime.c:63:
+/*1974*/ SPY( 4, 1,0), SPY( 5, 1,0), SPY( 6, 1,0), SPY( 7, 2,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8481: FILE: fs/udf/udftime.c:63:
+/*1974*/ SPY( 4, 1,0), SPY( 5, 1,0), SPY( 6, 1,0), SPY( 7, 2,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8481: FILE: fs/udf/udftime.c:63:
+/*1974*/ SPY( 4, 1,0), SPY( 5, 1,0), SPY( 6, 1,0), SPY( 7, 2,0),
                                                             ^

ERROR:SPACING: space prohibited after that open parenthesis '('
#8481: FILE: fs/udf/udftime.c:63:
+/*1974*/ SPY( 4, 1,0), SPY( 5, 1,0), SPY( 6, 1,0), SPY( 7, 2,0),

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8482: FILE: fs/udf/udftime.c:64:
+/*1978*/ SPY( 8, 2,0), SPY( 9, 2,0), SPY(10, 2,0), SPY(11, 3,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8482: FILE: fs/udf/udftime.c:64:
+/*1978*/ SPY( 8, 2,0), SPY( 9, 2,0), SPY(10, 2,0), SPY(11, 3,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8482: FILE: fs/udf/udftime.c:64:
+/*1978*/ SPY( 8, 2,0), SPY( 9, 2,0), SPY(10, 2,0), SPY(11, 3,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8482: FILE: fs/udf/udftime.c:64:
+/*1978*/ SPY( 8, 2,0), SPY( 9, 2,0), SPY(10, 2,0), SPY(11, 3,0),
                                                             ^

ERROR:SPACING: space prohibited after that open parenthesis '('
#8482: FILE: fs/udf/udftime.c:64:
+/*1978*/ SPY( 8, 2,0), SPY( 9, 2,0), SPY(10, 2,0), SPY(11, 3,0),

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8483: FILE: fs/udf/udftime.c:65:
+/*1982*/ SPY(12, 3,0), SPY(13, 3,0), SPY(14, 3,0), SPY(15, 4,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8483: FILE: fs/udf/udftime.c:65:
+/*1982*/ SPY(12, 3,0), SPY(13, 3,0), SPY(14, 3,0), SPY(15, 4,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8483: FILE: fs/udf/udftime.c:65:
+/*1982*/ SPY(12, 3,0), SPY(13, 3,0), SPY(14, 3,0), SPY(15, 4,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8483: FILE: fs/udf/udftime.c:65:
+/*1982*/ SPY(12, 3,0), SPY(13, 3,0), SPY(14, 3,0), SPY(15, 4,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8484: FILE: fs/udf/udftime.c:66:
+/*1986*/ SPY(16, 4,0), SPY(17, 4,0), SPY(18, 4,0), SPY(19, 5,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8484: FILE: fs/udf/udftime.c:66:
+/*1986*/ SPY(16, 4,0), SPY(17, 4,0), SPY(18, 4,0), SPY(19, 5,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8484: FILE: fs/udf/udftime.c:66:
+/*1986*/ SPY(16, 4,0), SPY(17, 4,0), SPY(18, 4,0), SPY(19, 5,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8484: FILE: fs/udf/udftime.c:66:
+/*1986*/ SPY(16, 4,0), SPY(17, 4,0), SPY(18, 4,0), SPY(19, 5,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8485: FILE: fs/udf/udftime.c:67:
+/*1990*/ SPY(20, 5,0), SPY(21, 5,0), SPY(22, 5,0), SPY(23, 6,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8485: FILE: fs/udf/udftime.c:67:
+/*1990*/ SPY(20, 5,0), SPY(21, 5,0), SPY(22, 5,0), SPY(23, 6,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8485: FILE: fs/udf/udftime.c:67:
+/*1990*/ SPY(20, 5,0), SPY(21, 5,0), SPY(22, 5,0), SPY(23, 6,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8485: FILE: fs/udf/udftime.c:67:
+/*1990*/ SPY(20, 5,0), SPY(21, 5,0), SPY(22, 5,0), SPY(23, 6,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8486: FILE: fs/udf/udftime.c:68:
+/*1994*/ SPY(24, 6,0), SPY(25, 6,0), SPY(26, 6,0), SPY(27, 7,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8486: FILE: fs/udf/udftime.c:68:
+/*1994*/ SPY(24, 6,0), SPY(25, 6,0), SPY(26, 6,0), SPY(27, 7,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8486: FILE: fs/udf/udftime.c:68:
+/*1994*/ SPY(24, 6,0), SPY(25, 6,0), SPY(26, 6,0), SPY(27, 7,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8486: FILE: fs/udf/udftime.c:68:
+/*1994*/ SPY(24, 6,0), SPY(25, 6,0), SPY(26, 6,0), SPY(27, 7,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8487: FILE: fs/udf/udftime.c:69:
+/*1998*/ SPY(28, 7,0), SPY(29, 7,0), SPY(30, 7,0), SPY(31, 8,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8487: FILE: fs/udf/udftime.c:69:
+/*1998*/ SPY(28, 7,0), SPY(29, 7,0), SPY(30, 7,0), SPY(31, 8,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8487: FILE: fs/udf/udftime.c:69:
+/*1998*/ SPY(28, 7,0), SPY(29, 7,0), SPY(30, 7,0), SPY(31, 8,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8487: FILE: fs/udf/udftime.c:69:
+/*1998*/ SPY(28, 7,0), SPY(29, 7,0), SPY(30, 7,0), SPY(31, 8,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8488: FILE: fs/udf/udftime.c:70:
+/*2002*/ SPY(32, 8,0), SPY(33, 8,0), SPY(34, 8,0), SPY(35, 9,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8488: FILE: fs/udf/udftime.c:70:
+/*2002*/ SPY(32, 8,0), SPY(33, 8,0), SPY(34, 8,0), SPY(35, 9,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8488: FILE: fs/udf/udftime.c:70:
+/*2002*/ SPY(32, 8,0), SPY(33, 8,0), SPY(34, 8,0), SPY(35, 9,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8488: FILE: fs/udf/udftime.c:70:
+/*2002*/ SPY(32, 8,0), SPY(33, 8,0), SPY(34, 8,0), SPY(35, 9,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8489: FILE: fs/udf/udftime.c:71:
+/*2006*/ SPY(36, 9,0), SPY(37, 9,0), SPY(38, 9,0), SPY(39,10,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8489: FILE: fs/udf/udftime.c:71:
+/*2006*/ SPY(36, 9,0), SPY(37, 9,0), SPY(38, 9,0), SPY(39,10,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8489: FILE: fs/udf/udftime.c:71:
+/*2006*/ SPY(36, 9,0), SPY(37, 9,0), SPY(38, 9,0), SPY(39,10,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8489: FILE: fs/udf/udftime.c:71:
+/*2006*/ SPY(36, 9,0), SPY(37, 9,0), SPY(38, 9,0), SPY(39,10,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8489: FILE: fs/udf/udftime.c:71:
+/*2006*/ SPY(36, 9,0), SPY(37, 9,0), SPY(38, 9,0), SPY(39,10,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                                            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8490: FILE: fs/udf/udftime.c:72:
+/*2010*/ SPY(40,10,0), SPY(41,10,0), SPY(42,10,0), SPY(43,11,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                                            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8491: FILE: fs/udf/udftime.c:73:
+/*2014*/ SPY(44,11,0), SPY(45,11,0), SPY(46,11,0), SPY(47,12,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                                            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8492: FILE: fs/udf/udftime.c:74:
+/*2018*/ SPY(48,12,0), SPY(49,12,0), SPY(50,12,0), SPY(51,13,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                                            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8493: FILE: fs/udf/udftime.c:75:
+/*2022*/ SPY(52,13,0), SPY(53,13,0), SPY(54,13,0), SPY(55,14,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                                            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8494: FILE: fs/udf/udftime.c:76:
+/*2026*/ SPY(56,14,0), SPY(57,14,0), SPY(58,14,0), SPY(59,15,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                                            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8495: FILE: fs/udf/udftime.c:77:
+/*2030*/ SPY(60,15,0), SPY(61,15,0), SPY(62,15,0), SPY(63,16,0),
                                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                                 ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                                            ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#8496: FILE: fs/udf/udftime.c:78:
+/*2034*/ SPY(64,16,0), SPY(65,16,0), SPY(66,16,0), SPY(67,17,0),
                                                             ^

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#8506: FILE: fs/udf/udftime.c:87:
+time_t * udf_stamp_to_time(time_t *dest, long *dest_usec, kernel_timestamp src)

CHECK:SPACING: spaces preferred around that '+' (ctx:VxV)
#8529: FILE: fs/udf/udftime.c:104:
+	    (src.year >= EPOCH_YEAR+MAX_YEAR_SECONDS)) {
 	                           ^

ERROR:SPACING: space prohibited after that open parenthesis '('
#8540: FILE: fs/udf/udftime.c:114:
+	*dest += ( ( (yday * 24) + src.hour ) * 60 + src.minute ) * 60 + src.second;

ERROR:SPACING: space prohibited before that close parenthesis ')'
#8540: FILE: fs/udf/udftime.c:114:
+	*dest += ( ( (yday * 24) + src.hour ) * 60 + src.minute ) * 60 + src.second;

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#8548: FILE: fs/udf/udftime.c:120:
+kernel_timestamp * udf_time_to_stamp(kernel_timestamp *dest, struct timespec ts)

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#8565: FILE: fs/udf/udftime.c:150:
+			 + LEAPS_THRU_END_OF (yg - 1)

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#8566: FILE: fs/udf/udftime.c:151:
+			 - LEAPS_THRU_END_OF (y - 1));

CHECK:CAMELCASE: Avoid CamelCase: <hundredsOfMicroseconds>
#8575: FILE: fs/udf/udftime.c:165:
+			      dest->hundredsOfMicroseconds * 100);

CHECK:CAMELCASE: Avoid CamelCase: <u_cmpID>
#8613: FILE: fs/udf/unicode.c:57:
+	dest->u_cmpID = ptr[0];

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#8656: FILE: fs/udf/unicode.c:123:
+		printk(KERN_ERR "udf: unknown compression code (%d) stri=%s\n",

WARNING:BRACES: braces {} are not necessary for single statement blocks
#8776: FILE: fs/udf/unicode.c:235:
+		if (max_val == 0xffffU) {
 			ocu[++u_len] = (uint8_t)(utf_char >> 8);
 		}

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#8813: FILE: fs/udf/unicode.c:274:
+		printk(KERN_ERR "udf: unknown compression code (%d) stri=%s\n",

WARNING:BRACES: braces {} are not necessary for single statement blocks
#8862: FILE: fs/udf/unicode.c:331:
+	if (udf_build_ustr_exact(&unifilename, sname, flen)) {
 		return 0;
 	}

CHECK:CAMELCASE: Avoid CamelCase: <udf_CS0toNLS>
#8881: FILE: fs/udf/unicode.c:341:
+		if (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, &filename, &unifilename)) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#8896: FILE: fs/udf/unicode.c:351:
+	if (len) {
 		return len;
 	}

WARNING:BRACES: braces {} are not necessary for single statement blocks
#8909: FILE: fs/udf/unicode.c:363:
+	if (!(udf_char_to_ustr(&unifilename, sname, flen))) {
 		return 0;
 	}

CHECK:CAMELCASE: Avoid CamelCase: <udf_UTF8toCS0>
#8918: FILE: fs/udf/unicode.c:368:
+		namelen = udf_UTF8toCS0(dname, &unifilename, UDF_NAME_LEN);

WARNING:BRACES: braces {} are not necessary for single statement blocks
#8919: FILE: fs/udf/unicode.c:369:
+		if (!namelen) {
 			return 0;
 		}

CHECK:CAMELCASE: Avoid CamelCase: <udf_NLStoCS0>
#8928: FILE: fs/udf/unicode.c:373:
+		namelen = udf_NLStoCS0(UDF_SB(sb)->s_nls_map, dname, &unifilename, UDF_NAME_LEN);

WARNING:BRACES: braces {} are not necessary for single statement blocks
#8929: FILE: fs/udf/unicode.c:374:
+		if (!namelen) {
 			return 0;
 		}

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#8947: FILE: fs/udf/unicode.c:387:
+#define EXT_SIZE ^I^I5$

CHECK:CAMELCASE: Avoid CamelCase: <newName>
#8950: FILE: fs/udf/unicode.c:389:
+static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName, int udfLen,

CHECK:CAMELCASE: Avoid CamelCase: <udfName>
#8950: FILE: fs/udf/unicode.c:389:
+static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName, int udfLen,

CHECK:CAMELCASE: Avoid CamelCase: <udfLen>
#8950: FILE: fs/udf/unicode.c:389:
+static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName, int udfLen,

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8950: FILE: fs/udf/unicode.c:389:
+static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName, int udfLen,

CHECK:CAMELCASE: Avoid CamelCase: <fidName>
#8951: FILE: fs/udf/unicode.c:390:
+				  uint8_t *fidName, int fidNameLen)

CHECK:CAMELCASE: Avoid CamelCase: <fidNameLen>
#8951: FILE: fs/udf/unicode.c:390:
+				  uint8_t *fidName, int fidNameLen)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u8' over 'uint8_t'
#8951: FILE: fs/udf/unicode.c:390:
+				  uint8_t *fidName, int fidNameLen)

CHECK:CAMELCASE: Avoid CamelCase: <newIndex>
#8954: FILE: fs/udf/unicode.c:392:
+	int index, newIndex = 0, needsCRC = 0;

CHECK:CAMELCASE: Avoid CamelCase: <needsCRC>
#8954: FILE: fs/udf/unicode.c:392:
+	int index, newIndex = 0, needsCRC = 0;

ERROR:TRAILING_STATEMENTS: trailing statements should be on next line (or did you mean 'else if'?)
#8990: FILE: fs/udf/unicode.c:412:
+			} if (curr == EXT_MARK && (udfLen - index - 1) <= EXT_SIZE) {

Trailing statements (for example after any conditional) should be
on the next line.
Statements, such as::

  if (x == y) break;

should be::

  if (x == y)
          break;

CHECK:CAMELCASE: Avoid CamelCase: <hasExt>
#9011: FILE: fs/udf/unicode.c:431:
+		if (hasExt) {

ERROR:SPACING: space required before the open parenthesis '('
#9016: FILE: fs/udf/unicode.c:433:
+			for(index = 0; index < EXT_SIZE && extIndex + index + 1 < udfLen; index++) {

CHECK:CAMELCASE: Avoid CamelCase: <extIndex>
#9016: FILE: fs/udf/unicode.c:433:
+			for(index = 0; index < EXT_SIZE && extIndex + index + 1 < udfLen; index++) {

ERROR:SPACING: space required before the open parenthesis '('
#9027: FILE: fs/udf/unicode.c:439:
+					while(extIndex + index + 2 < udfLen &&

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#9029: FILE: fs/udf/unicode.c:441:
+					      (index + 1 < EXT_SIZE
+					       && (udfName[extIndex + index + 2] == '/' ||

CHECK:CAMELCASE: Avoid CamelCase: <localExtIndex>
#9043: FILE: fs/udf/unicode.c:464:
+			for (index = 0; index < localExtIndex; index++)

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000427522.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 198 errors, 111 warnings, 208 checks, 8539 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000427522.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
