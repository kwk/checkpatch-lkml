WARNING:TYPO_SPELLING: 'reenable' may be misspelled - perhaps 're-enable'?
#34: 
conditionally reenable interrupts explicitly, like x86_64.
              ^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'trapnr' - possible side-effects?
#51: FILE: arch/x86/kernel/traps_32.c:531:
+#define DO_TRAP(trapnr, signr, str, name)				\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	trace_hardirqs_fixup();						\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 0, regs, error_code, NULL);		\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'signr' - possible side-effects?
#51: FILE: arch/x86/kernel/traps_32.c:531:
+#define DO_TRAP(trapnr, signr, str, name)				\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	trace_hardirqs_fixup();						\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 0, regs, error_code, NULL);		\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'str' - possible side-effects?
#51: FILE: arch/x86/kernel/traps_32.c:531:
+#define DO_TRAP(trapnr, signr, str, name)				\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	trace_hardirqs_fixup();						\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 0, regs, error_code, NULL);		\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'trapnr' - possible side-effects?
#61: FILE: arch/x86/kernel/traps_32.c:541:
+#define DO_TRAP_INFO(trapnr, signr, str, name, sicode, siaddr, irq)	\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	siginfo_t info;							\
+	if (irq)							\
+		local_irq_enable();					\
+	info.si_signo = signr;						\
+	info.si_errno = 0;						\
+	info.si_code = sicode;						\
+	info.si_addr = (void __user *)siaddr;				\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 0, regs, error_code, &info);	\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'signr' - possible side-effects?
#61: FILE: arch/x86/kernel/traps_32.c:541:
+#define DO_TRAP_INFO(trapnr, signr, str, name, sicode, siaddr, irq)	\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	siginfo_t info;							\
+	if (irq)							\
+		local_irq_enable();					\
+	info.si_signo = signr;						\
+	info.si_errno = 0;						\
+	info.si_code = sicode;						\
+	info.si_addr = (void __user *)siaddr;				\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 0, regs, error_code, &info);	\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'str' - possible side-effects?
#61: FILE: arch/x86/kernel/traps_32.c:541:
+#define DO_TRAP_INFO(trapnr, signr, str, name, sicode, siaddr, irq)	\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	siginfo_t info;							\
+	if (irq)							\
+		local_irq_enable();					\
+	info.si_signo = signr;						\
+	info.si_errno = 0;						\
+	info.si_code = sicode;						\
+	info.si_addr = (void __user *)siaddr;				\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 0, regs, error_code, &info);	\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'trapnr' - possible side-effects?
#77: FILE: arch/x86/kernel/traps_32.c:557:
+#define DO_VM86_TRAP(trapnr, signr, str, name)				\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 1, regs, error_code, NULL);		\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'signr' - possible side-effects?
#77: FILE: arch/x86/kernel/traps_32.c:557:
+#define DO_VM86_TRAP(trapnr, signr, str, name)				\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 1, regs, error_code, NULL);		\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'str' - possible side-effects?
#77: FILE: arch/x86/kernel/traps_32.c:557:
+#define DO_VM86_TRAP(trapnr, signr, str, name)				\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 1, regs, error_code, NULL);		\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'trapnr' - possible side-effects?
#86: FILE: arch/x86/kernel/traps_32.c:566:
+#define DO_VM86_TRAP_INFO(trapnr, signr, str, name, sicode, siaddr)	\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	siginfo_t info;							\
+	info.si_signo = signr;						\
+	info.si_errno = 0;						\
+	info.si_code = sicode;						\
+	info.si_addr = (void __user *)siaddr;				\
+	trace_hardirqs_fixup();						\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 1, regs, error_code, &info);	\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'signr' - possible side-effects?
#86: FILE: arch/x86/kernel/traps_32.c:566:
+#define DO_VM86_TRAP_INFO(trapnr, signr, str, name, sicode, siaddr)	\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	siginfo_t info;							\
+	info.si_signo = signr;						\
+	info.si_errno = 0;						\
+	info.si_code = sicode;						\
+	info.si_addr = (void __user *)siaddr;				\
+	trace_hardirqs_fixup();						\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 1, regs, error_code, &info);	\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'str' - possible side-effects?
#86: FILE: arch/x86/kernel/traps_32.c:566:
+#define DO_VM86_TRAP_INFO(trapnr, signr, str, name, sicode, siaddr)	\
+void do_##name(struct pt_regs *regs, long error_code)			\
+{									\
+	siginfo_t info;							\
+	info.si_signo = signr;						\
+	info.si_errno = 0;						\
+	info.si_code = sicode;						\
+	info.si_addr = (void __user *)siaddr;				\
+	trace_hardirqs_fixup();						\
+	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
+							== NOTIFY_STOP)	\
+		return;							\
+	do_trap(trapnr, signr, str, 1, regs, error_code, &info);	\
+}

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000229613.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 0 errors, 1 warnings, 12 checks, 111 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000229613.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
