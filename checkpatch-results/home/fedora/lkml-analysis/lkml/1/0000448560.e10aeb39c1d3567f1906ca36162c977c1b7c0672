CHECK:MACRO_ARG_REUSE: Macro argument reuse '__rettype' - possible side-effects?
#77: FILE: include/asm-i386/paravirt.h:205:
+#define PVOP_CALL0(__rettype, __op)					\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__op' - possible side-effects?
#77: FILE: include/asm-i386/paravirt.h:205:
+#define PVOP_CALL0(__rettype, __op)					\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__rettype' - possible side-effects?
#111: FILE: include/asm-i386/paravirt.h:239:
+#define PVOP_CALL1(__rettype, __op, arg1)				\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__op' - possible side-effects?
#111: FILE: include/asm-i386/paravirt.h:239:
+#define PVOP_CALL1(__rettype, __op, arg1)				\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg1' - possible side-effects?
#111: FILE: include/asm-i386/paravirt.h:239:
+#define PVOP_CALL1(__rettype, __op, arg1)				\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__rettype' - possible side-effects?
#148: FILE: include/asm-i386/paravirt.h:276:
+#define PVOP_CALL2(__rettype, __op, arg1, arg2)				\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__op' - possible side-effects?
#148: FILE: include/asm-i386/paravirt.h:276:
+#define PVOP_CALL2(__rettype, __op, arg1, arg2)				\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg1' - possible side-effects?
#148: FILE: include/asm-i386/paravirt.h:276:
+#define PVOP_CALL2(__rettype, __op, arg1, arg2)				\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg2' - possible side-effects?
#148: FILE: include/asm-i386/paravirt.h:276:
+#define PVOP_CALL2(__rettype, __op, arg1, arg2)				\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__rettype' - possible side-effects?
#188: FILE: include/asm-i386/paravirt.h:316:
+#define PVOP_CALL3(__rettype, __op, arg1, arg2, arg3)			\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;	\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__op' - possible side-effects?
#188: FILE: include/asm-i386/paravirt.h:316:
+#define PVOP_CALL3(__rettype, __op, arg1, arg2, arg3)			\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;	\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg1' - possible side-effects?
#188: FILE: include/asm-i386/paravirt.h:316:
+#define PVOP_CALL3(__rettype, __op, arg1, arg2, arg3)			\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;	\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg2' - possible side-effects?
#188: FILE: include/asm-i386/paravirt.h:316:
+#define PVOP_CALL3(__rettype, __op, arg1, arg2, arg3)			\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;	\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg3' - possible side-effects?
#188: FILE: include/asm-i386/paravirt.h:316:
+#define PVOP_CALL3(__rettype, __op, arg1, arg2, arg3)			\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;	\
+			asm volatile(paravirt_alt(PARAVIRT_CALL)	\
+				     : "=a" (__tmp), "=d" (__edx),	\
+				       "=c" (__ecx)			\
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__rettype' - possible side-effects?
#231: FILE: include/asm-i386/paravirt.h:359:
+#define PVOP_CALL4(__rettype, __op, arg1, arg2, arg3, arg4)		\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       [_arg4] "mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc",);		\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=a" (__tmp), "=d" (__edx), "=c" (__ecx) \
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       [_arg4]"mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse '__op' - possible side-effects?
#231: FILE: include/asm-i386/paravirt.h:359:
+#define PVOP_CALL4(__rettype, __op, arg1, arg2, arg3, arg4)		\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       [_arg4] "mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc",);		\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=a" (__tmp), "=d" (__edx), "=c" (__ecx) \
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       [_arg4]"mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg1' - possible side-effects?
#231: FILE: include/asm-i386/paravirt.h:359:
+#define PVOP_CALL4(__rettype, __op, arg1, arg2, arg3, arg4)		\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       [_arg4] "mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc",);		\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=a" (__tmp), "=d" (__edx), "=c" (__ecx) \
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       [_arg4]"mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg2' - possible side-effects?
#231: FILE: include/asm-i386/paravirt.h:359:
+#define PVOP_CALL4(__rettype, __op, arg1, arg2, arg3, arg4)		\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       [_arg4] "mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc",);		\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=a" (__tmp), "=d" (__edx), "=c" (__ecx) \
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       [_arg4]"mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg3' - possible side-effects?
#231: FILE: include/asm-i386/paravirt.h:359:
+#define PVOP_CALL4(__rettype, __op, arg1, arg2, arg3, arg4)		\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       [_arg4] "mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc",);		\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=a" (__tmp), "=d" (__edx), "=c" (__ecx) \
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       [_arg4]"mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'arg4' - possible side-effects?
#231: FILE: include/asm-i386/paravirt.h:359:
+#define PVOP_CALL4(__rettype, __op, arg1, arg2, arg3, arg4)		\
+	({								\
+		__rettype __ret;					\
+		if (sizeof(__rettype) > sizeof(unsigned long)) {	\
+			unsigned long long __tmp;			\
+			unsigned long __ecx;				\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=A" (__tmp), "=c" (__ecx)	\
+				     : "a" ((u32)(arg1)),		\
+				       "d" ((u32)(arg2)),		\
+				       "1" ((u32)(arg3)),		\
+				       [_arg4] "mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc",);		\
+			__ret = (__rettype)__tmp;			\
+		} else {						\
+			unsigned long __tmp, __edx, __ecx;		\
+			asm volatile("push %[_arg4]; "			\
+				     paravirt_alt(PARAVIRT_CALL)	\
+				     "lea 4(%%esp),%%esp"		\
+				     : "=a" (__tmp), "=d" (__edx), "=c" (__ecx) \
+				     : "0" ((u32)(arg1)),		\
+				       "1" ((u32)(arg2)),		\
+				       "2" ((u32)(arg3)),		\
+				       [_arg4]"mr" ((u32)(arg4)),	\
+				       paravirt_type(__op),		\
+				       paravirt_clobber(CLBR_ANY)	\
+				     : "memory", "cc");			\
+			__ret = (__rettype)__tmp;			\
+		}							\
+		__ret;							\
+	})

ERROR:SPACING: space required after that ',' (ctx:VxB)
#247: FILE: include/asm-i386/paravirt.h:375:
+				     : "memory", "cc",);		\
 				                     ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#342: FILE: include/asm-i386/paravirt.h:451:
+}
+#define get_debugreg(var, reg) var = paravirt_get_debugreg(reg)

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:COMPLEX_MACRO: Macros with complex values should be enclosed in parentheses
#342: FILE: include/asm-i386/paravirt.h:451:
+#define get_debugreg(var, reg) var = paravirt_get_debugreg(reg)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#387: FILE: include/asm-i386/paravirt.h:496:
+}
+static inline unsigned long read_cr4_safe(void)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#418: FILE: include/asm-i386/paravirt.h:523:
+static inline u64 paravirt_read_msr(unsigned msr, int *err)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#422: FILE: include/asm-i386/paravirt.h:527:
+}
+static inline int paravirt_write_msr(unsigned msr, unsigned low, unsigned high)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#422: FILE: include/asm-i386/paravirt.h:527:
+static inline int paravirt_write_msr(unsigned msr, unsigned low, unsigned high)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#422: FILE: include/asm-i386/paravirt.h:527:
+static inline int paravirt_write_msr(unsigned msr, unsigned low, unsigned high)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#422: FILE: include/asm-i386/paravirt.h:527:
+static inline int paravirt_write_msr(unsigned msr, unsigned low, unsigned high)

ERROR:SPACING: space required after that ',' (ctx:VxV)
#433: FILE: include/asm-i386/paravirt.h:533:
+#define rdmsr(msr,val1,val2) do {		\
                  ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#433: FILE: include/asm-i386/paravirt.h:533:
+#define rdmsr(msr,val1,val2) do {		\
                       ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#443: FILE: include/asm-i386/paravirt.h:540:
+#define wrmsr(msr,val1,val2) do {		\
                  ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#443: FILE: include/asm-i386/paravirt.h:540:
+#define wrmsr(msr,val1,val2) do {		\
                       ^

WARNING:SINGLE_STATEMENT_DO_WHILE_MACRO: Single statement macros should not use a do {} while (0) loop
#443: FILE: include/asm-i386/paravirt.h:540:
+#define wrmsr(msr,val1,val2) do {		\
+	paravirt_write_msr(msr, val1, val2);	\
 } while(0)

For the multi-statement macros, it is necessary to use the do-while
loop to avoid unpredictable code paths. The do-while loop helps to
group the multiple statements into a single one so that a
function-like macro can be used as a function only.

But for the single statement macros, it is unnecessary to use the
do-while loop. Although the code is syntactically correct but using
the do-while loop is redundant. So remove the do-while loop for single
statement macros.

ERROR:SPACING: space required after that ',' (ctx:VxV)
#450: FILE: include/asm-i386/paravirt.h:544:
+#define rdmsrl(msr,val) do {			\
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#460: FILE: include/asm-i386/paravirt.h:549:
+#define wrmsrl(msr,val)		((void)paravirt_write_msr(msr, val, 0))
                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#461: FILE: include/asm-i386/paravirt.h:550:
+#define wrmsr_safe(msr,a,b)	paravirt_write_msr(msr, a, b)
                       ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#461: FILE: include/asm-i386/paravirt.h:550:
+#define wrmsr_safe(msr,a,b)	paravirt_write_msr(msr, a, b)
                         ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#469: FILE: include/asm-i386/paravirt.h:553:
+#define rdmsr_safe(msr,a,b) ({			\
                       ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#469: FILE: include/asm-i386/paravirt.h:553:
+#define rdmsr_safe(msr,a,b) ({			\
                         ^

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'a' may be better as '(a)' to avoid precedence issues
#469: FILE: include/asm-i386/paravirt.h:553:
+#define rdmsr_safe(msr,a,b) ({			\
+	int _err;				\
+	u64 _l = paravirt_read_msr(msr, &_err);	\
+	(*a) = (u32)_l;				\
+	(*b) = _l >> 32;			\
 	_err; })

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'b' may be better as '(b)' to avoid precedence issues
#469: FILE: include/asm-i386/paravirt.h:553:
+#define rdmsr_safe(msr,a,b) ({			\
+	int _err;				\
+	u64 _l = paravirt_read_msr(msr, &_err);	\
+	(*a) = (u32)_l;				\
+	(*b) = _l >> 32;			\
 	_err; })

CHECK:LINE_SPACING: Please don't use multiple blank lines
#480: FILE: include/asm-i386/paravirt.h:560:
 
+

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#485: FILE: include/asm-i386/paravirt.h:565:
+}
+#define rdtsc(low,high) do {			\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#485: FILE: include/asm-i386/paravirt.h:565:
+#define rdtsc(low,high) do {			\
                  ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#516: FILE: include/asm-i386/paravirt.h:588:
+#define rdpmc(counter,low,high) do {		\
                      ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#516: FILE: include/asm-i386/paravirt.h:588:
+#define rdpmc(counter,low,high) do {		\
                          ^

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#552: FILE: include/asm-i386/paravirt.h:598:
+}
+static inline void load_gdt(const struct Xgt_desc_struct *dtr)

CHECK:CAMELCASE: Avoid CamelCase: <Xgt_desc_struct>
#552: FILE: include/asm-i386/paravirt.h:598:
+static inline void load_gdt(const struct Xgt_desc_struct *dtr)

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#556: FILE: include/asm-i386/paravirt.h:602:
+}
+static inline void load_idt(const struct Xgt_desc_struct *dtr)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#560: FILE: include/asm-i386/paravirt.h:606:
+}
+static inline void set_ldt(const void *addr, unsigned entries)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#560: FILE: include/asm-i386/paravirt.h:606:
+static inline void set_ldt(const void *addr, unsigned entries)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#564: FILE: include/asm-i386/paravirt.h:610:
+}
+static inline void store_gdt(struct Xgt_desc_struct *dtr)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#568: FILE: include/asm-i386/paravirt.h:614:
+}
+static inline void store_idt(struct Xgt_desc_struct *dtr)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#572: FILE: include/asm-i386/paravirt.h:618:
+}
+static inline unsigned long paravirt_store_tr(void)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#576: FILE: include/asm-i386/paravirt.h:622:
+}
+#define store_tr(tr)	((tr) = paravirt_store_tr())

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#577: FILE: include/asm-i386/paravirt.h:623:
+static inline void load_TLS(struct thread_struct *t, unsigned cpu)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#581: FILE: include/asm-i386/paravirt.h:627:
+}
+static inline void write_ldt_entry(void *dt, int entry, u32 low, u32 high)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#585: FILE: include/asm-i386/paravirt.h:631:
+}
+static inline void write_gdt_entry(void *dt, int entry, u32 low, u32 high)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#589: FILE: include/asm-i386/paravirt.h:635:
+}
+static inline void write_idt_entry(void *dt, int entry, u32 low, u32 high)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#593: FILE: include/asm-i386/paravirt.h:639:
+}
+static inline void set_iopl_mask(unsigned mask)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#593: FILE: include/asm-i386/paravirt.h:639:
+static inline void set_iopl_mask(unsigned mask)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#681: FILE: include/asm-i386/paravirt.h:725:
+}
+static inline void __flush_tlb_global(void)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#685: FILE: include/asm-i386/paravirt.h:729:
+}
+static inline void __flush_tlb_single(unsigned long addr)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#695: FILE: include/asm-i386/paravirt.h:739:
+static inline void paravirt_alloc_pt(unsigned pfn)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#699: FILE: include/asm-i386/paravirt.h:743:
+}
+static inline void paravirt_release_pt(unsigned pfn)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#699: FILE: include/asm-i386/paravirt.h:743:
+static inline void paravirt_release_pt(unsigned pfn)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#704: FILE: include/asm-i386/paravirt.h:748:
+static inline void paravirt_alloc_pd(unsigned pfn)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#709: FILE: include/asm-i386/paravirt.h:753:
+static inline void paravirt_alloc_pd_clone(unsigned pfn, unsigned clonepfn,

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#709: FILE: include/asm-i386/paravirt.h:753:
+static inline void paravirt_alloc_pd_clone(unsigned pfn, unsigned clonepfn,

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#710: FILE: include/asm-i386/paravirt.h:754:
+					   unsigned start, unsigned count)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#710: FILE: include/asm-i386/paravirt.h:754:
+					   unsigned start, unsigned count)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#714: FILE: include/asm-i386/paravirt.h:758:
+}
+static inline void paravirt_release_pd(unsigned pfn)

WARNING:UNSPECIFIED_INT: Prefer 'unsigned int' to bare use of 'unsigned'
#714: FILE: include/asm-i386/paravirt.h:758:
+static inline void paravirt_release_pd(unsigned pfn)

WARNING:LINE_SPACING: Missing a blank line after declarations
#839: FILE: include/asm-i386/paravirt.h:855:
+	unsigned long long val = PVOP_CALL1(unsigned long long, ptep_get_and_clear, p);
+	return (pte_t) { val, val >> 32 };

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#896: FILE: include/asm-i386/paravirt.h:910:
+}
+static inline void arch_leave_lazy_cpu_mode(void)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#908: FILE: include/asm-i386/paravirt.h:920:
+}
+static inline void arch_leave_lazy_mmu_mode(void)

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000448560.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 15 errors, 17 warnings, 45 checks, 874 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000448560.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
