WARNING:FILE_PATH_CHANGES: added, moved or deleted file(s), does MAINTAINERS need updating?
#83: 
new file mode 100644

Whenever files are added, moved, or deleted, the MAINTAINERS file
patterns can be out of sync or outdated.

So MAINTAINERS might need updating in these cases.

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#88: FILE: include/trace/ftrace.h:1:
+/*

The source file is missing or has an improper SPDX identifier tag.
The Linux kernel requires the precise SPDX identifier in all source files,
and it is thoroughly documented in the kernel docs.

See: https://www.kernel.org/doc/html/latest/process/license-rules.html

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#112: FILE: include/trace/ftrace.h:25:
+#define __array(type, item, len)	type	item[len];

Macros with multiple statements should be enclosed in a
do - while block.  Same should also be the case for macros
starting with `if` to avoid logic defects::

  #define macrofun(a, b, c)                 \
    do {                                    \
            if (a == 5)                     \
                    do_this(b, c);          \
    } while (0)

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#macros-enums-and-rtl

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#112: FILE: include/trace/ftrace.h:25:
+#define __array(type, item, len)	type	item[len];

Macro definition should not end with a semicolon. The macro
invocation style should be consistent with function calls.
This can prevent any unexpected code paths::

  #define MAC do_something;

If this macro is used within a if else statement, like::

  if (some_condition)
          MAC;

  else
          do_something;

Then there would be a compilation error, because when the macro is
expanded there are two trailing semicolons, so the else branch gets
orphaned.

See: https://lore.kernel.org/lkml/1399671106.2912.21.camel@joe-AO725/

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#115: FILE: include/trace/ftrace.h:28:
+#define __field(type, item)		type	item;

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#115: FILE: include/trace/ftrace.h:28:
+#define __field(type, item)		type	item;

ERROR:TRAILING_WHITESPACE: trailing whitespace
#195: FILE: include/trace/ftrace.h:108:
+^I$

Trailing whitespace should always be removed.
Some editors highlight the trailing whitespace and cause visual
distractions when editing files.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#219: FILE: include/trace/ftrace.h:132:
+#define __field(type, item)					\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item ";\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'item' - possible side-effects?
#219: FILE: include/trace/ftrace.h:132:
+#define __field(type, item)					\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item ";\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

WARNING:MACRO_WITH_FLOW_CONTROL: Macros with flow control statements should be avoided
#219: FILE: include/trace/ftrace.h:132:
+#define __field(type, item)					\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item ";\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#219: FILE: include/trace/ftrace.h:132:
+#define __field(type, item)					\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item ";\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#228: FILE: include/trace/ftrace.h:141:
+#define __array(type, item, len)						\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item "[" #len "];\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'item' - possible side-effects?
#228: FILE: include/trace/ftrace.h:141:
+#define __array(type, item, len)						\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item "[" #len "];\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

WARNING:MACRO_WITH_FLOW_CONTROL: Macros with flow control statements should be avoided
#228: FILE: include/trace/ftrace.h:141:
+#define __array(type, item, len)						\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item "[" #len "];\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#228: FILE: include/trace/ftrace.h:141:
+#define __array(type, item, len)						\
+	ret = trace_seq_printf(s, "\tfield:" #type " " #item "[" #len "];\t"	\
+			       "offset:%u;\tsize:%u;\n",		\
+			       (unsigned int)offsetof(typeof(field), item), \
+			       (unsigned int)sizeof(field.item));	\
+	if (!ret)							\
+		return 0;

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#263: FILE: include/trace/ftrace.h:176:
+#define __field(type, item)						\
+	ret = trace_define_field(event_call, #type, #item,		\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'item' - possible side-effects?
#263: FILE: include/trace/ftrace.h:176:
+#define __field(type, item)						\
+	ret = trace_define_field(event_call, #type, #item,		\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

WARNING:MACRO_WITH_FLOW_CONTROL: Macros with flow control statements should be avoided
#263: FILE: include/trace/ftrace.h:176:
+#define __field(type, item)						\
+	ret = trace_define_field(event_call, #type, #item,		\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#263: FILE: include/trace/ftrace.h:176:
+#define __field(type, item)						\
+	ret = trace_define_field(event_call, #type, #item,		\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros with multiple statements should be enclosed in a do - while loop
#271: FILE: include/trace/ftrace.h:184:
+#define __array(type, item, len)					\
+	BUILD_BUG_ON(len > MAX_FILTER_STR_VAL);				\
+	ret = trace_define_field(event_call, #type "[" #len "]", #item,	\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'item' - possible side-effects?
#271: FILE: include/trace/ftrace.h:184:
+#define __array(type, item, len)					\
+	BUILD_BUG_ON(len > MAX_FILTER_STR_VAL);				\
+	ret = trace_define_field(event_call, #type "[" #len "]", #item,	\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'len' may be better as '(len)' to avoid precedence issues
#271: FILE: include/trace/ftrace.h:184:
+#define __array(type, item, len)					\
+	BUILD_BUG_ON(len > MAX_FILTER_STR_VAL);				\
+	ret = trace_define_field(event_call, #type "[" #len "]", #item,	\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

WARNING:MACRO_WITH_FLOW_CONTROL: Macros with flow control statements should be avoided
#271: FILE: include/trace/ftrace.h:184:
+#define __array(type, item, len)					\
+	BUILD_BUG_ON(len > MAX_FILTER_STR_VAL);				\
+	ret = trace_define_field(event_call, #type "[" #len "]", #item,	\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#271: FILE: include/trace/ftrace.h:184:
+#define __array(type, item, len)					\
+	BUILD_BUG_ON(len > MAX_FILTER_STR_VAL);				\
+	ret = trace_define_field(event_call, #type "[" #len "]", #item,	\
+				 offsetof(typeof(field), item),		\
+				 sizeof(field.item));			\
+	if (ret)							\
+		return ret;

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __aligned(4) over __attribute__((__aligned__(4)))
#330: FILE: include/trace/ftrace.h:243:
+ * __attribute__((__aligned__(4)))

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __section("_ftrace_events") over __attribute__((section("_ftrace_events")))
#331: FILE: include/trace/ftrace.h:244:
+ * __attribute__((section("_ftrace_events"))) event_<call> = {

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __aligned(4) over __attribute__((__aligned__(4)))
#397: FILE: include/trace/ftrace.h:310:
+ * __attribute__((__aligned__(4)))

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __section("_ftrace_events") over __attribute__((section("_ftrace_events")))
#398: FILE: include/trace/ftrace.h:311:
+ * __attribute__((section("_ftrace_events"))) event_<call> = {

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'call' - possible side-effects?
#413: FILE: include/trace/ftrace.h:326:
+#define _TRACE_PROFILE(call, proto, args)				\
+static void ftrace_profile_##call(proto)				\
+{									\
+	extern void perf_tpcounter_event(int);				\
+	perf_tpcounter_event(event_##call.id);				\
+}									\
+									\
+static int ftrace_profile_enable_##call(struct ftrace_event_call *call) \
+{									\
+	int ret = 0;							\
+									\
+	if (!atomic_inc_return(&call->profile_count))			\
+		ret = register_trace_##call(ftrace_profile_##call);	\
+									\
+	return ret;							\
+}									\
+									\
+static void ftrace_profile_disable_##call(struct ftrace_event_call *call) \
+{									\
+	if (atomic_add_negative(-1, &call->profile_count))		\
+		unregister_trace_##call(ftrace_profile_##call);		\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'call' may be better as '(call)' to avoid precedence issues
#413: FILE: include/trace/ftrace.h:326:
+#define _TRACE_PROFILE(call, proto, args)				\
+static void ftrace_profile_##call(proto)				\
+{									\
+	extern void perf_tpcounter_event(int);				\
+	perf_tpcounter_event(event_##call.id);				\
+}									\
+									\
+static int ftrace_profile_enable_##call(struct ftrace_event_call *call) \
+{									\
+	int ret = 0;							\
+									\
+	if (!atomic_inc_return(&call->profile_count))			\
+		ret = register_trace_##call(ftrace_profile_##call);	\
+									\
+	return ret;							\
+}									\
+									\
+static void ftrace_profile_disable_##call(struct ftrace_event_call *call) \
+{									\
+	if (atomic_add_negative(-1, &call->profile_count))		\
+		unregister_trace_##call(ftrace_profile_##call);		\
+}

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#416: FILE: include/trace/ftrace.h:329:
+	extern void perf_tpcounter_event(int);				\

Function prototypes don't need to be declared extern in .h
files.  It's assumed by the compiler and is unnecessary.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'int' should also have an identifier name
#416: FILE: include/trace/ftrace.h:329:
+	extern void perf_tpcounter_event(int);				\

This warning is emitted due to any of the following reasons:

  1. Arguments for the function declaration do not follow
     the identifier name.  Example::

       void foo
       (int bar, int baz)

     This should be corrected to::

       void foo(int bar, int baz)

  2. Some arguments for the function definition do not
     have an identifier name.  Example::

       void foo(int)

     All arguments should have identifier names.

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'call' - possible side-effects?
#482: FILE: include/trace/ftrace.h:395:
+#define TRACE_FORMAT(call, proto, args, fmt)				\
+_TRACE_FORMAT(call, PARAMS(proto), PARAMS(args), PARAMS(fmt))		\
+_TRACE_PROFILE(call, PARAMS(proto), PARAMS(args))			\
+static struct ftrace_event_call __used					\
+__attribute__((__aligned__(4)))						\
+__attribute__((section("_ftrace_events"))) event_##call = {		\
+	.name			= #call,				\
+	.system			= __stringify(TRACE_SYSTEM),		\
+	.raw_init		= ftrace_init_event_##call,		\
+	.regfunc		= ftrace_reg_event_##call,		\
+	.unregfunc		= ftrace_unreg_event_##call,		\
+	_TRACE_PROFILE_INIT(call)					\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'proto' - possible side-effects?
#482: FILE: include/trace/ftrace.h:395:
+#define TRACE_FORMAT(call, proto, args, fmt)				\
+_TRACE_FORMAT(call, PARAMS(proto), PARAMS(args), PARAMS(fmt))		\
+_TRACE_PROFILE(call, PARAMS(proto), PARAMS(args))			\
+static struct ftrace_event_call __used					\
+__attribute__((__aligned__(4)))						\
+__attribute__((section("_ftrace_events"))) event_##call = {		\
+	.name			= #call,				\
+	.system			= __stringify(TRACE_SYSTEM),		\
+	.raw_init		= ftrace_init_event_##call,		\
+	.regfunc		= ftrace_reg_event_##call,		\
+	.unregfunc		= ftrace_unreg_event_##call,		\
+	_TRACE_PROFILE_INIT(call)					\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'args' - possible side-effects?
#482: FILE: include/trace/ftrace.h:395:
+#define TRACE_FORMAT(call, proto, args, fmt)				\
+_TRACE_FORMAT(call, PARAMS(proto), PARAMS(args), PARAMS(fmt))		\
+_TRACE_PROFILE(call, PARAMS(proto), PARAMS(args))			\
+static struct ftrace_event_call __used					\
+__attribute__((__aligned__(4)))						\
+__attribute__((section("_ftrace_events"))) event_##call = {		\
+	.name			= #call,				\
+	.system			= __stringify(TRACE_SYSTEM),		\
+	.raw_init		= ftrace_init_event_##call,		\
+	.regfunc		= ftrace_reg_event_##call,		\
+	.unregfunc		= ftrace_unreg_event_##call,		\
+	_TRACE_PROFILE_INIT(call)					\
+}

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __aligned(4) over __attribute__((__aligned__(4)))
#486: FILE: include/trace/ftrace.h:399:
+__attribute__((__aligned__(4)))						\

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __section("_ftrace_events") over __attribute__((section("_ftrace_events")))
#487: FILE: include/trace/ftrace.h:400:
+__attribute__((section("_ftrace_events"))) event_##call = {		\

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'call' - possible side-effects?
#500: FILE: include/trace/ftrace.h:413:
+#define TRACE_EVENT(call, proto, args, tstruct, assign, print)		\
+_TRACE_PROFILE(call, PARAMS(proto), PARAMS(args))			\
+									\
+static struct ftrace_event_call event_##call;				\
+									\
+static void ftrace_raw_event_##call(proto)				\
+{									\
+	struct ftrace_event_call *call = &event_##call;			\
+	struct ring_buffer_event *event;				\
+	struct ftrace_raw_##call *entry;				\
+	unsigned long irq_flags;					\
+	int pc;								\
+									\
+	local_save_flags(irq_flags);					\
+	pc = preempt_count();						\
+									\
+	event = trace_current_buffer_lock_reserve(event_##call.id,	\
+				  sizeof(struct ftrace_raw_##call),	\
+				  irq_flags, pc);			\
+	if (!event)							\
+		return;							\
+	entry	= ring_buffer_event_data(event);			\
+									\
+	assign;								\
+									\
+	if (!filter_current_check_discard(call, entry, event))		\
+		trace_nowake_buffer_unlock_commit(event, irq_flags, pc); \
+}									\
+									\
+static int ftrace_raw_reg_event_##call(void)				\
+{									\
+	int ret;							\
+									\
+	ret = register_trace_##call(ftrace_raw_event_##call);		\
+	if (ret)							\
+		pr_info("event trace: Could not activate trace point "	\
+			"probe to " #call "\n");			\
+	return ret;							\
+}									\
+									\
+static void ftrace_raw_unreg_event_##call(void)				\
+{									\
+	unregister_trace_##call(ftrace_raw_event_##call);		\
+}									\
+									\
+static struct trace_event ftrace_event_type_##call = {			\
+	.trace			= ftrace_raw_output_##call,		\
+};									\
+									\
+static int ftrace_raw_init_event_##call(void)				\
+{									\
+	int id;								\
+									\
+	id = register_ftrace_event(&ftrace_event_type_##call);		\
+	if (!id)							\
+		return -ENODEV;						\
+	event_##call.id = id;						\
+	INIT_LIST_HEAD(&event_##call.fields);				\
+	init_preds(&event_##call);					\
+	return 0;							\
+}									\
+									\
+static struct ftrace_event_call __used					\
+__attribute__((__aligned__(4)))						\
+__attribute__((section("_ftrace_events"))) event_##call = {		\
+	.name			= #call,				\
+	.system			= __stringify(TRACE_SYSTEM),		\
+	.raw_init		= ftrace_raw_init_event_##call,		\
+	.regfunc		= ftrace_raw_reg_event_##call,		\
+	.unregfunc		= ftrace_raw_unreg_event_##call,	\
+	.show_format		= ftrace_format_##call,			\
+	.define_fields		= ftrace_define_fields_##call,		\
+	_TRACE_PROFILE_INIT(call)					\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'proto' - possible side-effects?
#500: FILE: include/trace/ftrace.h:413:
+#define TRACE_EVENT(call, proto, args, tstruct, assign, print)		\
+_TRACE_PROFILE(call, PARAMS(proto), PARAMS(args))			\
+									\
+static struct ftrace_event_call event_##call;				\
+									\
+static void ftrace_raw_event_##call(proto)				\
+{									\
+	struct ftrace_event_call *call = &event_##call;			\
+	struct ring_buffer_event *event;				\
+	struct ftrace_raw_##call *entry;				\
+	unsigned long irq_flags;					\
+	int pc;								\
+									\
+	local_save_flags(irq_flags);					\
+	pc = preempt_count();						\
+									\
+	event = trace_current_buffer_lock_reserve(event_##call.id,	\
+				  sizeof(struct ftrace_raw_##call),	\
+				  irq_flags, pc);			\
+	if (!event)							\
+		return;							\
+	entry	= ring_buffer_event_data(event);			\
+									\
+	assign;								\
+									\
+	if (!filter_current_check_discard(call, entry, event))		\
+		trace_nowake_buffer_unlock_commit(event, irq_flags, pc); \
+}									\
+									\
+static int ftrace_raw_reg_event_##call(void)				\
+{									\
+	int ret;							\
+									\
+	ret = register_trace_##call(ftrace_raw_event_##call);		\
+	if (ret)							\
+		pr_info("event trace: Could not activate trace point "	\
+			"probe to " #call "\n");			\
+	return ret;							\
+}									\
+									\
+static void ftrace_raw_unreg_event_##call(void)				\
+{									\
+	unregister_trace_##call(ftrace_raw_event_##call);		\
+}									\
+									\
+static struct trace_event ftrace_event_type_##call = {			\
+	.trace			= ftrace_raw_output_##call,		\
+};									\
+									\
+static int ftrace_raw_init_event_##call(void)				\
+{									\
+	int id;								\
+									\
+	id = register_ftrace_event(&ftrace_event_type_##call);		\
+	if (!id)							\
+		return -ENODEV;						\
+	event_##call.id = id;						\
+	INIT_LIST_HEAD(&event_##call.fields);				\
+	init_preds(&event_##call);					\
+	return 0;							\
+}									\
+									\
+static struct ftrace_event_call __used					\
+__attribute__((__aligned__(4)))						\
+__attribute__((section("_ftrace_events"))) event_##call = {		\
+	.name			= #call,				\
+	.system			= __stringify(TRACE_SYSTEM),		\
+	.raw_init		= ftrace_raw_init_event_##call,		\
+	.regfunc		= ftrace_raw_reg_event_##call,		\
+	.unregfunc		= ftrace_raw_unreg_event_##call,	\
+	.show_format		= ftrace_format_##call,			\
+	.define_fields		= ftrace_define_fields_##call,		\
+	_TRACE_PROFILE_INIT(call)					\
+}

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __aligned(4) over __attribute__((__aligned__(4)))
#563: FILE: include/trace/ftrace.h:476:
+__attribute__((__aligned__(4)))						\

WARNING:PREFER_DEFINED_ATTRIBUTE_MACRO: Prefer __section("_ftrace_events") over __attribute__((section("_ftrace_events")))
#564: FILE: include/trace/ftrace.h:477:
+__attribute__((section("_ftrace_events"))) event_##call = {		\

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000139573.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 7 errors, 21 warnings, 13 checks, 509 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000139573.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
