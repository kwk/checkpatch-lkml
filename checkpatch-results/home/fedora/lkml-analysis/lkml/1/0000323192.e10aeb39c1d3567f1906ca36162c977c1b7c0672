WARNING:TYPO_SPELLING: 'didnt' may be misspelled - perhaps 'didn't'?
#51: 
no, they were not lost, they just didnt pass QA here (they crashed on a 
                                  ^^^^^

Some words may have been misspelled.  Consider reviewing them.

WARNING:TYPO_SPELLING: 'refure' may be misspelled - perhaps 'refuse'?
#87: 
      sched: rt-group: refure unrunnable tasks
                       ^^^^^^

WARNING:TYPO_SPELLING: 'synchonised' may be misspelled - perhaps 'synchronised'?
#88: 
      sched: rt-group: synchonised bandwidth period
                       ^^^^^^^^^^^

WARNING:FILE_PATH_CHANGES: added, moved or deleted file(s), does MAINTAINERS need updating?
#121: 
new file mode 100644

Whenever files are added, moved, or deleted, the MAINTAINERS file
patterns can be out of sync or outdated.

So MAINTAINERS might need updating in these cases.

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#207: FILE: include/linux/hardirq.h:113:
+extern void rcu_irq_enter(void);

Function prototypes don't need to be declared extern in .h
files.  It's assumed by the compiler and is unnecessary.

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#208: FILE: include/linux/hardirq.h:114:
+extern void rcu_irq_exit(void);

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#242: FILE: include/linux/init_task.h:155:
+^I^I.group_node ^I= LIST_HEAD_INIT(tsk.se.group_node),^I\$

WARNING:MEMORY_BARRIER: memory barrier without comment
#275: FILE: include/linux/rcupreempt.h:92:
+	mb();

WARNING:MEMORY_BARRIER: memory barrier without comment
#280: FILE: include/linux/rcupreempt.h:97:
+	mb();

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#344: FILE: include/linux/sched.h:1557:
+		struct file *filp, void __user *buffer, size_t *lenp,
 		             ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#344: FILE: include/linux/sched.h:1557:
+int sched_rt_handler(struct ctl_table *table, int write,
+		struct file *filp, void __user *buffer, size_t *lenp,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#367: FILE: include/linux/sched.h:2046:
+extern int sched_group_set_rt_runtime(struct task_group *tg,

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#369: FILE: include/linux/sched.h:2048:
+extern long sched_group_rt_runtime(struct task_group *tg);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#370: FILE: include/linux/sched.h:2049:
+extern int sched_group_set_rt_period(struct task_group *tg,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#371: FILE: include/linux/sched.h:2050:
+extern int sched_group_set_rt_period(struct task_group *tg,
+				      long rt_period_us);

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#372: FILE: include/linux/sched.h:2051:
+extern long sched_group_rt_period(struct task_group *tg);

WARNING:CONFIG_DESCRIPTION: please write a help paragraph that fully describes the config symbol
#387: FILE: init/Kconfig:314:
+config GROUP_SCHED
+	bool "Group CPU scheduler"
 	default y
 	help
 	  This feature lets CPU scheduler recognize task groups and control CPU
 	  bandwidth allocation to such task groups.
 

Kconfig symbols should have a help text which fully describes
it.

WARNING:CONFIG_DESCRIPTION: please write a help paragraph that fully describes the config symbol
#394: FILE: init/Kconfig:321:
+config FAIR_GROUP_SCHED
+	bool "Group scheduling for SCHED_OTHER"
+	depends on GROUP_SCHED
+	default y
+

WARNING:CONFIG_DESCRIPTION: please write a help paragraph that fully describes the config symbol
#399: FILE: init/Kconfig:326:
+config RT_GROUP_SCHED
+	bool "Group scheduling for SCHED_RR/FIFO"
+	depends on EXPERIMENTAL
+	depends on GROUP_SCHED
+	default n
+

WARNING:TYPO_SPELLING: 'postion' may be misspelled - perhaps 'position'?
#480: FILE: kernel/rcupreempt.c:453:
+		 * to a postion that it was in during the NMI/SMI.
 		        ^^^^^^^

WARNING:TYPO_SPELLING: 'preceed' may be misspelled - perhaps 'precede'?
#553: FILE: kernel/rcupreempt.c:526:
+		 * are seen by other CPUs to preceed the following
 		                             ^^^^^^^

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'curr == snap'
#590: FILE: kernel/rcupreempt.c:563:
+	if ((curr == snap) && ((curr & 0x1) == 0))

Parentheses are not required in the following cases:

  1. Function pointer uses::

      (foo->bar)();

    could be::

      foo->bar();

  2. Comparisons in if::

      if ((foo->bar) && (foo->baz))
      if ((foo == bar))

    could be::

      if (foo->bar && foo->baz)
      if (foo == bar)

  3. addressof/dereference single Lvalues::

      &(foo->bar)
      *(foo->bar)

    could be::

      &foo->bar
      *foo->bar

CHECK:UNNECESSARY_PARENTHESES: Unnecessary parentheses around 'curr == snap'
#625: FILE: kernel/rcupreempt.c:598:
+	if ((curr == snap) && ((curr & 0x1) == 0))

WARNING:LINE_SPACING: Missing a blank line after declarations
#738: FILE: kernel/sched.c:166:
+	static const ktime_t ktime_zero = { .tv64 = 0 };
+	return ktime_add_ns(ktime_zero, ns);

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:UNCOMMENTED_DEFINITION: spinlock_t definition without comment
#744: FILE: kernel/sched.c:172:
+	spinlock_t rt_runtime_lock;

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#782: FILE: kernel/sched.c:210:
+	hrtimer_init(&rt_b->rt_period_timer,
+			CLOCK_MONOTONIC, HRTIMER_MODE_REL);

CHECK:SPACING: spaces preferred around that '*' (ctx:VxV)
#897: FILE: kernel/sched.c:345:
+# define INIT_TASK_GROUP_LOAD	(2*NICE_0_LOAD)
                              	  ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:UNCOMMENTED_DEFINITION: spinlock_t definition without comment
#1014: FILE: kernel/sched.c:470:
+	spinlock_t rt_runtime_lock;

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1239: FILE: kernel/sched.c:7279:
+	init_rt_bandwidth(&def_rt_bandwidth,
+			global_rt_period(), global_rt_runtime());

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1243: FILE: kernel/sched.c:7283:
+	init_rt_bandwidth(&init_task_group.rt_bandwidth,
+			global_rt_period(), global_rt_runtime());

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1391: FILE: kernel/sched.c:7709:
+	list_add_rcu(&tg->cfs_rq[cpu]->leaf_cfs_rq_list,
+			&cpu_rq(cpu)->leaf_cfs_rq_list);

WARNING:NR_CPUS: usage of NR_CPUS is often wrong - consider using cpu_possible(), num_possible_cpus(), for_each_possible_cpu(), etc
#1442: FILE: kernel/sched.c:7760:
+	tg->rt_rq = kzalloc(sizeof(rt_rq) * NR_CPUS, GFP_KERNEL);

WARNING:NR_CPUS: usage of NR_CPUS is often wrong - consider using cpu_possible(), num_possible_cpus(), for_each_possible_cpu(), etc
#1445: FILE: kernel/sched.c:7763:
+	tg->rt_se = kzalloc(sizeof(rt_se) * NR_CPUS, GFP_KERNEL);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1450: FILE: kernel/sched.c:7768:
+	init_rt_bandwidth(&tg->rt_bandwidth,
+			ktime_to_ns(def_rt_bandwidth.rt_period), 0);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1476: FILE: kernel/sched.c:7795:
+	list_add_rcu(&tg->rt_rq[cpu]->leaf_rt_rq_list,
+			&cpu_rq(cpu)->leaf_rt_rq_list);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1683: FILE: kernel/sched.c:8042:
+static int tg_set_bandwidth(struct task_group *tg,
+		u64 rt_period, u64 rt_runtime)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1788: FILE: kernel/sched.c:8145:
+		struct file *filp, void __user *buffer, size_t *lenp,
 		             ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1788: FILE: kernel/sched.c:8145:
+int sched_rt_handler(struct ctl_table *table, int write,
+		struct file *filp, void __user *buffer, size_t *lenp,

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1799: FILE: kernel/sched.c:8156:
+	ret = proc_dointvec(table, write, filp, buffer, lenp, ppos);
 	                                  ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1857: FILE: kernel/sched.c:8257:
+static ssize_t cpu_rt_runtime_write(struct cgroup *cgrp, struct cftype *cft,
+				struct file *file,

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1877: FILE: kernel/sched.c:8276:
+	if (nbytes && (buffer[nbytes-1] == '\n'))
 	                            ^

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#1878: FILE: kernel/sched.c:8277:
+		buffer[nbytes-1] = 0;
 		             ^

WARNING:CONSIDER_KSTRTO: simple_strtoll is obsolete, use kstrtoll instead
#1879: FILE: kernel/sched.c:8278:
+	val = simple_strtoll(buffer, &end, 0);

The simple_strtol(), simple_strtoll(), simple_strtoul(), and
simple_strtoull() functions explicitly ignore overflows, which
may lead to unexpected results in callers.  The respective kstrtol(),
kstrtoll(), kstrtoul(), and kstrtoull() functions tend to be the
correct replacements.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#simple-strtol-simple-strtoll-simple-strtoul-simple-strtoull

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1906: FILE: kernel/sched.c:8302:
+static int cpu_rt_period_write_uint(struct cgroup *cgrp, struct cftype *cftype,
+		u64 rt_period_us)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'se' - possible side-effects?
#2002: FILE: kernel/sched_fair.c:97:
+#define for_each_sched_entity(se) \
+		for (; se; se = se->parent)

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'rq' may be better as '(rq)' to avoid precedence issues
#2031: FILE: kernel/sched_fair.c:126:
+#define for_each_leaf_cfs_rq(rq, cfs_rq) \
+	list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'se' - possible side-effects?
#2059: FILE: kernel/sched_fair.c:155:
+#define for_each_sched_entity(se) \
+		for (; se; se = NULL)

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'rq' may be better as '(rq)' to avoid precedence issues
#2088: FILE: kernel/sched_fair.c:182:
+#define for_each_leaf_cfs_rq(rq, cfs_rq) \
+		for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'cfs_rq' - possible side-effects?
#2088: FILE: kernel/sched_fair.c:182:
+#define for_each_leaf_cfs_rq(rq, cfs_rq) \
+		for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2200: FILE: kernel/sched_fair.c:407:
+		delta = calc_delta_mine(delta,
+				cfs_rq_of(se)->load.weight, &se->load);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2366: FILE: kernel/sched_fair.c:790:
+	if (rq_of(cfs_rq)->load.weight != curr->load.weight ||
+			!sched_feat(WAKEUP_PREEMPT))

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#2538: FILE: kernel/sched_fair.c:1136:
+	next = se = __pick_next_entity(cfs_rq);

Multiple assignments on a single line makes the code unnecessarily
complicated. So on a single line assign value to a single variable
only, this makes the code more readable and helps avoid typos.

CHECK:SPACING: spaces preferred around that '*' (ctx:VxV)
#2750: FILE: kernel/sched_rt.c:245:
+			rt_rq->rt_time -= min(rt_rq->rt_time, overrun*runtime);
 			                                             ^

WARNING:NAKED_SSCANF: unchecked sscanf return value
#3170: FILE: kernel/user.c:187:
+	sscanf(buf, "%lu", &rt_runtime);

WARNING:SSCANF_TO_KSTRTO: Prefer kstrto<type> to single variable sscanf
#3170: FILE: kernel/user.c:187:
+	sscanf(buf, "%lu", &rt_runtime);

ERROR:RETURN_PARENTHESES: return is not a function, parentheses are not required
#3174: FILE: kernel/user.c:191:
+	return (rc ? rc : size);

return is not a function and as such doesn't need parentheses::

  return (bar);

can simply be::

  return bar;

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#3181: FILE: kernel/user.c:198:
+static ssize_t cpu_rt_period_show(struct kobject *kobj,
+				   struct kobj_attribute *attr,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#3190: FILE: kernel/user.c:207:
+static ssize_t cpu_rt_period_store(struct kobject *kobj,
+				    struct kobj_attribute *attr,

WARNING:NAKED_SSCANF: unchecked sscanf return value
#3197: FILE: kernel/user.c:214:
+	sscanf(buf, "%lu", &rt_period);

WARNING:SSCANF_TO_KSTRTO: Prefer kstrto<type> to single variable sscanf
#3197: FILE: kernel/user.c:214:
+	sscanf(buf, "%lu", &rt_period);

ERROR:RETURN_PARENTHESES: return is not a function, parentheses are not required
#3201: FILE: kernel/user.c:218:
+	return (rc ? rc : size);

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000323192.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 total: 2 errors, 23 warnings, 36 checks, 2923 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.JOzjvdpBcb//home/fedora/lkml-analysis/lkml/1/patch.offset.0000323192.commit.e10aeb39c1d3567f1906ca36162c977c1b7c0672 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
