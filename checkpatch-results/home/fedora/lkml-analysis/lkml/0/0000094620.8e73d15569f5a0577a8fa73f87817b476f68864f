WARNING:TYPO_SPELLING: 'arbitary' may be misspelled - perhaps 'arbitrary'?
#25: 
is fairly arbitary and due to the message length limit on the list.
          ^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

CHECK:CAMELCASE: Avoid CamelCase: <RIOParam>
#44: FILE: drivers/char/rio/rioparam.c:160:
+int RIOParam(struct Port *PortP, int cmd, int Modem, int SleepFlag)

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

CHECK:CAMELCASE: Avoid CamelCase: <Port>
#44: FILE: drivers/char/rio/rioparam.c:160:
+int RIOParam(struct Port *PortP, int cmd, int Modem, int SleepFlag)

CHECK:CAMELCASE: Avoid CamelCase: <PortP>
#44: FILE: drivers/char/rio/rioparam.c:160:
+int RIOParam(struct Port *PortP, int cmd, int Modem, int SleepFlag)

CHECK:CAMELCASE: Avoid CamelCase: <Modem>
#44: FILE: drivers/char/rio/rioparam.c:160:
+int RIOParam(struct Port *PortP, int cmd, int Modem, int SleepFlag)

CHECK:CAMELCASE: Avoid CamelCase: <SleepFlag>
#44: FILE: drivers/char/rio/rioparam.c:160:
+int RIOParam(struct Port *PortP, int cmd, int Modem, int SleepFlag)

CHECK:CAMELCASE: Avoid CamelCase: <TtyP>
#47: FILE: drivers/char/rio/rioparam.c:162:
+	struct tty_struct *TtyP;

CHECK:CAMELCASE: Avoid CamelCase: <Cor1>
#56: FILE: drivers/char/rio/rioparam.c:167:
+	u8 Cor1 = 0, Cor2 = 0, Cor4 = 0, Cor5 = 0;

CHECK:CAMELCASE: Avoid CamelCase: <Cor2>
#56: FILE: drivers/char/rio/rioparam.c:167:
+	u8 Cor1 = 0, Cor2 = 0, Cor4 = 0, Cor5 = 0;

CHECK:CAMELCASE: Avoid CamelCase: <Cor4>
#56: FILE: drivers/char/rio/rioparam.c:167:
+	u8 Cor1 = 0, Cor2 = 0, Cor4 = 0, Cor5 = 0;

CHECK:CAMELCASE: Avoid CamelCase: <Cor5>
#56: FILE: drivers/char/rio/rioparam.c:167:
+	u8 Cor1 = 0, Cor2 = 0, Cor4 = 0, Cor5 = 0;

CHECK:CAMELCASE: Avoid CamelCase: <TxXon>
#57: FILE: drivers/char/rio/rioparam.c:168:
+	u8 TxXon = 0, TxXoff = 0, RxXon = 0, RxXoff = 0;

CHECK:CAMELCASE: Avoid CamelCase: <TxXoff>
#57: FILE: drivers/char/rio/rioparam.c:168:
+	u8 TxXon = 0, TxXoff = 0, RxXon = 0, RxXoff = 0;

CHECK:CAMELCASE: Avoid CamelCase: <RxXon>
#57: FILE: drivers/char/rio/rioparam.c:168:
+	u8 TxXon = 0, TxXoff = 0, RxXon = 0, RxXoff = 0;

CHECK:CAMELCASE: Avoid CamelCase: <RxXoff>
#57: FILE: drivers/char/rio/rioparam.c:168:
+	u8 TxXon = 0, TxXoff = 0, RxXon = 0, RxXoff = 0;

CHECK:CAMELCASE: Avoid CamelCase: <LNext>
#58: FILE: drivers/char/rio/rioparam.c:169:
+	u8 LNext = 0, TxBaud = 0, RxBaud = 0;

CHECK:CAMELCASE: Avoid CamelCase: <TxBaud>
#58: FILE: drivers/char/rio/rioparam.c:169:
+	u8 LNext = 0, TxBaud = 0, RxBaud = 0;

CHECK:CAMELCASE: Avoid CamelCase: <RxBaud>
#58: FILE: drivers/char/rio/rioparam.c:169:
+	u8 LNext = 0, TxBaud = 0, RxBaud = 0;

CHECK:CAMELCASE: Avoid CamelCase: <PacketP>
#84: FILE: drivers/char/rio/rioparam.c:243:
+	rio_dprintk(RIO_DEBUG_PARAM, "Packet is 0x%p\n", PacketP);

CHECK:CAMELCASE: Avoid CamelCase: <Cmd>
#114: FILE: drivers/char/rio/rioparam.c:545:
+	writeb(cmd, &phb_param_ptr->Cmd);

CHECK:CAMELCASE: Avoid CamelCase: <PktP>
#142: FILE: drivers/char/rio/rioparam.c:590:
+int can_add_transmit(PKT **PktP, struct Port *PortP)

CHECK:SPACING: No space is necessary after a cast
#148: FILE: drivers/char/rio/rioparam.c:594:
+	*PktP = tp = (PKT *) RIO_PTR(PortP->Caddr, readw(PortP->TxAdd));

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:CAMELCASE: Avoid CamelCase: <Caddr>
#148: FILE: drivers/char/rio/rioparam.c:594:
+	*PktP = tp = (PKT *) RIO_PTR(PortP->Caddr, readw(PortP->TxAdd));

CHECK:CAMELCASE: Avoid CamelCase: <TxAdd>
#148: FILE: drivers/char/rio/rioparam.c:594:
+	*PktP = tp = (PKT *) RIO_PTR(PortP->Caddr, readw(PortP->TxAdd));

CHECK:SPACING: No space is necessary after a cast
#151: FILE: drivers/char/rio/rioparam.c:596:
+	return !((unsigned long) tp & PKT_IN_USE);

WARNING:BRACES: braces {} are not necessary for single statement blocks
#164: FILE: drivers/char/rio/rioparam.c:606:
+	if (readw(PortP->TxAdd) & PKT_IN_USE) {
 		rio_dprintk(RIO_DEBUG_PARAM, "add_transmit: Packet has been stolen!");
 	}

The placement of braces is stylistically incorrect.
The preferred way is to put the opening brace last on the line,
and put the closing brace first::

  if (x is true) {
          we do y
  }

This applies for all non-functional blocks.
However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus::

  int function(int x)
  {
          body of function
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

CHECK:CAMELCASE: Avoid CamelCase: <PhbP>
#171: FILE: drivers/char/rio/rioparam.c:611:
+	writew(RIO_OFF(PortP->Caddr, PortP->TxAdd), &PortP->PhbP->tx_add);

CHECK:CAMELCASE: Avoid CamelCase: <Host>
#181: FILE: drivers/char/rio/rioparam.c:618:
+void put_free_end(struct Host *HostP, PKT *PktP)

CHECK:CAMELCASE: Avoid CamelCase: <HostP>
#181: FILE: drivers/char/rio/rioparam.c:618:
+void put_free_end(struct Host *HostP, PKT *PktP)

ERROR:ASSIGN_IN_IF: do not use assignment in if condition
#193: FILE: drivers/char/rio/rioparam.c:633:
+	if ((old_end = readw(&HostP->ParmMapP->free_list_end)) != TPNULL) {

Do not use assignments in if condition.
Example::

  if ((foo = bar(...)) < BAZ) {

should be written as::

  foo = bar(...);
  if (foo < BAZ) {

CHECK:CAMELCASE: Avoid CamelCase: <ParmMapP>
#193: FILE: drivers/char/rio/rioparam.c:633:
+	if ((old_end = readw(&HostP->ParmMapP->free_list_end)) != TPNULL) {

CHECK:SPACING: No space is necessary after a cast
#201: FILE: drivers/char/rio/rioparam.c:637:
+		writew(old_end, &((FREE_LIST *) PktP)->prev);

CHECK:SPACING: No space is necessary after a cast
#202: FILE: drivers/char/rio/rioparam.c:638:
+		writew(TPNULL, &((FREE_LIST *) PktP)->next);

CHECK:CAMELCASE: Avoid CamelCase: <RxRemove>
#227: FILE: drivers/char/rio/rioparam.c:659:
+	if (readw(PortP->RxRemove) & PKT_IN_USE) {

CHECK:SPACING: No space is necessary after a cast
#228: FILE: drivers/char/rio/rioparam.c:660:
+		*PktP = (PKT *) RIO_PTR(PortP->Caddr, readw(PortP->RxRemove) & ~PKT_IN_USE);

CHECK:CAMELCASE: Avoid CamelCase: <PktCmdP>
#254: FILE: drivers/char/rio/rioroute.c:118:
+	if (readb(&PktCmdP->Command) == ROUTE_TOPOLOGY) {

CHECK:CAMELCASE: Avoid CamelCase: <Command>
#254: FILE: drivers/char/rio/rioroute.c:118:
+	if (readb(&PktCmdP->Command) == ROUTE_TOPOLOGY) {

CHECK:SPACING: No space is necessary after a cast
#263: FILE: drivers/char/rio/rioroute.c:154:
+			if (readb(&PktCmdP->RouteTopology[ThisLink].Unit) > (ushort) MAX_RUP)

CHECK:CAMELCASE: Avoid CamelCase: <RouteTopology>
#263: FILE: drivers/char/rio/rioroute.c:154:
+			if (readb(&PktCmdP->RouteTopology[ThisLink].Unit) > (ushort) MAX_RUP)

CHECK:CAMELCASE: Avoid CamelCase: <ThisLink>
#263: FILE: drivers/char/rio/rioroute.c:154:
+			if (readb(&PktCmdP->RouteTopology[ThisLink].Unit) > (ushort) MAX_RUP)

CHECK:CAMELCASE: Avoid CamelCase: <Unit>
#263: FILE: drivers/char/rio/rioroute.c:154:
+			if (readb(&PktCmdP->RouteTopology[ThisLink].Unit) > (ushort) MAX_RUP)

WARNING:LONG_LINE: line length of 233 exceeds 100 columns
#268: FILE: drivers/char/rio/rioroute.c:158:
+				if ((readb(&PktCmdP->RouteTopology[ThisLink].Unit) == readb(&PktCmdP->RouteTopology[NewLink].Unit)) && (readb(&PktCmdP->RouteTopology[ThisLink].Link) == readb(&PktCmdP->RouteTopology[NewLink].Link))) {

The line has exceeded the specified maximum length.
To use a different maximum line length, the --max-line-length=n option
may be added while invoking checkpatch.

Earlier, the default line length was 80 columns.  Commit bdc48fa11e46
("checkpatch/coding-style: deprecate 80-column warning") increased the
limit to 100 columns.  This is not a hard limit either and it's
preferable to stay within 80 columns whenever possible.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#breaking-long-lines-and-strings

CHECK:CAMELCASE: Avoid CamelCase: <NewLink>
#268: FILE: drivers/char/rio/rioroute.c:158:
+				if ((readb(&PktCmdP->RouteTopology[ThisLink].Unit) == readb(&PktCmdP->RouteTopology[NewLink].Unit)) && (readb(&PktCmdP->RouteTopology[ThisLink].Link) == readb(&PktCmdP->RouteTopology[NewLink].Link))) {

CHECK:CAMELCASE: Avoid CamelCase: <Link>
#268: FILE: drivers/char/rio/rioroute.c:158:
+				if ((readb(&PktCmdP->RouteTopology[ThisLink].Unit) == readb(&PktCmdP->RouteTopology[NewLink].Unit)) && (readb(&PktCmdP->RouteTopology[ThisLink].Link) == readb(&PktCmdP->RouteTopology[NewLink].Link))) {

WARNING:BRACES: braces {} are not necessary for single statement blocks
#268: FILE: drivers/char/rio/rioroute.c:158:
+				if ((readb(&PktCmdP->RouteTopology[ThisLink].Unit) == readb(&PktCmdP->RouteTopology[NewLink].Unit)) && (readb(&PktCmdP->RouteTopology[ThisLink].Link) == readb(&PktCmdP->RouteTopology[NewLink].Link))) {
 					Lies++;
 				}

WARNING:LONG_LINE: line length of 254 exceeds 100 columns
#283: FILE: drivers/char/rio/rioroute.c:170:
+				    'A' + readb(&PktCmdP->RouteTopology[1].Link), readb(&PktCmdP->RouteTopology[2].Unit), 'A' + readb(&PktCmdP->RouteTopology[2].Link), readb(&PktCmdP->RouteTopology[3].Unit), 'A' + readb(&PktCmdP->RouteTopology[3].Link));

CHECK:CAMELCASE: Avoid CamelCase: <NewUnit>
#293: FILE: drivers/char/rio/rioroute.c:187:
+			NewUnit = readb(&PktCmdP->RouteTopology[ThisLink].Unit);

WARNING:LONG_LINE: line length of 162 exceeds 100 columns
#303: FILE: drivers/char/rio/rioroute.c:222:
+							printk(KERN_DEBUG "rio: %s '%s' (%c) is connected to another network.\n", MyType, MyName, 'A' + ThisLink);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#303: FILE: drivers/char/rio/rioroute.c:222:
+							printk(KERN_DEBUG "rio: %s '%s' (%c) is connected to another network.\n", MyType, MyName, 'A' + ThisLink);

CHECK:CAMELCASE: Avoid CamelCase: <MyType>
#303: FILE: drivers/char/rio/rioroute.c:222:
+							printk(KERN_DEBUG "rio: %s '%s' (%c) is connected to another network.\n", MyType, MyName, 'A' + ThisLink);

CHECK:CAMELCASE: Avoid CamelCase: <MyName>
#303: FILE: drivers/char/rio/rioroute.c:222:
+							printk(KERN_DEBUG "rio: %s '%s' (%c) is connected to another network.\n", MyType, MyName, 'A' + ThisLink);

WARNING:LONG_LINE: line length of 144 exceeds 100 columns
#314: FILE: drivers/char/rio/rioroute.c:268:
+		rio_dprintk(RIO_DEBUG_ROUTE, "Unknown command %d received on rup %d host %p ROUTE_RUP\n", readb(&PktCmdP->Command), Rup, HostP);

CHECK:CAMELCASE: Avoid CamelCase: <Rup>
#314: FILE: drivers/char/rio/rioroute.c:268:
+		rio_dprintk(RIO_DEBUG_ROUTE, "Unknown command %d received on rup %d host %p ROUTE_RUP\n", readb(&PktCmdP->Command), Rup, HostP);

WARNING:LONG_LINE: line length of 161 exceeds 100 columns
#319: FILE: drivers/char/rio/rioroute.c:272:
+	RtaUniq = (readb(&PktCmdP->UniqNum[0])) + (readb(&PktCmdP->UniqNum[1]) << 8) + (readb(&PktCmdP->UniqNum[2]) << 16) + (readb(&PktCmdP->UniqNum[3]) << 24);

CHECK:CAMELCASE: Avoid CamelCase: <RtaUniq>
#319: FILE: drivers/char/rio/rioroute.c:272:
+	RtaUniq = (readb(&PktCmdP->UniqNum[0])) + (readb(&PktCmdP->UniqNum[1]) << 8) + (readb(&PktCmdP->UniqNum[2]) << 16) + (readb(&PktCmdP->UniqNum[3]) << 24);

CHECK:CAMELCASE: Avoid CamelCase: <UniqNum>
#319: FILE: drivers/char/rio/rioroute.c:272:
+	RtaUniq = (readb(&PktCmdP->UniqNum[0])) + (readb(&PktCmdP->UniqNum[1]) << 8) + (readb(&PktCmdP->UniqNum[2]) << 16) + (readb(&PktCmdP->UniqNum[3]) << 24);

CHECK:CAMELCASE: Avoid CamelCase: <Mod>
#328: FILE: drivers/char/rio/rioroute.c:281:
+	Mod = readb(&PktCmdP->ModuleTypes);

CHECK:CAMELCASE: Avoid CamelCase: <ModuleTypes>
#328: FILE: drivers/char/rio/rioroute.c:281:
+	Mod = readb(&PktCmdP->ModuleTypes);

WARNING:LONG_LINE: line length of 134 exceeds 100 columns
#337: FILE: drivers/char/rio/rioroute.c:351:
+						printk(KERN_DEBUG "rio: RTA '%s' is being updated.\n", HostP->Mapping[ThisUnit].Name);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#337: FILE: drivers/char/rio/rioroute.c:351:
+						printk(KERN_DEBUG "rio: RTA '%s' is being updated.\n", HostP->Mapping[ThisUnit].Name);

CHECK:CAMELCASE: Avoid CamelCase: <Mapping>
#337: FILE: drivers/char/rio/rioroute.c:351:
+						printk(KERN_DEBUG "rio: RTA '%s' is being updated.\n", HostP->Mapping[ThisUnit].Name);

CHECK:CAMELCASE: Avoid CamelCase: <ThisUnit>
#337: FILE: drivers/char/rio/rioroute.c:351:
+						printk(KERN_DEBUG "rio: RTA '%s' is being updated.\n", HostP->Mapping[ThisUnit].Name);

CHECK:CAMELCASE: Avoid CamelCase: <Name>
#337: FILE: drivers/char/rio/rioroute.c:351:
+						printk(KERN_DEBUG "rio: RTA '%s' is being updated.\n", HostP->Mapping[ThisUnit].Name);

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#346: FILE: drivers/char/rio/rioroute.c:478:
+				printk(KERN_DEBUG "rio: One or more unknown RTAs are being updated.\n");

CHECK:SPACING: No space is necessary after a cast
#364: FILE: drivers/char/rio/rioroute.c:572:
+				Pkt = (PKT *) RIO_PTR(HostP->Caddr, readw(TxPktP));

CHECK:CAMELCASE: Avoid CamelCase: <Pkt>
#364: FILE: drivers/char/rio/rioroute.c:572:
+				Pkt = (PKT *) RIO_PTR(HostP->Caddr, readw(TxPktP));

CHECK:CAMELCASE: Avoid CamelCase: <TxPktP>
#364: FILE: drivers/char/rio/rioroute.c:572:
+				Pkt = (PKT *) RIO_PTR(HostP->Caddr, readw(TxPktP));

CHECK:SPACING: No space is necessary after a cast
#376: FILE: drivers/char/rio/rioroute.c:577:
+				Pkt = (PKT *) ((unsigned long) Pkt & ~PKT_IN_USE);

WARNING:LONG_LINE: line length of 199 exceeds 100 columns
#380: FILE: drivers/char/rio/rioroute.c:581:
+			rio_dprintk(RIO_DEBUG_ROUTE, "phb dest: Old %x:%x New %x:%x\n", readw(&PortP->PhbP->destination) & 0xff, (readw(&PortP->PhbP->destination) >> 8) & 0xff, dest_unit, dest_port);

CHECK:CAMELCASE: Avoid CamelCase: <LinkStrP>
#391: FILE: drivers/char/rio/rioroute.c:593:
+		if (((unit * 8) + 7) > readw(&HostP->LinkStrP[link].last_port)) {

WARNING:LONG_LINE: line length of 203 exceeds 100 columns
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <FromType>
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <FromName>
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <FromLink>
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <ToType>
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <ToName>
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <ToLink>
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <Change>
#403: FILE: drivers/char/rio/rioroute.c:821:
+	printk(KERN_DEBUG "rio: Link between %s '%s' (%c) and %s '%s' (%c) %s.\n", FromType, FromName, 'A' + FromLink, ToType, ToName, 'A' + ToLink, (Change == CONNECT) ? "established" : "disconnected");

CHECK:CAMELCASE: Avoid CamelCase: <RIOSavedTable>
#412: FILE: drivers/char/rio/rioroute.c:841:
+			memset(&p->RIOSavedTable[entry], 0, sizeof(struct Map));

CHECK:CAMELCASE: Avoid CamelCase: <Map>
#412: FILE: drivers/char/rio/rioroute.c:841:
+			memset(&p->RIOSavedTable[entry], 0, sizeof(struct Map));

CHECK:CAMELCASE: Avoid CamelCase: <nOther>
#421: FILE: drivers/char/rio/rioroute.c:901:
+		memset(&HostP->Mapping[nOther], 0, sizeof(struct Map));

CHECK:CAMELCASE: Avoid CamelCase: <RIONewTable>
#452: FILE: drivers/char/rio/riotable.c:94:
+int RIONewTable(struct rio_info *p)

CHECK:CAMELCASE: Avoid CamelCase: <RIOHosts>
#461: FILE: drivers/char/rio/riotable.c:300:
+			memset(&p->RIOHosts[Host].Mapping[Entry], 0, sizeof(struct Map));

CHECK:CAMELCASE: Avoid CamelCase: <Entry>
#461: FILE: drivers/char/rio/riotable.c:300:
+			memset(&p->RIOHosts[Host].Mapping[Entry], 0, sizeof(struct Map));

CHECK:CAMELCASE: Avoid CamelCase: <RIOApel>
#477: FILE: drivers/char/rio/riotable.c:414:
+int RIOApel(struct rio_info *p)

CHECK:CAMELCASE: Avoid CamelCase: <RIOConnectTable>
#493: FILE: drivers/char/rio/riotable.c:426:
+	memset(&p->RIOConnectTable[0], 0, sizeof(struct Map) * TOTAL_MAP_ENTRIES);

CHECK:CAMELCASE: Avoid CamelCase: <HostLock>
#498: FILE: drivers/char/rio/riotable.c:431:
+		rio_spin_lock_irqsave(&HostP->HostLock, flags);

ERROR:TRAILING_WHITESPACE: trailing whitespace
#499: FILE: drivers/char/rio/riotable.c:432:
+^I^I$

Trailing whitespace should always be removed.
Some editors highlight the trailing whitespace and cause visual
distractions when editing files.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

WARNING:TYPO_SPELLING: 'MapP' may be misspelled - perhaps 'Map'?
#520: FILE: drivers/char/rio/riotable.c:466:
+int RIODeleteRta(struct rio_info *p, struct Map *MapP)
                                                  ^^^^

CHECK:CAMELCASE: Avoid CamelCase: <RIODeleteRta>
#520: FILE: drivers/char/rio/riotable.c:466:
+int RIODeleteRta(struct rio_info *p, struct Map *MapP)

CHECK:CAMELCASE: Avoid CamelCase: <MapP>
#520: FILE: drivers/char/rio/riotable.c:466:
+int RIODeleteRta(struct rio_info *p, struct Map *MapP)

WARNING:LONG_LINE: line length of 117 exceeds 100 columns
#538: FILE: drivers/char/rio/riotable.c:555:
+								Pkt = (PKT *) RIO_PTR(HostP->Caddr, readw(&*TxPktP));

CHECK:SPACING: No space is necessary after a cast
#538: FILE: drivers/char/rio/riotable.c:555:
+								Pkt = (PKT *) RIO_PTR(HostP->Caddr, readw(&*TxPktP));

WARNING:LONG_LINE: line length of 120 exceeds 100 columns
#547: FILE: drivers/char/rio/riotable.c:561:
+							writew(dest_unit + (dest_port << 8), &PortP->PhbP->destination);

CHECK:CAMELCASE: Avoid CamelCase: <HostMapP>
#554: FILE: drivers/char/rio/riotable.c:567:
+				memset(HostMapP, 0, sizeof(struct Map));

CHECK:CAMELCASE: Avoid CamelCase: <RIOReMapPorts>
#580: FILE: drivers/char/rio/riotable.c:743:
+int RIOReMapPorts(struct rio_info *p, struct Host *HostP, struct Map *HostMapP)

CHECK:SPACING: No space is necessary after a cast
#597: FILE: drivers/char/rio/riotable.c:792:
+			PortP->TxAdd = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->tx_add));

CHECK:SPACING: No space is necessary after a cast
#598: FILE: drivers/char/rio/riotable.c:793:
+			PortP->TxStart = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->tx_start));

CHECK:CAMELCASE: Avoid CamelCase: <TxStart>
#598: FILE: drivers/char/rio/riotable.c:793:
+			PortP->TxStart = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->tx_start));

CHECK:SPACING: No space is necessary after a cast
#599: FILE: drivers/char/rio/riotable.c:794:
+			PortP->TxEnd = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->tx_end));

CHECK:CAMELCASE: Avoid CamelCase: <TxEnd>
#599: FILE: drivers/char/rio/riotable.c:794:
+			PortP->TxEnd = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->tx_end));

CHECK:SPACING: No space is necessary after a cast
#600: FILE: drivers/char/rio/riotable.c:795:
+			PortP->RxRemove = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->rx_remove));

CHECK:SPACING: No space is necessary after a cast
#601: FILE: drivers/char/rio/riotable.c:796:
+			PortP->RxStart = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->rx_start));

CHECK:CAMELCASE: Avoid CamelCase: <RxStart>
#601: FILE: drivers/char/rio/riotable.c:796:
+			PortP->RxStart = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->rx_start));

CHECK:SPACING: No space is necessary after a cast
#602: FILE: drivers/char/rio/riotable.c:797:
+			PortP->RxEnd = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->rx_end));

CHECK:CAMELCASE: Avoid CamelCase: <RxEnd>
#602: FILE: drivers/char/rio/riotable.c:797:
+			PortP->RxEnd = (u16 *) RIO_PTR(HostP->Caddr, readw(&PhbP->rx_end));

CHECK:CAMELCASE: Avoid CamelCase: <TxRingBuffer>
#621: FILE: drivers/char/rio/riotable.c:871:
+			memset(PortP->TxRingBuffer, 0, p->RIOBufferSize);

CHECK:CAMELCASE: Avoid CamelCase: <RIOBufferSize>
#621: FILE: drivers/char/rio/riotable.c:871:
+			memset(PortP->TxRingBuffer, 0, p->RIOBufferSize);

CHECK:SPACING: No space is necessary after a cast
#635: FILE: drivers/char/rio/riotable.c:885:
+		PortP->LastRxTgl = ~(u8) PHB_RX_TGL;

CHECK:CAMELCASE: Avoid CamelCase: <LastRxTgl>
#635: FILE: drivers/char/rio/riotable.c:885:
+		PortP->LastRxTgl = ~(u8) PHB_RX_TGL;

WARNING:TYPO_SPELLING: 'MapP' may be misspelled - perhaps 'Map'?
#646: FILE: drivers/char/rio/riotable.c:901:
+int RIOChangeName(struct rio_info *p, struct Map *MapP)
                                                   ^^^^

CHECK:CAMELCASE: Avoid CamelCase: <RIOChangeName>
#646: FILE: drivers/char/rio/riotable.c:901:
+int RIOChangeName(struct rio_info *p, struct Map *MapP)

CHECK:CAMELCASE: Avoid CamelCase: <SysPort>
#658: FILE: drivers/char/rio/riotty.c:139:
+	unsigned int SysPort;

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000094620.commit.8e73d15569f5a0577a8fa73f87817b476f68864f total: 2 errors, 19 warnings, 93 checks, 658 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000094620.commit.8e73d15569f5a0577a8fa73f87817b476f68864f has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
