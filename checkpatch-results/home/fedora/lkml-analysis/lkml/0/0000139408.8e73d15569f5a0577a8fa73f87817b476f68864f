WARNING:TYPO_SPELLING: 'dynamicly' may be misspelled - perhaps 'dynamically'?
#73: FILE: Documentation/sysctl/vm.txt:112:
+The thrashing-threshold is dynamicly estimated according to the
                            ^^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u64' over 'uint64_t'
#103: FILE: include/linux/fs.h:565:
+	uint64_t      cache_hit;	/* cache hit count*/

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#144: FILE: include/linux/mm.h:900:
+			struct file_ra_state *ra, struct file *filp,
 			                                       ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#144: FILE: include/linux/mm.h:900:
+page_cache_readahead_adaptive(struct address_space *mapping,
+			struct file_ra_state *ra, struct file *filp,

CHECK:BIT_MACRO: Prefer using the BIT macro
#271: FILE: include/linux/page-flags.h:345:
+#define PAGE_REFCNT_1		(1 << PG_referenced)

Defines like: 1 << <digit> could be BIT(digit).
The BIT() macro is defined via include/linux/bits.h::

  #define BIT(nr)         (1UL << (nr))

CHECK:BIT_MACRO: Prefer using the BIT macro
#272: FILE: include/linux/page-flags.h:346:
+#define PAGE_REFCNT_2		(1 << PG_activate)

CHECK:BIT_MACRO: Prefer using the BIT macro
#305: FILE: include/linux/radix-tree.h:32:
+#define RADIX_TREE_MAP_SIZE	(1UL << RADIX_TREE_MAP_SHIFT)

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#306: FILE: include/linux/radix-tree.h:33:
+#define RADIX_TREE_MAP_MASK	(RADIX_TREE_MAP_SIZE-1)
                            	                    ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct radix_tree_root *' should also have an identifier name
#339: FILE: include/linux/radix-tree.h:75:
+void *radix_tree_lookup_node(struct radix_tree_root *, unsigned long,

This warning is emitted due to any of the following reasons:

  1. Arguments for the function declaration do not follow
     the identifier name.  Example::

       void foo
       (int bar, int baz)

     This should be corrected to::

       void foo(int bar, int baz)

  2. Some arguments for the function definition do not
     have an identifier name.  Example::

       void foo(int)

     All arguments should have identifier names.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'unsigned long' should also have an identifier name
#339: FILE: include/linux/radix-tree.h:75:
+void *radix_tree_lookup_node(struct radix_tree_root *, unsigned long,

WARNING:FUNCTION_ARGUMENTS: function definition argument 'unsigned int' should also have an identifier name
#339: FILE: include/linux/radix-tree.h:75:
+void *radix_tree_lookup_node(struct radix_tree_root *, unsigned long,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#340: FILE: include/linux/radix-tree.h:76:
+void *radix_tree_lookup_node(struct radix_tree_root *, unsigned long,
+							unsigned int);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#343: FILE: include/linux/radix-tree.h:79:
+unsigned long radix_tree_lookup_head(struct radix_tree_root *root,
+				unsigned long index, unsigned int max_scan);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#345: FILE: include/linux/radix-tree.h:81:
+unsigned long radix_tree_lookup_tail(struct radix_tree_root *root,
+				unsigned long index, unsigned int max_scan);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#361: FILE: include/linux/radix-tree.h:111:
+static inline void *radix_tree_lookup(struct radix_tree_root *root,
+							unsigned long index)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#375: FILE: include/linux/radix-tree.h:125:
+static inline void **radix_tree_lookup_slot(struct radix_tree_root *root,
+							unsigned long index)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#399: FILE: include/linux/radix-tree.h:149:
+static inline void *radix_tree_cache_lookup_node(struct radix_tree_root *root,
+				struct radix_tree_cache *cache,

ERROR:CODE_INDENT: code indent should use tabs where possible
#403: FILE: include/linux/radix-tree.h:153:
+        unsigned long i;$

Code indent should use tabs instead of spaces.
Outside of comments, documentation and Kconfig,
spaces are never used for indentation.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#403: FILE: include/linux/radix-tree.h:153:
+        unsigned long i;$

ERROR:CODE_INDENT: code indent should use tabs where possible
#404: FILE: include/linux/radix-tree.h:154:
+        unsigned long mask;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#404: FILE: include/linux/radix-tree.h:154:
+        unsigned long mask;$

ERROR:CODE_INDENT: code indent should use tabs where possible
#406: FILE: include/linux/radix-tree.h:156:
+        if (level && level >= root->height)$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#406: FILE: include/linux/radix-tree.h:156:
+        if (level && level >= root->height)$

ERROR:CODE_INDENT: code indent should use tabs where possible
#407: FILE: include/linux/radix-tree.h:157:
+                return root->rnode;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#407: FILE: include/linux/radix-tree.h:157:
+                return root->rnode;$

ERROR:CODE_INDENT: code indent should use tabs where possible
#409: FILE: include/linux/radix-tree.h:159:
+        i = ((index >> (level * RADIX_TREE_MAP_SHIFT)) & RADIX_TREE_MAP_MASK);$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#409: FILE: include/linux/radix-tree.h:159:
+        i = ((index >> (level * RADIX_TREE_MAP_SHIFT)) & RADIX_TREE_MAP_MASK);$

ERROR:CODE_INDENT: code indent should use tabs where possible
#410: FILE: include/linux/radix-tree.h:160:
+        mask = ~((RADIX_TREE_MAP_SIZE << (level * RADIX_TREE_MAP_SHIFT)) - 1);$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#410: FILE: include/linux/radix-tree.h:160:
+        mask = ~((RADIX_TREE_MAP_SIZE << (level * RADIX_TREE_MAP_SHIFT)) - 1);$

ERROR:CODE_INDENT: code indent should use tabs where possible
#413: FILE: include/linux/radix-tree.h:163:
+                return cache->tree_node->slots[i];$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#413: FILE: include/linux/radix-tree.h:163:
+                return cache->tree_node->slots[i];$

ERROR:CODE_INDENT: code indent should use tabs where possible
#421: FILE: include/linux/radix-tree.h:171:
+        return node->slots[i];$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#421: FILE: include/linux/radix-tree.h:171:
+        return node->slots[i];$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#433: FILE: include/linux/radix-tree.h:183:
+static inline void *radix_tree_cache_lookup(struct radix_tree_root *root,
+				struct radix_tree_cache *cache,

ERROR:SPACING: spaces required around that '=' (ctx:VxV)
#475: FILE: include/linux/sysctl.h:183:
+	VM_READAHEAD_RATIO=29, /* percent of read-ahead size to thrashing-threshold */
 	                  ^

WARNING:AVOID_EXTERNS: externs should be avoided in .c files
#502: FILE: kernel/sysctl.c:70:
+extern int readahead_ratio;

Function prototypes don't need to be declared extern in .h
files.  It's assumed by the compiler and is unnecessary.

WARNING:DUPLICATED_SYSCTL_CONST: duplicated sysctl range checking value 'zero', consider using the shared one in include/linux/sysctl.h
#518: FILE: kernel/sysctl.c:861:
+		.extra1		= &zero,

Commit d91bff3011cf ("proc/sysctl: add shared variables for range
check") added some shared const variables to be used instead of a local
copy in each source file.

Consider replacing the sysctl range checking value with the shared
one in include/linux/sysctl.h.  The following conversion scheme may
be used::

  &zero     ->  SYSCTL_ZERO
  &one      ->  SYSCTL_ONE
  &int_max  ->  SYSCTL_INT_MAX

See:

  1. https://lore.kernel.org/lkml/20190430180111.10688-1-mcroce@redhat.com/
  2. https://lore.kernel.org/lkml/20190531131422.14970-1-mcroce@redhat.com/

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#579: FILE: lib/radix-tree.c:280:
+void *radix_tree_lookup_node(struct radix_tree_root *root,
+				unsigned long index, unsigned int level)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#613: FILE: lib/radix-tree.c:319:
+unsigned long radix_tree_lookup_head(struct radix_tree_root *root,
+				unsigned long index, unsigned int max_scan)

ERROR:CODE_INDENT: code indent should use tabs where possible
#623: FILE: lib/radix-tree.c:329:
+        radix_tree_cache_init(&cache);$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#623: FILE: lib/radix-tree.c:329:
+        radix_tree_cache_init(&cache);$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#667: FILE: lib/radix-tree.c:373:
+unsigned long radix_tree_lookup_tail(struct radix_tree_root *root,
+				unsigned long index, unsigned int max_scan)

ERROR:CODE_INDENT: code indent should use tabs where possible
#677: FILE: lib/radix-tree.c:383:
+        radix_tree_cache_init(&cache);$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#677: FILE: lib/radix-tree.c:383:
+        radix_tree_cache_init(&cache);$

WARNING:AVOID_EXTERNS: externs should be avoided in .c files
#715: FILE: mm/filemap.c:705:
+extern int readahead_ratio;

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "!page"
#746: FILE: mm/filemap.c:776:
+			if (unlikely(page == NULL)) {

Comparisons to NULL in the form (foo == NULL) or (foo != NULL)
are better written as (!foo) and (foo).

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#748: FILE: mm/filemap.c:778:
+						filp, prev_page, NULL,
 						^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#748: FILE: mm/filemap.c:778:
+				page_cache_readahead_adaptive(mapping, &ra,
+						filp, prev_page, NULL,

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#754: FILE: mm/filemap.c:784:
+						filp, prev_page, page,
 						^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#754: FILE: mm/filemap.c:784:
+				page_cache_readahead_adaptive(mapping, &ra,
+						filp, prev_page, page,

WARNING:BRACES: braces {} are not necessary for single statement blocks
#777: FILE: mm/filemap.c:813:
+		if (prev_index != index) {
 			mark_page_accessed(page);
+		}

The placement of braces is stylistically incorrect.
The preferred way is to put the opening brace last on the line,
and put the closing brace first::

  if (x is true) {
          we do y
  }

This applies for all non-functional blocks.
However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus::

  int function(int x)
  {
          body of function
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

CHECK:LINE_SPACING: Please don't use multiple blank lines
#862: FILE: mm/filemap.c:1245:
 
+

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#871: FILE: mm/filemap.c:1254:
+			page_cache_readahead_adaptive(mapping, ra,
+						file, NULL, NULL,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#876: FILE: mm/filemap.c:1259:
+			page_cache_readahead_adaptive(mapping, ra,
+						file, NULL, page,

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#982: FILE: mm/page_alloc.c:842:
+	BUG_ON(!batch_size);

BUG() or BUG_ON() should be avoided totally.
Use WARN() and WARN_ON() instead, and handle the "impossible"
error condition as gracefully as possible.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#bug-and-bug-on

WARNING:BRACES: braces {} are not necessary for single statement blocks
#991: FILE: mm/page_alloc.c:851:
+			if (left_count <= 0) {
+				break;
+			}

WARNING:SPLIT_STRING: quoted string split across lines
#1063: FILE: mm/page_alloc.c:1413:
 			" present:%lukB"
+			" aging:%lukB"

Quoted strings that appear as messages in userspace and can be
grepped, should not be split across multiple lines.

See: https://lore.kernel.org/lkml/20120203052727.GA15035@leaf/

WARNING:SPLIT_STRING: quoted string split across lines
#1064: FILE: mm/page_alloc.c:1414:
+			" aging:%lukB"
+			" age:%lu"

WARNING:SPLIT_STRING: quoted string split across lines
#1091: FILE: mm/page_alloc.c:2167:
 			   "\n        inactive %lu"
+			   "\n        aging    %lu"

WARNING:SPLIT_STRING: quoted string split across lines
#1092: FILE: mm/page_alloc.c:2168:
+			   "\n        aging    %lu"
+			   "\n        age      %lu"

WARNING:TYPO_SPELLING: 'contexta' may be misspelled - perhaps 'context'?
#1201: FILE: mm/readahead.c:85:
+	"contexta",
 	 ^^^^^^^^

CHECK:SPACING: spaces preferred around that '+' (ctx:VxV)
#1224: FILE: mm/readahead.c:108:
+static unsigned long ra_event_count[RA_CLASS_END+1][RA_EVENT_END][2];
                                                 ^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1227: FILE: mm/readahead.c:111:
+static inline void ra_account(struct file_ra_state *ra,
+				enum ra_event e, int pages)

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1238: FILE: mm/readahead.c:122:
+	BUG_ON(c > RA_CLASS_END);

WARNING:STATIC_CONST_CHAR_ARRAY: static char array declaration should probably be static const char
#1249: FILE: mm/readahead.c:133:
+	static char event_fmt[] = "%-16s";

WARNING:STATIC_CONST_CHAR_ARRAY: static char array declaration should probably be static const char
#1250: FILE: mm/readahead.c:134:
+	static char class_fmt[] = "%11s";

WARNING:STATIC_CONST_CHAR_ARRAY: static char array declaration should probably be static const char
#1251: FILE: mm/readahead.c:135:
+	static char item_fmt[] = "%11lu";

WARNING:STATIC_CONST_CHAR_ARRAY: static char array declaration should probably be static const char
#1252: FILE: mm/readahead.c:136:
+	static char percent_format[] = "%10lu%%";

WARNING:STATIC_CONST_CHAR_ARRAY: char * array declaration might be better as static const
#1253: FILE: mm/readahead.c:137:
+	static char *table_name[] = {

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1278: FILE: mm/readahead.c:162:
+				seq_printf(s, item_fmt,
+						ra_event_count[c][e][i]);

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#1289: FILE: mm/readahead.c:173:
+	seq_printf(s, event_fmt, "random_rate");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1292: FILE: mm/readahead.c:176:
+		seq_printf(s, percent_format,
+			(ra_event_count[c][RA_EVENT_READRANDOM][0] * 100) /

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#1297: FILE: mm/readahead.c:181:
+	seq_printf(s, event_fmt, "ra_hit_rate");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1300: FILE: mm/readahead.c:184:
+		seq_printf(s, percent_format,
+			(ra_event_count[c][RA_EVENT_READAHEAD_HIT][1] * 100) /

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#1304: FILE: mm/readahead.c:188:
+	seq_printf(s, event_fmt, "la_hit_rate");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1307: FILE: mm/readahead.c:191:
+		seq_printf(s, percent_format,
+			(ra_event_count[c][RA_EVENT_LOOKAHEAD_HIT][0] * 100) /

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#1311: FILE: mm/readahead.c:195:
+	seq_printf(s, event_fmt, "avg_ra_size");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1314: FILE: mm/readahead.c:198:
+		seq_printf(s, item_fmt,
+			(ra_event_count[c][RA_EVENT_READAHEAD][1] +

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#1319: FILE: mm/readahead.c:203:
+	seq_printf(s, event_fmt, "avg_la_size");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1322: FILE: mm/readahead.c:206:
+		seq_printf(s, item_fmt,
+			(ra_event_count[c][RA_EVENT_LOOKAHEAD][1] +

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1338: FILE: mm/readahead.c:222:
+static ssize_t ra_debug_write(struct file *file, const char __user *buf,
+				size_t size, loff_t *offset)

WARNING:CONST_STRUCT: struct file_operations should normally be const
#1345: FILE: mm/readahead.c:229:
+static struct file_operations ra_debug_fops = {

Using const is generally a good idea.  Checkpatch reads
a list of frequently used structs that are always or
almost always constant.

The existing structs list can be viewed from
`scripts/const_structs.checkpatch`.

See: https://lore.kernel.org/lkml/alpine.DEB.2.10.1608281509480.3321@hadrien/

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1357: FILE: mm/readahead.c:241:
+	readahead_dentry = debugfs_create_file("readahead",
+					0644, NULL, NULL, &ra_debug_fops);

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros starting with if should be enclosed by a do - while loop to avoid possible if/else logic defects
#1363: FILE: mm/readahead.c:247:
+#define dprintk(args...) \
+	if (readahead_ratio & 1) printk(KERN_DEBUG args)

Macros with multiple statements should be enclosed in a
do - while block.  Same should also be the case for macros
starting with `if` to avoid logic defects::

  #define macrofun(a, b, c)                 \
    do {                                    \
            if (a == 5)                     \
                    do_this(b, c);          \
    } while (0)

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#macros-enums-and-rtl

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#1364: FILE: mm/readahead.c:248:
+	if (readahead_ratio & 1) printk(KERN_DEBUG args)

ERROR:TRAILING_STATEMENTS: trailing statements should be on next line
#1364: FILE: mm/readahead.c:248:
+	if (readahead_ratio & 1) printk(KERN_DEBUG args)

Trailing statements (for example after any conditional) should be
on the next line.
Statements, such as::

  if (x == y) break;

should be::

  if (x == y)
          break;

ERROR:MULTISTATEMENT_MACRO_USE_DO_WHILE: Macros starting with if should be enclosed by a do - while loop to avoid possible if/else logic defects
#1365: FILE: mm/readahead.c:249:
+#define ddprintk(args...) \
+	if ((readahead_ratio & 3) == 3) printk(KERN_DEBUG args)

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#1366: FILE: mm/readahead.c:250:
+	if ((readahead_ratio & 3) == 3) printk(KERN_DEBUG args)

ERROR:TRAILING_STATEMENTS: trailing statements should be on next line
#1366: FILE: mm/readahead.c:250:
+	if ((readahead_ratio & 3) == 3) printk(KERN_DEBUG args)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1371: FILE: mm/readahead.c:255:
+static inline void ra_account(struct file_ra_state *ra,
+				enum ra_event e, int pages)

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#1374: FILE: mm/readahead.c:258:
+}
+#define dprintk(args...)     do {} while(0)

ERROR:SPACING: space required before the open parenthesis '('
#1374: FILE: mm/readahead.c:258:
+#define dprintk(args...)     do {} while(0)

ERROR:SPACING: space required before the open parenthesis '('
#1375: FILE: mm/readahead.c:259:
+#define ddprintk(args...)    do {} while(0)

CHECK:LINE_SPACING: Please don't use multiple blank lines
#1379: FILE: mm/readahead.c:263:
+
+

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1441: FILE: mm/readahead.c:545:
+		if (readahead_ratio > 9 &&
+				page_idx == nr_to_read - lookahead_size)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1460: FILE: mm/readahead.c:630:
+	return __do_page_cache_readahead(mapping, filp, offset, nr_to_read, 0);
 	                                          ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1469: FILE: mm/readahead.c:650:
+	actual = __do_page_cache_readahead(mapping, filp, offset, nr_to_read, 0);
 	                                            ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1472: FILE: mm/readahead.c:653:
+	dprintk("blockable-readahead(ino=%lu, ra=%lu+%lu) = %d\n",
+			mapping->host->i_ino, offset, nr_to_read, actual);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1525: FILE: mm/readahead.c:861:
+static inline struct page *__find_page(struct address_space *mapping,
+						unsigned long offset)

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1539: FILE: mm/readahead.c:875:
+		BUG_ON(page->index != offset);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1555: FILE: mm/readahead.c:891:
+	BUG_ON(!nr_pages || !page);

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'rescue_pages', this function's name, in a string
#1560: FILE: mm/readahead.c:896:
+	dprintk("rescue_pages(ino=%lu, index=%lu nr=%lu)\n",

Embedded function names are less appropriate to use as
refactoring can cause function renaming.  Prefer the use of
"%s", __func__ to embedded function names.

Note that this does not work with -f (--file) checkpatch option
as it depends on patch context providing the function name.

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1561: FILE: mm/readahead.c:897:
+	dprintk("rescue_pages(ino=%lu, index=%lu nr=%lu)\n",
+			mapping->host->i_ino, index, nr_pages);

ERROR:SPACING: space required before the open parenthesis '('
#1563: FILE: mm/readahead.c:899:
+	for(;;) {

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1571: FILE: mm/readahead.c:907:
+		while (page_mapping(page) == mapping &&
+				page_index(page) == index) {

WARNING:LINE_SPACING: Missing a blank line after declarations
#1573: FILE: mm/readahead.c:909:
+			struct page *the_page = page;
+			page = next_page(page);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1575: FILE: mm/readahead.c:911:
+			if (!PageActive(the_page) &&
+					!PageActivate(the_page) &&

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1720: FILE: mm/readahead.c:1056:
+static inline void ra_state_init(struct file_ra_state *ra,
+				unsigned long la_index, unsigned long ra_index)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1732: FILE: mm/readahead.c:1068:
+static inline void ra_state_update(struct file_ra_state *ra,
+				unsigned long ra_size, unsigned long la_size)

WARNING:LINE_SPACING: Missing a blank line after declarations
#1736: FILE: mm/readahead.c:1072:
+	unsigned long old_ra = ra->readahead_index - ra->ra_index;
+	if (ra_size < old_ra && ra_cache_hit(ra, 0))

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1751: FILE: mm/readahead.c:1087:
+static inline void ra_state_adjust(struct file_ra_state *ra,
+				unsigned long ra_size, unsigned long la_size)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1761: FILE: mm/readahead.c:1097:
+			struct address_space *mapping, struct file *filp)
 			                                            ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1761: FILE: mm/readahead.c:1097:
+static int ra_dispatch(struct file_ra_state *ra,
+			struct address_space *mapping, struct file *filp)

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1770: FILE: mm/readahead.c:1106:
+	BUG_ON(ra_class == 0 || ra_class > RA_CLASS_END);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1781: FILE: mm/readahead.c:1117:
+		if (ra_class == RA_CLASS_CONTEXT_ACCELERATED &&
+				eof_index > ra->lookahead_index + 1)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1789: FILE: mm/readahead.c:1125:
+	actual = __do_page_cache_readahead(mapping, filp,
 	                                            ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1790: FILE: mm/readahead.c:1126:
+	actual = __do_page_cache_readahead(mapping, filp,
+					ra->ra_index, ra_size, la_size);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1801: FILE: mm/readahead.c:1137:
+	dprintk("readahead-%s(ino=%lu, index=%lu, ra=%lu+%lu-%lu) = %d\n",
+			ra_class_name[ra_class],

WARNING:TYPO_SPELLING: 'Substract' may be misspelled - perhaps 'Subtract'?
#1812: FILE: mm/readahead.c:1148:
+ *   - Substract ra_size by the old look-ahead to get real safe read-ahead;
        ^^^^^^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1823: FILE: mm/readahead.c:1159:
+static inline int adjust_rala(unsigned long ra_max,
+				unsigned long *ra_size, unsigned long *la_size)

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#1870: FILE: mm/readahead.c:1206:
+static inline unsigned long compute_thrashing_threshold(

WARNING:SPLIT_STRING: quoted string split across lines
#1893: FILE: mm/readahead.c:1229:
+	ddprintk("compute_thrashing_threshold: "
+			"ra=%lu=%lu*%lu/%lu, remain %lu for %lu\n",

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1904: FILE: mm/readahead.c:1240:
+state_based_readahead(struct address_space *mapping, struct file *filp,
                                                                   ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1905: FILE: mm/readahead.c:1241:
+state_based_readahead(struct address_space *mapping, struct file *filp,
+			struct file_ra_state *ra, struct page *page,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1918: FILE: mm/readahead.c:1254:
+	if (readahead_ratio < VM_READAHEAD_PROTECT_RATIO &&
+			remain_space <= la_size && la_size > 1) {

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1924: FILE: mm/readahead.c:1260:
+	if (!adjust_rala(min(ra_max, 2 * ra_old + (ra_max - ra_old) / 16),
+				&ra_size, &la_size))

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1930: FILE: mm/readahead.c:1266:
+	return ra_dispatch(ra, mapping, filp);
 	                                ^^^^

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1953: FILE: mm/readahead.c:1289:
+ * ^Il: the number of pages read by the stream$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1955: FILE: mm/readahead.c:1291:
+ * ^IL: the number of pages pushed into inactive_list in the mean time$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1957: FILE: mm/readahead.c:1293:
+ * ^If(l01) <= L0$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1958: FILE: mm/readahead.c:1294:
+ * ^If(l11 + l12) = L1$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1959: FILE: mm/readahead.c:1295:
+ * ^If(l21 + l22) = L2$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1960: FILE: mm/readahead.c:1296:
+ * ^I...$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1961: FILE: mm/readahead.c:1297:
+ * ^If(l01 + l11 + ...) <= Sum(L0 + L1 + ...)$

ERROR:SWITCH_CASE_INDENT_LEVEL: switch and case should be at the same indent
#1992: FILE: mm/readahead.c:1328:
+	switch (page_refcnt(page)) {
+		case 0:
[...]
+		case PAGE_REFCNT_1:
[...]
+		case PAGE_REFCNT_2:
[...]
+		case PAGE_REFCNT_3:

switch should be at the same indent as case.
Example::

  switch (suffix) {
  case 'G':
  case 'g':
          mem <<= 30;
          break;
  case 'M':
  case 'm':
          mem <<= 20;
          break;
  case 'K':
  case 'k':
          mem <<= 10;
          fallthrough;
  default:
          break;
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2010: FILE: mm/readahead.c:1346:
+static int count_cache_hit(struct address_space *mapping,
+			unsigned long first_index, unsigned long last_index)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2022: FILE: mm/readahead.c:1358:
+		page = __find_page(mapping,
+					first_index + size * steps[i++] / 8);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2036: FILE: mm/readahead.c:1372:
+static int query_page_cache(struct address_space *mapping,
+			unsigned long *remain, unsigned long offset,

ERROR:CODE_INDENT: code indent should use tabs where possible
#2043: FILE: mm/readahead.c:1379:
+        struct radix_tree_cache cache;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#2043: FILE: mm/readahead.c:1379:
+        struct radix_tree_cache cache;$

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2058: FILE: mm/readahead.c:1394:
+		BUG_ON(index > offset + 1);

ERROR:CODE_INDENT: code indent should use tabs where possible
#2088: FILE: mm/readahead.c:1424:
+        radix_tree_cache_init(&cache);$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#2088: FILE: mm/readahead.c:1424:
+        radix_tree_cache_init(&cache);$

WARNING:LINE_SPACING: Missing a blank line after declarations
#2092: FILE: mm/readahead.c:1428:
+		struct radix_tree_node *node;
+		node = radix_tree_cache_lookup_node(&mapping->page_tree,

ERROR:CODE_INDENT: code indent should use tabs where possible
#2093: FILE: mm/readahead.c:1429:
+                                                &cache, offset - step, 1);$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2093: FILE: mm/readahead.c:1429:
+		node = radix_tree_cache_lookup_node(&mapping->page_tree,
+                                                &cache, offset - step, 1);

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#2093: FILE: mm/readahead.c:1429:
+                                                &cache, offset - step, 1);$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2098: FILE: mm/readahead.c:1434:
+		if (node != radix_tree_lookup_node(&mapping->page_tree,
+							offset - step, 1)) {

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#2100: FILE: mm/readahead.c:1436:
+			printk(KERN_ERR "check radix_tree_cache_lookup_node!\n");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2125: FILE: mm/readahead.c:1461:
+static inline unsigned long first_absent_page_bw(struct address_space *mapping,
+				unsigned long index, unsigned long max_scan)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2138: FILE: mm/readahead.c:1474:
+		page = radix_tree_cache_lookup(&mapping->page_tree,
+							&cache, --index);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2155: FILE: mm/readahead.c:1491:
+static inline unsigned long first_absent_page(struct address_space *mapping,
+				unsigned long index, unsigned long max_scan)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2161: FILE: mm/readahead.c:1497:
+	ra_index = radix_tree_lookup_tail(&mapping->page_tree,
+					index + 1, max_scan);

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2165: FILE: mm/readahead.c:1501:
+	BUG_ON(ra_index <= index);

WARNING:TYPO_SPELLING: 'choosed' may be misspelled - perhaps 'chose'?
#2186: FILE: mm/readahead.c:1522:
+ * is not choosed to make the whole next chunk safe(as in normal ones). Only
           ^^^^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2192: FILE: mm/readahead.c:1528:
+static inline int adjust_rala_accelerated(unsigned long ra_max,
+				unsigned long *ra_size, unsigned long *la_size)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2213: FILE: mm/readahead.c:1549:
+try_context_based_readahead(struct address_space *mapping,
+			struct file_ra_state *ra,

CHECK:BRACES: braces {} should be used on all arms of this statement
#2228: FILE: mm/readahead.c:1564:
+	if (page) {
[...]
+	} else if (!prev_page) {
[...]
+	} else
[...]

CHECK:BRACES: Unbalanced braces around else statement
#2238: FILE: mm/readahead.c:1574:
+	} else

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2242: FILE: mm/readahead.c:1578:
+	ra_size = query_page_cache(mapping, &remain_pages,
+						index - 1, ra_min, ra_max);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2246: FILE: mm/readahead.c:1582:
+	if (readahead_ratio < VM_READAHEAD_PROTECT_RATIO &&
+			remain_pages <= la_size && la_size > 1) {

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2281: FILE: mm/readahead.c:1617:
+		struct file *filp, struct file_ra_state *ra,
 		             ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2281: FILE: mm/readahead.c:1617:
+newfile_readahead(struct address_space *mapping,
+		struct file *filp, struct file_ra_state *ra,

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2297: FILE: mm/readahead.c:1633:
+	return ra_dispatch(ra, mapping, filp);
 	                                ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2307: FILE: mm/readahead.c:1643:
+try_read_backward(struct file_ra_state *ra,
+			unsigned long begin_index, unsigned long end_index,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2346: FILE: mm/readahead.c:1682:
+try_random_readahead(struct file_ra_state *ra, unsigned long index,
+			unsigned long ra_size, unsigned long ra_max)

CHECK:BRACES: braces {} should be used on all arms of this statement
#2356: FILE: mm/readahead.c:1692:
+	if (index == ra->prev_page + 1) {    /* read after thrashing */
[...]
+	} else if (ra_size < hit1 &&         /* read after seeking   */
[...]
+	} else
[...]

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2360: FILE: mm/readahead.c:1696:
+		ra_account(ra, RA_EVENT_READAHEAD_THRASHING,
+						ra->readahead_index - index);

CHECK:BRACES: Unbalanced braces around else statement
#2367: FILE: mm/readahead.c:1703:
+	} else

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#2398: FILE: mm/readahead.c:1734:
+	*ra_min = min(min(KB(VM_MIN_READAHEAD + mem_mb/16), KB(128)), *ra_max/2);
 	                                              ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#2398: FILE: mm/readahead.c:1734:
+	*ra_min = min(min(KB(VM_MIN_READAHEAD + mem_mb/16), KB(128)), *ra_max/2);
 	                                                                     ^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2406: FILE: mm/readahead.c:1742:
+void renew_lookahead(struct address_space *mapping,
+			struct file_ra_state *ra,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2412: FILE: mm/readahead.c:1748:
+	if (index == ra->lookahead_index &&
+			new_index >= ra->readahead_index)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2441: FILE: mm/readahead.c:1777:
+			struct file_ra_state *ra, struct file *filp,
 			                                       ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2441: FILE: mm/readahead.c:1777:
+page_cache_readahead_adaptive(struct address_space *mapping,
+			struct file_ra_state *ra, struct file *filp,

ERROR:SPACING: space required before the open parenthesis '('
#2452: FILE: mm/readahead.c:1788:
+		if(!TestClearPageReadahead(page))

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2456: FILE: mm/readahead.c:1792:
+			ra_account(ra, RA_EVENT_IO_CONGESTION,
+							end_index - index);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2467: FILE: mm/readahead.c:1803:
+		ra_account(ra, RA_EVENT_LOOKAHEAD_HIT,
+				ra->readahead_index - ra->lookahead_index);

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2484: FILE: mm/readahead.c:1820:
+		return newfile_readahead(mapping, filp, ra, end_index, ra_min);
 		                                  ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2490: FILE: mm/readahead.c:1826:
+	if ((readahead_ratio % 5) == 0 &&
+		index == ra->lookahead_index &&

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2494: FILE: mm/readahead.c:1830:
+		return state_based_readahead(mapping, filp, ra, page, ra_max);
 		                                      ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2500: FILE: mm/readahead.c:1836:
+		return ra_dispatch(ra, mapping, filp);
 		                                ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2506: FILE: mm/readahead.c:1842:
+	ret = try_context_based_readahead(mapping, ra, prev_page, page,
+						index, ra_min, ra_max);

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2508: FILE: mm/readahead.c:1844:
+		return ra_dispatch(ra, mapping, filp);
 		                                ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2520: FILE: mm/readahead.c:1856:
+		return ra_dispatch(ra, mapping, filp);
 		                                ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2529: FILE: mm/readahead.c:1865:
+	size = __do_page_cache_readahead(mapping, filp, index, size, 0);
 	                                          ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2533: FILE: mm/readahead.c:1869:
+	dprintk("readrandom(ino=%lu, pages=%lu, index=%lu-%lu-%lu) = %lu\n",
+			mapping->host->i_ino, mapping->nrpages,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2552: FILE: mm/readahead.c:1888:
+			ra_account(ra, RA_EVENT_IO_BLOCK,
+					ra->readahead_index - page->index);

WARNING:TYPO_SPELLING: 'safty' may be misspelled - perhaps 'safety'?
#2570: FILE: mm/readahead.c:1906:
+ * This function provides safty guarantee for file servers with big
                           ^^^^^

WARNING:TYPO_SPELLING: 'pratical' may be misspelled - perhaps 'practical'?
#2590: FILE: mm/readahead.c:1926:
+ * In pratical, the group of pages are fragmented into chunks. To tell whether
       ^^^^^^^^

WARNING:TYPO_SPELLING: 'Sepcial' may be misspelled - perhaps 'Special'?
#2594: FILE: mm/readahead.c:1930:
+ * 3) Sepcial case: live head just sits on the boundary of current chunk?
       ^^^^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2630: FILE: mm/readahead.c:1966:
+static int save_chunk(struct page *head, struct page *live_head,
+			struct page *tail, struct list_head *save_list)

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2659: FILE: mm/readahead.c:1995:
+	BUG_ON(!mapping); /* QUESTION: in what case mapping will be NULL ? */

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2667: FILE: mm/readahead.c:2003:
+	index = radix_tree_lookup_head(&mapping->page_tree,
+						index, LIVE_PAGE_SCAN);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2698: FILE: mm/readahead.c:2034:
+	if (refcnt > page_refcnt(next_page(head)) &&
+			page_refcnt(page) > page_refcnt(next_page(head))) {

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2713: FILE: mm/readahead.c:2049:
+		page = radix_tree_cache_lookup(&mapping->page_tree, &cache,
+								--index);

WARNING:LINE_SPACING: Missing a blank line after declarations
#2744: FILE: mm/readahead.c:2080:
+		struct page *last_page = prev_page(tail);
+		page = radix_tree_cache_lookup(&mapping->page_tree, &cache,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2745: FILE: mm/readahead.c:2081:
+		page = radix_tree_cache_lookup(&mapping->page_tree, &cache,
+						last_page->index + 1);

CHECK:BRACES: braces {} should be used on all arms of this statement
#2746: FILE: mm/readahead.c:2082:
+		if (page && !live_head) {
[...]
+		} else if (!page && live_head)
[...]

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#2749: FILE: mm/readahead.c:2085:
+				page = radix_tree_cache_lookup(

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2770: FILE: mm/readahead.c:2106:
+			BUG_ON(PageAnon(page));

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#2771: FILE: mm/readahead.c:2107:
+			BUG_ON(PageSwapCache(page));

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'save_chunk', this function's name, in a string
#2805: FILE: mm/readahead.c:2141:
+		ddprintk("save_chunk(ino=%lu, idx=%lu-%lu-%lu, %s@%s:%s)"

WARNING:SPLIT_STRING: quoted string split across lines
#2806: FILE: mm/readahead.c:2142:
+		ddprintk("save_chunk(ino=%lu, idx=%lu-%lu-%lu, %s@%s:%s)"
+				" = %d\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2872: FILE: mm/readahead.c:2208:
+	if (mapping && !PageAnon(chunk_head) &&
+			!PageSwapCache(chunk_head) &&

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#3023: FILE: mm/vmscan.c:1098:
+						begin_zone = end_zone = i;

Multiple assignments on a single line makes the code unnecessarily
complicated. So on a single line assign value to a single variable
only, this makes the code more readable and helps avoid typos.

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#3043: FILE: mm/vmscan.c:1115:
+		while (end_zone < pgdat->nr_zones - 1 &&
+			pages_more_aged(pgdat->node_zones + end_zone,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#3047: FILE: mm/vmscan.c:1119:
+		while (begin_zone &&
+			pages_more_aged(pgdat->node_zones + begin_zone,

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000139408.commit.8e73d15569f5a0577a8fa73f87817b476f68864f total: 23 errors, 89 warnings, 96 checks, 2887 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000139408.commit.8e73d15569f5a0577a8fa73f87817b476f68864f has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
