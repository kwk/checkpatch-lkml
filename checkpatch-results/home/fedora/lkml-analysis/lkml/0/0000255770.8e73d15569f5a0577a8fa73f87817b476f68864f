WARNING:TYPO_SPELLING: 'beeing' may be misspelled - perhaps 'being'?
#28: 
grmp, UML folks re-added ghash.h despite beeing told repeatedly not to
                                         ^^^^^^

Some words may have been misspelled.  Consider reviewing them.

WARNING:TYPO_SPELLING: 'thge' may be misspelled - perhaps 'the'?
#30: 
again when they are on similar drugs as thge UML people.
                                        ^^^^

WARNING:COMMIT_LOG_LONG_LINE: Possible unwrapped commit description (prefer a maximum 75 chars per line)
#33: 
diff -uNr linux-2.6.9-rc1-mm1/arch/um/kernel/ghash.h linux-2.6.9-rc1-mm1-hch/arch/um/kernel/ghash.h

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#37: FILE: arch/um/kernel/ghash.h:1:
+/*

The source file is missing or has an improper SPDX identifier tag.
The Linux kernel requires the precise SPDX identifier in all source files,
and it is thoroughly documented in the kernel docs.

See: https://www.kernel.org/doc/html/latest/process/license-rules.html

CHECK:LINE_SPACING: Please don't use multiple blank lines
#50: FILE: arch/um/kernel/ghash.h:14:
+
+

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:SPACING: space required after that ',' (ctx:VxV)
#51: FILE: arch/um/kernel/ghash.h:15:
+#define DEF_HASH_FUZZY_STRUCTS(NAME,HASHSIZE,TYPE) \
                                    ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:SPACING: space required after that ',' (ctx:VxV)
#51: FILE: arch/um/kernel/ghash.h:15:
+#define DEF_HASH_FUZZY_STRUCTS(NAME,HASHSIZE,TYPE) \
                                             ^

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#51: FILE: arch/um/kernel/ghash.h:15:
+#define DEF_HASH_FUZZY_STRUCTS(NAME,HASHSIZE,TYPE) \
+\
+struct NAME##_table {\
+	TYPE * hashtable[HASHSIZE];\
+	TYPE * sorted_list;\
+	int nr_entries;\
+};\
+\
+struct NAME##_ptrs {\
+	TYPE * next_hash;\
+	TYPE * prev_hash;\
+	TYPE * next_sorted;\
+	TYPE * prev_sorted;\
+};

Macro definition should not end with a semicolon. The macro
invocation style should be consistent with function calls.
This can prevent any unexpected code paths::

  #define MAC do_something;

If this macro is used within a if else statement, like::

  if (some_condition)
          MAC;

  else
          do_something;

Then there would be a compilation error, because when the macro is
expanded there are two trailing semicolons, so the else branch gets
orphaned.

See: https://lore.kernel.org/lkml/1399671106.2912.21.camel@joe-AO725/

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#55: FILE: arch/um/kernel/ghash.h:19:
+	TYPE * sorted_list;\

When using pointer data or a function that returns a pointer type,
the preferred use of * is adjacent to the data name or function name
and not adjacent to the type name.
Examples::

  char *linux_banner;
  unsigned long long memparse(char *ptr, char **retptr);
  char *match_strdup(substring_t *s);

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#60: FILE: arch/um/kernel/ghash.h:24:
+	TYPE * next_hash;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#61: FILE: arch/um/kernel/ghash.h:25:
+	TYPE * prev_hash;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#62: FILE: arch/um/kernel/ghash.h:26:
+	TYPE * next_sorted;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#63: FILE: arch/um/kernel/ghash.h:27:
+	TYPE * prev_sorted;\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                    ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                             ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                                  ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                                       ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                                                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                                                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
                                                                                ^

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'LINKAGE' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'HASHSIZE' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'PTRS' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'PTRS' may be better as '(PTRS)' to avoid precedence issues
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'KEYTYPE' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'KEY' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'KEY' may be better as '(KEY)' to avoid precedence issues
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'KEYCMP' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'KEYCMP' may be better as '(KEYCMP)' to avoid precedence issues
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'KEYEQ' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'KEYEQ' may be better as '(KEYEQ)' to avoid precedence issues
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'HASHFN' - possible side-effects?
#66: FILE: arch/um/kernel/ghash.h:30:
+#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+\
+	ptr = prev;\
+	if(!ptr) {\
+		ptr = tbl->sorted_list;\
+		prev = NULL;\
+	} else {\
+		prev = ptr->PTRS.prev_sorted;\
+	}\
+	while(ptr) {\
+		TYPE * next = ptr->PTRS.next_hash;\
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = next;\
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
+			prev = ptr;\
+			ptr = ptr->PTRS.next_sorted;\
+		} else\
+			break;\
+	}\
+	elem->PTRS.next_sorted = ptr;\
+	elem->PTRS.prev_sorted = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_sorted = elem;\
+	}\
+	if(prev) {\
+		prev->PTRS.next_sorted = elem;\
+	} else {\
+		tbl->sorted_list = elem;\
+	}\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+\
+	next = elem->PTRS.next_sorted;\
+	prev = elem->PTRS.prev_sorted;\
+	if(next)\
+		next->PTRS.prev_sorted = prev;\
+	if(prev)\
+		prev->PTRS.next_sorted = next;\
+	else\
+		tbl->sorted_list = next;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = hashfn(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	if(ptr && !KEYEQ(ptr->KEY, pos))\
+		ptr = NULL;\
+	return ptr;\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix;\
+	int offset;\
+	TYPE * ptr;\
+	TYPE * next;\
+\
+	ptr = tbl->sorted_list;\
+	if(!ptr || KEYCMP(pos, ptr->KEY))\
+		return NULL;\
+	ix = HASHFN(pos);\
+	offset = HASHSIZE;\
+	do {\
+		offset >>= 1;\
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\
+			ptr = next;\
+	} while(offset);\
+\
+	for(;;) {\
+		next = ptr->PTRS.next_hash;\
+		if(next) {\
+			if(KEYCMP(next->KEY, pos)) {\
+				ptr = next;\
+				continue;\
+			}\
+		}\
+		next = ptr->PTRS.next_sorted;\
+		if(next && KEYCMP(next->KEY, pos)) {\
+			ptr = next;\
+			continue;\
+		}\
+		return ptr;\
+	}\
+	return NULL;\
+}

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#68: FILE: arch/um/kernel/ghash.h:32:
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#68: FILE: arch/um/kernel/ghash.h:32:
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo ** bar" should be "foo **bar"
#71: FILE: arch/um/kernel/ghash.h:35:
+	TYPE ** base = &tbl->hashtable[ix];\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#72: FILE: arch/um/kernel/ghash.h:36:
+	TYPE * ptr = *base;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#73: FILE: arch/um/kernel/ghash.h:37:
+	TYPE * prev = NULL;\

ERROR:SPACING: space required before the open parenthesis '('
#76: FILE: arch/um/kernel/ghash.h:40:
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\

ERROR:SPACING: space required after that close brace '}'
#80: FILE: arch/um/kernel/ghash.h:44:
+	}\

ERROR:SPACING: space required before the open parenthesis '('
#83: FILE: arch/um/kernel/ghash.h:47:
+	if(ptr) {\

ERROR:SPACING: space required after that close brace '}'
#85: FILE: arch/um/kernel/ghash.h:49:
+	}\

ERROR:SPACING: space required before the open parenthesis '('
#89: FILE: arch/um/kernel/ghash.h:53:
+	if(!ptr) {\

ERROR:SPACING: space required after that close brace '}'
#94: FILE: arch/um/kernel/ghash.h:58:
+	}\

ERROR:SPACING: space required before the open parenthesis '('
#95: FILE: arch/um/kernel/ghash.h:59:
+	while(ptr) {\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#96: FILE: arch/um/kernel/ghash.h:60:
+		TYPE * next = ptr->PTRS.next_hash;\

ERROR:SPACING: space required before the open parenthesis '('
#97: FILE: arch/um/kernel/ghash.h:61:
+		if(next && KEYCMP(next->KEY, elem->KEY)) {\

ERROR:SPACING: space required before the open parenthesis '('
#100: FILE: arch/um/kernel/ghash.h:64:
+		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\

ERROR:SPACING: space required after that close brace '}'
#105: FILE: arch/um/kernel/ghash.h:69:
+	}\

ERROR:SPACING: space required before the open parenthesis '('
#108: FILE: arch/um/kernel/ghash.h:72:
+	if(ptr) {\

ERROR:SPACING: space required after that close brace '}'
#110: FILE: arch/um/kernel/ghash.h:74:
+	}\

ERROR:SPACING: space required before the open parenthesis '('
#111: FILE: arch/um/kernel/ghash.h:75:
+	if(prev) {\

ERROR:SPACING: space required after that close brace '}'
#115: FILE: arch/um/kernel/ghash.h:79:
+	}\

ERROR:SPACING: space required after that close brace '}'
#116: FILE: arch/um/kernel/ghash.h:80:
+}\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#118: FILE: arch/um/kernel/ghash.h:82:
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#118: FILE: arch/um/kernel/ghash.h:82:
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#120: FILE: arch/um/kernel/ghash.h:84:
+	TYPE * next = elem->PTRS.next_hash;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#121: FILE: arch/um/kernel/ghash.h:85:
+	TYPE * prev = elem->PTRS.prev_hash;\

ERROR:SPACING: space required before the open parenthesis '('
#124: FILE: arch/um/kernel/ghash.h:88:
+	if(next)\

ERROR:SPACING: space required before the open parenthesis '('
#126: FILE: arch/um/kernel/ghash.h:90:
+	if(prev)\

ERROR:SPACING: space required after that close brace '}'
#131: FILE: arch/um/kernel/ghash.h:95:
+	}\

ERROR:SPACING: space required before the open parenthesis '('
#135: FILE: arch/um/kernel/ghash.h:99:
+	if(next)\

ERROR:SPACING: space required before the open parenthesis '('
#137: FILE: arch/um/kernel/ghash.h:101:
+	if(prev)\

ERROR:SPACING: space required after that close brace '}'
#141: FILE: arch/um/kernel/ghash.h:105:
+}\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#143: FILE: arch/um/kernel/ghash.h:107:
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#143: FILE: arch/um/kernel/ghash.h:107:
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#146: FILE: arch/um/kernel/ghash.h:110:
+	TYPE * ptr = tbl->hashtable[ix];\

ERROR:SPACING: space required before the open parenthesis '('
#147: FILE: arch/um/kernel/ghash.h:111:
+	while(ptr && KEYCMP(ptr->KEY, pos))\

ERROR:SPACING: space required before the open parenthesis '('
#149: FILE: arch/um/kernel/ghash.h:113:
+	if(ptr && !KEYEQ(ptr->KEY, pos))\

ERROR:SPACING: space required after that close brace '}'
#152: FILE: arch/um/kernel/ghash.h:116:
+}\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#154: FILE: arch/um/kernel/ghash.h:118:
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#154: FILE: arch/um/kernel/ghash.h:118:
+LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#158: FILE: arch/um/kernel/ghash.h:122:
+	TYPE * ptr;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#159: FILE: arch/um/kernel/ghash.h:123:
+	TYPE * next;\

ERROR:SPACING: space required before the open parenthesis '('
#162: FILE: arch/um/kernel/ghash.h:126:
+	if(!ptr || KEYCMP(pos, ptr->KEY))\

CHECK:SPACING: spaces preferred around that '+' (ctx:VxV)
#168: FILE: arch/um/kernel/ghash.h:132:
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
 		                         ^

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#168: FILE: arch/um/kernel/ghash.h:132:
+		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
 		                                               ^

ERROR:SPACING: space required before the open parenthesis '('
#169: FILE: arch/um/kernel/ghash.h:133:
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\

CHECK:LOGICAL_CONTINUATIONS: Logical continuations should be on the previous line
#170: FILE: arch/um/kernel/ghash.h:134:
+		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
+		   && KEYCMP(ptr->KEY, next->KEY))\

ERROR:SPACING: space required before the open parenthesis '('
#172: FILE: arch/um/kernel/ghash.h:136:
+	} while(offset);\

ERROR:SPACING: space required before the open parenthesis '('
#174: FILE: arch/um/kernel/ghash.h:138:
+	for(;;) {\

ERROR:SPACING: space required before the open parenthesis '('
#176: FILE: arch/um/kernel/ghash.h:140:
+		if(next) {\

ERROR:SPACING: space required before the open parenthesis '('
#177: FILE: arch/um/kernel/ghash.h:141:
+			if(KEYCMP(next->KEY, pos)) {\

ERROR:SPACING: space required after that close brace '}'
#180: FILE: arch/um/kernel/ghash.h:144:
+			}\

ERROR:SPACING: space required after that close brace '}'
#181: FILE: arch/um/kernel/ghash.h:145:
+		}\

ERROR:SPACING: space required before the open parenthesis '('
#183: FILE: arch/um/kernel/ghash.h:147:
+		if(next && KEYCMP(next->KEY, pos)) {\

ERROR:SPACING: space required after that close brace '}'
#186: FILE: arch/um/kernel/ghash.h:150:
+		}\

ERROR:SPACING: space required after that close brace '}'
#188: FILE: arch/um/kernel/ghash.h:152:
+	}\

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#195: FILE: arch/um/kernel/ghash.h:159:
+ * ^Iany others$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#198: FILE: arch/um/kernel/ghash.h:162:
+ * ^Ifield is of type NAME_ptrs, another is the hash key$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#200: FILE: arch/um/kernel/ghash.h:164:
+ * ^Ifield$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#204: FILE: arch/um/kernel/ghash.h:168:
+ * ^Iprototype is int KEYCMP(KEYTYPE, KEYTYPE), it returns zero for equal,$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#205: FILE: arch/um/kernel/ghash.h:169:
+ * ^Inon-zero for not equal$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#207: FILE: arch/um/kernel/ghash.h:171:
+ * ^Iit returns a number in the range 0 ... HASHSIZE - 1$

ERROR:SPACING: space required after that ',' (ctx:VxV)
#212: FILE: arch/um/kernel/ghash.h:176:
+#define DEF_HASH_STRUCTS(NAME,HASHSIZE,TYPE) \
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#212: FILE: arch/um/kernel/ghash.h:176:
+#define DEF_HASH_STRUCTS(NAME,HASHSIZE,TYPE) \
                                       ^

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#212: FILE: arch/um/kernel/ghash.h:176:
+#define DEF_HASH_STRUCTS(NAME,HASHSIZE,TYPE) \
+\
+struct NAME##_table {\
+	TYPE * hashtable[HASHSIZE];\
+	int nr_entries;\
+};\
+\
+struct NAME##_ptrs {\
+	TYPE * next_hash;\
+	TYPE * prev_hash;\
+};

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#215: FILE: arch/um/kernel/ghash.h:179:
+	TYPE * hashtable[HASHSIZE];\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#220: FILE: arch/um/kernel/ghash.h:184:
+	TYPE * next_hash;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#221: FILE: arch/um/kernel/ghash.h:185:
+	TYPE * prev_hash;\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
                         ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
                              ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
                                   ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
                                        ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
                                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
                                                    ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
                                                           ^

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'LINKAGE' - possible side-effects?
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'PTRS' - possible side-effects?
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'PTRS' may be better as '(PTRS)' to avoid precedence issues
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'KEY' - possible side-effects?
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'KEY' may be better as '(KEY)' to avoid precedence issues
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'KEYCMP' - possible side-effects?
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'KEYCMP' may be better as '(KEYCMP)' to avoid precedence issues
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'HASHFN' - possible side-effects?
#224: FILE: arch/um/kernel/ghash.h:188:
+#define DEF_HASH(LINKAGE,NAME,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,HASHFN)\
+\
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	int ix = HASHFN(elem->KEY);\
+	TYPE ** base = &tbl->hashtable[ix];\
+	TYPE * ptr = *base;\
+	TYPE * prev = NULL;\
+\
+	tbl->nr_entries++;\
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
+		base = &ptr->PTRS.next_hash;\
+		prev = ptr;\
+		ptr = *base;\
+	}\
+	elem->PTRS.next_hash = ptr;\
+	elem->PTRS.prev_hash = prev;\
+	if(ptr) {\
+		ptr->PTRS.prev_hash = elem;\
+	}\
+	*base = elem;\
+}\
+\
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\
+{\
+	TYPE * next = elem->PTRS.next_hash;\
+	TYPE * prev = elem->PTRS.prev_hash;\
+\
+	tbl->nr_entries--;\
+	if(next)\
+		next->PTRS.prev_hash = prev;\
+	if(prev)\
+		prev->PTRS.next_hash = next;\
+	else {\
+		int ix = HASHFN(elem->KEY);\
+		tbl->hashtable[ix] = next;\
+	}\
+}\
+\
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\
+{\
+	int ix = HASHFN(pos);\
+	TYPE * ptr = tbl->hashtable[ix];\
+	while(ptr && KEYCMP(ptr->KEY, pos))\
+		ptr = ptr->PTRS.next_hash;\
+	return ptr;\
+}

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#226: FILE: arch/um/kernel/ghash.h:190:
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#226: FILE: arch/um/kernel/ghash.h:190:
+LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo ** bar" should be "foo **bar"
#229: FILE: arch/um/kernel/ghash.h:193:
+	TYPE ** base = &tbl->hashtable[ix];\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#230: FILE: arch/um/kernel/ghash.h:194:
+	TYPE * ptr = *base;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#231: FILE: arch/um/kernel/ghash.h:195:
+	TYPE * prev = NULL;\

ERROR:SPACING: space required before the open parenthesis '('
#234: FILE: arch/um/kernel/ghash.h:198:
+	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\

ERROR:SPACING: space required after that close brace '}'
#238: FILE: arch/um/kernel/ghash.h:202:
+	}\

ERROR:SPACING: space required before the open parenthesis '('
#241: FILE: arch/um/kernel/ghash.h:205:
+	if(ptr) {\

ERROR:SPACING: space required after that close brace '}'
#243: FILE: arch/um/kernel/ghash.h:207:
+	}\

ERROR:SPACING: space required after that close brace '}'
#245: FILE: arch/um/kernel/ghash.h:209:
+}\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#247: FILE: arch/um/kernel/ghash.h:211:
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#247: FILE: arch/um/kernel/ghash.h:211:
+LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#249: FILE: arch/um/kernel/ghash.h:213:
+	TYPE * next = elem->PTRS.next_hash;\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#250: FILE: arch/um/kernel/ghash.h:214:
+	TYPE * prev = elem->PTRS.prev_hash;\

ERROR:SPACING: space required before the open parenthesis '('
#253: FILE: arch/um/kernel/ghash.h:217:
+	if(next)\

ERROR:SPACING: space required before the open parenthesis '('
#255: FILE: arch/um/kernel/ghash.h:219:
+	if(prev)\

ERROR:SPACING: space required after that close brace '}'
#260: FILE: arch/um/kernel/ghash.h:224:
+	}\

ERROR:SPACING: space required after that close brace '}'
#261: FILE: arch/um/kernel/ghash.h:225:
+}\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#263: FILE: arch/um/kernel/ghash.h:227:
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#263: FILE: arch/um/kernel/ghash.h:227:
+LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)\

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#266: FILE: arch/um/kernel/ghash.h:230:
+	TYPE * ptr = tbl->hashtable[ix];\

ERROR:SPACING: space required before the open parenthesis '('
#267: FILE: arch/um/kernel/ghash.h:231:
+	while(ptr && KEYCMP(ptr->KEY, pos))\

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000255770.commit.8e73d15569f5a0577a8fa73f87817b476f68864f total: 102 errors, 12 warnings, 24 checks, 250 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000255770.commit.8e73d15569f5a0577a8fa73f87817b476f68864f has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
