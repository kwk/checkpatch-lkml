WARNING:TYPO_SPELLING: 'implementaion' may be misspelled - perhaps 'implementation'?
#35: 
This is implementaion of circular doubly linked parametrized list.
        ^^^^^^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

WARNING:COMMIT_LOG_LONG_LINE: Possible unwrapped commit description (prefer a maximum 75 chars per line)
#37: 
but it also provides type safety which allows to detect some of list manipulating

WARNING:TYPO_SPELLING: 'implementaion' may be misspelled - perhaps 'implementation'?
#53: 
This is implementaion of circular doubly linked parametrized list.
        ^^^^^^^^^^^^^

WARNING:SPDX_LICENSE_TAG: Missing or malformed SPDX-License-Identifier tag in line 1
#66: FILE: include/linux/type_safe_list.h:1:
+#ifndef _LINUX_TYPE_SAFE_LIST_H

The source file is missing or has an improper SPDX identifier tag.
The Linux kernel requires the precise SPDX identifier in all source files,
and it is thoroughly documented in the kernel docs.

See: https://www.kernel.org/doc/html/latest/process/license-rules.html

WARNING:BLOCK_COMMENT_STYLE: Block comments use * on subsequent lines
#70: FILE: include/linux/type_safe_list.h:5:
+/* A circular doubly linked list that differs from the previous
+   <linux/list.h> implementation because it is parametrized to provide

The comment style is incorrect.  The preferred style for multi-
line comments is::

  /*
  * This is the preferred style
  * for multi line comments.
  */

The networking comment style is a bit different, with the first line
not empty like the former::

  /* This is the preferred comment style
  * for files in net/ and drivers/net/
  */

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#commenting

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'name' - possible side-effects?
#132: FILE: include/linux/type_safe_list.h:67:
+#define TYPE_SAFE_LIST_LINK_INIT(name) { &(name), &(name) }

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'name' - possible side-effects?
#133: FILE: include/linux/type_safe_list.h:68:
+#define TYPE_SAFE_LIST_HEAD_INIT(name) { (void *)&(name), (void *)&(name) }

ERROR:SPACING: space required after that ',' (ctx:VxV)
#137: FILE: include/linux/type_safe_list.h:72:
+#define TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,LINK) \
                                  ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:SPACING: space required after that ',' (ctx:VxV)
#137: FILE: include/linux/type_safe_list.h:72:
+#define TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,LINK) \
                                            ^

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'ITEM_TYPE' - possible side-effects?
#137: FILE: include/linux/type_safe_list.h:72:
+#define TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,LINK) \
+	((ITEM_TYPE *)((char *)(LINK)-(unsigned long)(&((ITEM_TYPE *)0)->LINK_NAME)))

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'ITEM_TYPE' may be better as '(ITEM_TYPE)' to avoid precedence issues
#137: FILE: include/linux/type_safe_list.h:72:
+#define TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,LINK) \
+	((ITEM_TYPE *)((char *)(LINK)-(unsigned long)(&((ITEM_TYPE *)0)->LINK_NAME)))

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'LINK_NAME' may be better as '(LINK_NAME)' to avoid precedence issues
#137: FILE: include/linux/type_safe_list.h:72:
+#define TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,LINK) \
+	((ITEM_TYPE *)((char *)(LINK)-(unsigned long)(&((ITEM_TYPE *)0)->LINK_NAME)))

CHECK:SPACING: spaces preferred around that '-' (ctx:VxV)
#138: FILE: include/linux/type_safe_list.h:73:
+	((ITEM_TYPE *)((char *)(LINK)-(unsigned long)(&((ITEM_TYPE *)0)->LINK_NAME)))
 	                             ^

WARNING:BLOCK_COMMENT_STYLE: Block comments use * on subsequent lines
#141: FILE: include/linux/type_safe_list.h:76:
+/* Step 1: Use the TYPE_SAFE_LIST_DECLARE() macro to define the "list head"
+   and "list link" objects.  This macro takes one arguments, the

WARNING:NEW_TYPEDEFS: do not add new typedefs
#152: FILE: include/linux/type_safe_list.h:87:
+typedef struct _##PREFIX##_list_head        PREFIX##_list_head;	\

WARNING:NEW_TYPEDEFS: do not add new typedefs
#153: FILE: include/linux/type_safe_list.h:88:
+typedef struct _##PREFIX##_list_link        PREFIX##_list_link;	\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#157: FILE: include/linux/type_safe_list.h:92:
+	PREFIX##_list_link *_next;				\
 	                   ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#158: FILE: include/linux/type_safe_list.h:93:
+	PREFIX##_list_link *_prev;				\
 	                   ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#163: FILE: include/linux/type_safe_list.h:98:
+	PREFIX##_list_link *_next;				\
 	                   ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#164: FILE: include/linux/type_safe_list.h:99:
+	PREFIX##_list_link *_prev;				\
 	                   ^

WARNING:BLOCK_COMMENT_STYLE: Block comments use * on subsequent lines
#168: FILE: include/linux/type_safe_list.h:103:
+/* Step 2: Once you have defined the two list classes, you should
+   define the item type you intend to use.  The list classes must be

WARNING:BLOCK_COMMENT_STYLE: Block comments use * on subsequent lines
#187: FILE: include/linux/type_safe_list.h:122:
+/* Step 3: The final step will define the list-functions for a
+   specific list class using the macro TYPE_SAFE_LIST_DEFINE.  There are

WARNING:LONG_LINE_COMMENT: line length of 102 exceeds 100 columns
#207: FILE: include/linux/type_safe_list.h:142:
+   rx_event_list_remove_get_next  Remove an item from anywhere in the list and return the next element

A comment starts before but extends beyond the maximum line length.
To use a different maximum line length, the --max-line-length=n option
may be added while invoking checkpatch.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#breaking-long-lines-and-strings

WARNING:LONG_LINE_COMMENT: line length of 102 exceeds 100 columns
#208: FILE: include/linux/type_safe_list.h:143:
+   rx_event_list_remove_get_prev  Remove an item from anywhere in the list and return the prev element

ERROR:CODE_INDENT: code indent should use tabs where possible
#219: FILE: include/linux/type_safe_list.h:154:
+                                  list invariants. For debugging.$

Code indent should use tabs instead of spaces.
Outside of comments, documentation and Kconfig,
spaces are never used for indentation.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

ERROR:CODE_INDENT: code indent should use tabs where possible
#227: FILE: include/linux/type_safe_list.h:162:
+               ! rx_event_list_end   (head, item);$

ERROR:CODE_INDENT: code indent should use tabs where possible
#228: FILE: include/linux/type_safe_list.h:163:
+          item = rx_event_list_next  (item))$

ERROR:SPACING: space required after that ',' (ctx:VxV)
#231: FILE: include/linux/type_safe_list.h:166:
+#define TYPE_SAFE_LIST_DEFINE(PREFIX,ITEM_TYPE,LINK_NAME)					\
                                     ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#231: FILE: include/linux/type_safe_list.h:166:
+#define TYPE_SAFE_LIST_DEFINE(PREFIX,ITEM_TYPE,LINK_NAME)					\
                                               ^

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'ITEM_TYPE' - possible side-effects?
#231: FILE: include/linux/type_safe_list.h:166:
+#define TYPE_SAFE_LIST_DEFINE(PREFIX,ITEM_TYPE,LINK_NAME)					\
+												\
+static __inline__ int										\
+PREFIX##_list_link_invariant (const PREFIX##_list_link  *_link)					\
+{												\
+	return (_link != NULL) &&								\
+		(_link->_prev != NULL) && (_link->_next != NULL ) &&				\
+		(_link->_prev->_next == _link) &&						\
+		(_link->_next->_prev == _link);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_link_ok (const PREFIX##_list_link  *_link UNUSED_ARG)				\
+{												\
+	BUG_ON(!PREFIX##_list_link_invariant (_link));						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_object_ok (const ITEM_TYPE           *item)					\
+{												\
+	PREFIX##_list_link_ok (&item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_init (PREFIX##_list_head  *head)							\
+{												\
+	head->_next = (PREFIX##_list_link*) head;						\
+	head->_prev = (PREFIX##_list_link*) head;						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_clean (ITEM_TYPE           *item)							\
+{												\
+	PREFIX##_list_link *_link = &item->LINK_NAME;						\
+												\
+	_link->_next = _link;									\
+	_link->_prev = _link;									\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_is_clean (const ITEM_TYPE           *item)					\
+{												\
+	const PREFIX##_list_link *_link = &item->LINK_NAME;					\
+												\
+	PREFIX##_list_link_ok (_link);								\
+	return (_link == _link->_next) && (_link == _link->_prev);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_int (PREFIX##_list_link  *next,						\
+			  PREFIX##_list_link  *item)						\
+{												\
+	PREFIX##_list_link *prev = next->_prev;							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = item;									\
+	item->_next = next;									\
+	item->_prev = prev;									\
+	prev->_next = item;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	PREFIX##_list_link_ok (item);								\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_front (PREFIX##_list_head  *head,						\
+			  ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (head->_next, & item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_back (PREFIX##_list_head  *head,						\
+			 ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int ((PREFIX##_list_link *) head, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_before (ITEM_TYPE         *reference,					\
+			     ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (& reference->LINK_NAME, & item->LINK_NAME);			\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_after (ITEM_TYPE         *reference,					\
+			    ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (reference->LINK_NAME._next, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ PREFIX##_list_link*								\
+PREFIX##_list_remove_int (PREFIX##_list_link *list_link)					\
+{												\
+	PREFIX##_list_link *next = list_link->_next;						\
+	PREFIX##_list_link *prev = list_link->_prev;						\
+	PREFIX##_list_link_ok (list_link);							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = prev;									\
+	prev->_next = next;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	return list_link;									\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove (ITEM_TYPE  *item)								\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove_clean (ITEM_TYPE  *item)							\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	PREFIX##_list_clean (item);								\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_next (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *next = item->LINK_NAME._next;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,next);					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_prev (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *prev = item->LINK_NAME._prev;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,prev);					\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_empty (const PREFIX##_list_head  *head)						\
+{												\
+	return head == (PREFIX##_list_head*) head->_next;					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_front (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head));							\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_next));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_back (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head)); /* WWI started */					\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_prev));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_front (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_next);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_back (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_prev);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_next (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._next);			\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_prev (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._prev);			\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_end (const PREFIX##_list_head  *head,						\
+ 		   const ITEM_TYPE           *item)						\
+{												\
+	return ((PREFIX##_list_link *) head) == (& item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_splice (PREFIX##_list_head  *head_join,						\
+ 		      PREFIX##_list_head  *head_empty)						\
+{												\
+	if (PREFIX##_list_empty (head_empty)) {							\
+		return;										\
+	}											\
+												\
+	head_empty->_prev->_next = (PREFIX##_list_link*) head_join;				\
+	head_empty->_next->_prev = head_join->_prev;						\
+												\
+	head_join->_prev->_next  = head_empty->_next;						\
+	head_join->_prev         = head_empty->_prev;						\
+												\
+	PREFIX##_list_link_ok ((PREFIX##_list_link*) head_join);				\
+	PREFIX##_list_link_ok (head_join->_prev);						\
+	PREFIX##_list_link_ok (head_join->_next);						\
+												\
+	PREFIX##_list_init (head_empty);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_split(PREFIX##_list_head  *head_split,						\
+		    PREFIX##_list_head  *head_new,						\
+		    ITEM_TYPE  *item)								\
+{												\
+	BUG_ON(!PREFIX##_list_empty(head_new));							\
+												\
+	/* attach to new list */								\
+	head_new->_next = (& item->LINK_NAME);							\
+	head_new->_prev = head_split->_prev;							\
+												\
+	/* cut from old list */									\
+	item->LINK_NAME._prev->_next = (PREFIX##_list_link*)head_split;				\
+	head_split->_prev = item->LINK_NAME._prev;						\
+												\
+	/* link new list */									\
+	head_new->_next->_prev = (PREFIX##_list_link*)head_new;					\
+	head_new->_prev->_next = (PREFIX##_list_link*)head_new;					\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_check (const PREFIX##_list_head  *head)						\
+{												\
+	const PREFIX##_list_link *link;								\
+												\
+	for (link = head->_next ; link != ((PREFIX##_list_link *) head) ; link = link->_next)	\
+		PREFIX##_list_link_ok (link);							\
+}												\
+												\
+typedef struct { int foo; } PREFIX##_list_dummy_decl

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'ITEM_TYPE' may be better as '(ITEM_TYPE)' to avoid precedence issues
#231: FILE: include/linux/type_safe_list.h:166:
+#define TYPE_SAFE_LIST_DEFINE(PREFIX,ITEM_TYPE,LINK_NAME)					\
+												\
+static __inline__ int										\
+PREFIX##_list_link_invariant (const PREFIX##_list_link  *_link)					\
+{												\
+	return (_link != NULL) &&								\
+		(_link->_prev != NULL) && (_link->_next != NULL ) &&				\
+		(_link->_prev->_next == _link) &&						\
+		(_link->_next->_prev == _link);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_link_ok (const PREFIX##_list_link  *_link UNUSED_ARG)				\
+{												\
+	BUG_ON(!PREFIX##_list_link_invariant (_link));						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_object_ok (const ITEM_TYPE           *item)					\
+{												\
+	PREFIX##_list_link_ok (&item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_init (PREFIX##_list_head  *head)							\
+{												\
+	head->_next = (PREFIX##_list_link*) head;						\
+	head->_prev = (PREFIX##_list_link*) head;						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_clean (ITEM_TYPE           *item)							\
+{												\
+	PREFIX##_list_link *_link = &item->LINK_NAME;						\
+												\
+	_link->_next = _link;									\
+	_link->_prev = _link;									\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_is_clean (const ITEM_TYPE           *item)					\
+{												\
+	const PREFIX##_list_link *_link = &item->LINK_NAME;					\
+												\
+	PREFIX##_list_link_ok (_link);								\
+	return (_link == _link->_next) && (_link == _link->_prev);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_int (PREFIX##_list_link  *next,						\
+			  PREFIX##_list_link  *item)						\
+{												\
+	PREFIX##_list_link *prev = next->_prev;							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = item;									\
+	item->_next = next;									\
+	item->_prev = prev;									\
+	prev->_next = item;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	PREFIX##_list_link_ok (item);								\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_front (PREFIX##_list_head  *head,						\
+			  ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (head->_next, & item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_back (PREFIX##_list_head  *head,						\
+			 ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int ((PREFIX##_list_link *) head, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_before (ITEM_TYPE         *reference,					\
+			     ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (& reference->LINK_NAME, & item->LINK_NAME);			\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_after (ITEM_TYPE         *reference,					\
+			    ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (reference->LINK_NAME._next, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ PREFIX##_list_link*								\
+PREFIX##_list_remove_int (PREFIX##_list_link *list_link)					\
+{												\
+	PREFIX##_list_link *next = list_link->_next;						\
+	PREFIX##_list_link *prev = list_link->_prev;						\
+	PREFIX##_list_link_ok (list_link);							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = prev;									\
+	prev->_next = next;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	return list_link;									\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove (ITEM_TYPE  *item)								\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove_clean (ITEM_TYPE  *item)							\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	PREFIX##_list_clean (item);								\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_next (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *next = item->LINK_NAME._next;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,next);					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_prev (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *prev = item->LINK_NAME._prev;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,prev);					\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_empty (const PREFIX##_list_head  *head)						\
+{												\
+	return head == (PREFIX##_list_head*) head->_next;					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_front (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head));							\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_next));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_back (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head)); /* WWI started */					\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_prev));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_front (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_next);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_back (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_prev);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_next (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._next);			\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_prev (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._prev);			\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_end (const PREFIX##_list_head  *head,						\
+ 		   const ITEM_TYPE           *item)						\
+{												\
+	return ((PREFIX##_list_link *) head) == (& item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_splice (PREFIX##_list_head  *head_join,						\
+ 		      PREFIX##_list_head  *head_empty)						\
+{												\
+	if (PREFIX##_list_empty (head_empty)) {							\
+		return;										\
+	}											\
+												\
+	head_empty->_prev->_next = (PREFIX##_list_link*) head_join;				\
+	head_empty->_next->_prev = head_join->_prev;						\
+												\
+	head_join->_prev->_next  = head_empty->_next;						\
+	head_join->_prev         = head_empty->_prev;						\
+												\
+	PREFIX##_list_link_ok ((PREFIX##_list_link*) head_join);				\
+	PREFIX##_list_link_ok (head_join->_prev);						\
+	PREFIX##_list_link_ok (head_join->_next);						\
+												\
+	PREFIX##_list_init (head_empty);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_split(PREFIX##_list_head  *head_split,						\
+		    PREFIX##_list_head  *head_new,						\
+		    ITEM_TYPE  *item)								\
+{												\
+	BUG_ON(!PREFIX##_list_empty(head_new));							\
+												\
+	/* attach to new list */								\
+	head_new->_next = (& item->LINK_NAME);							\
+	head_new->_prev = head_split->_prev;							\
+												\
+	/* cut from old list */									\
+	item->LINK_NAME._prev->_next = (PREFIX##_list_link*)head_split;				\
+	head_split->_prev = item->LINK_NAME._prev;						\
+												\
+	/* link new list */									\
+	head_new->_next->_prev = (PREFIX##_list_link*)head_new;					\
+	head_new->_prev->_next = (PREFIX##_list_link*)head_new;					\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_check (const PREFIX##_list_head  *head)						\
+{												\
+	const PREFIX##_list_link *link;								\
+												\
+	for (link = head->_next ; link != ((PREFIX##_list_link *) head) ; link = link->_next)	\
+		PREFIX##_list_link_ok (link);							\
+}												\
+												\
+typedef struct { int foo; } PREFIX##_list_dummy_decl

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'LINK_NAME' - possible side-effects?
#231: FILE: include/linux/type_safe_list.h:166:
+#define TYPE_SAFE_LIST_DEFINE(PREFIX,ITEM_TYPE,LINK_NAME)					\
+												\
+static __inline__ int										\
+PREFIX##_list_link_invariant (const PREFIX##_list_link  *_link)					\
+{												\
+	return (_link != NULL) &&								\
+		(_link->_prev != NULL) && (_link->_next != NULL ) &&				\
+		(_link->_prev->_next == _link) &&						\
+		(_link->_next->_prev == _link);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_link_ok (const PREFIX##_list_link  *_link UNUSED_ARG)				\
+{												\
+	BUG_ON(!PREFIX##_list_link_invariant (_link));						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_object_ok (const ITEM_TYPE           *item)					\
+{												\
+	PREFIX##_list_link_ok (&item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_init (PREFIX##_list_head  *head)							\
+{												\
+	head->_next = (PREFIX##_list_link*) head;						\
+	head->_prev = (PREFIX##_list_link*) head;						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_clean (ITEM_TYPE           *item)							\
+{												\
+	PREFIX##_list_link *_link = &item->LINK_NAME;						\
+												\
+	_link->_next = _link;									\
+	_link->_prev = _link;									\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_is_clean (const ITEM_TYPE           *item)					\
+{												\
+	const PREFIX##_list_link *_link = &item->LINK_NAME;					\
+												\
+	PREFIX##_list_link_ok (_link);								\
+	return (_link == _link->_next) && (_link == _link->_prev);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_int (PREFIX##_list_link  *next,						\
+			  PREFIX##_list_link  *item)						\
+{												\
+	PREFIX##_list_link *prev = next->_prev;							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = item;									\
+	item->_next = next;									\
+	item->_prev = prev;									\
+	prev->_next = item;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	PREFIX##_list_link_ok (item);								\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_front (PREFIX##_list_head  *head,						\
+			  ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (head->_next, & item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_back (PREFIX##_list_head  *head,						\
+			 ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int ((PREFIX##_list_link *) head, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_before (ITEM_TYPE         *reference,					\
+			     ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (& reference->LINK_NAME, & item->LINK_NAME);			\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_after (ITEM_TYPE         *reference,					\
+			    ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (reference->LINK_NAME._next, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ PREFIX##_list_link*								\
+PREFIX##_list_remove_int (PREFIX##_list_link *list_link)					\
+{												\
+	PREFIX##_list_link *next = list_link->_next;						\
+	PREFIX##_list_link *prev = list_link->_prev;						\
+	PREFIX##_list_link_ok (list_link);							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = prev;									\
+	prev->_next = next;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	return list_link;									\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove (ITEM_TYPE  *item)								\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove_clean (ITEM_TYPE  *item)							\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	PREFIX##_list_clean (item);								\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_next (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *next = item->LINK_NAME._next;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,next);					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_prev (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *prev = item->LINK_NAME._prev;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,prev);					\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_empty (const PREFIX##_list_head  *head)						\
+{												\
+	return head == (PREFIX##_list_head*) head->_next;					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_front (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head));							\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_next));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_back (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head)); /* WWI started */					\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_prev));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_front (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_next);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_back (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_prev);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_next (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._next);			\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_prev (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._prev);			\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_end (const PREFIX##_list_head  *head,						\
+ 		   const ITEM_TYPE           *item)						\
+{												\
+	return ((PREFIX##_list_link *) head) == (& item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_splice (PREFIX##_list_head  *head_join,						\
+ 		      PREFIX##_list_head  *head_empty)						\
+{												\
+	if (PREFIX##_list_empty (head_empty)) {							\
+		return;										\
+	}											\
+												\
+	head_empty->_prev->_next = (PREFIX##_list_link*) head_join;				\
+	head_empty->_next->_prev = head_join->_prev;						\
+												\
+	head_join->_prev->_next  = head_empty->_next;						\
+	head_join->_prev         = head_empty->_prev;						\
+												\
+	PREFIX##_list_link_ok ((PREFIX##_list_link*) head_join);				\
+	PREFIX##_list_link_ok (head_join->_prev);						\
+	PREFIX##_list_link_ok (head_join->_next);						\
+												\
+	PREFIX##_list_init (head_empty);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_split(PREFIX##_list_head  *head_split,						\
+		    PREFIX##_list_head  *head_new,						\
+		    ITEM_TYPE  *item)								\
+{												\
+	BUG_ON(!PREFIX##_list_empty(head_new));							\
+												\
+	/* attach to new list */								\
+	head_new->_next = (& item->LINK_NAME);							\
+	head_new->_prev = head_split->_prev;							\
+												\
+	/* cut from old list */									\
+	item->LINK_NAME._prev->_next = (PREFIX##_list_link*)head_split;				\
+	head_split->_prev = item->LINK_NAME._prev;						\
+												\
+	/* link new list */									\
+	head_new->_next->_prev = (PREFIX##_list_link*)head_new;					\
+	head_new->_prev->_next = (PREFIX##_list_link*)head_new;					\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_check (const PREFIX##_list_head  *head)						\
+{												\
+	const PREFIX##_list_link *link;								\
+												\
+	for (link = head->_next ; link != ((PREFIX##_list_link *) head) ; link = link->_next)	\
+		PREFIX##_list_link_ok (link);							\
+}												\
+												\
+typedef struct { int foo; } PREFIX##_list_dummy_decl

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'LINK_NAME' may be better as '(LINK_NAME)' to avoid precedence issues
#231: FILE: include/linux/type_safe_list.h:166:
+#define TYPE_SAFE_LIST_DEFINE(PREFIX,ITEM_TYPE,LINK_NAME)					\
+												\
+static __inline__ int										\
+PREFIX##_list_link_invariant (const PREFIX##_list_link  *_link)					\
+{												\
+	return (_link != NULL) &&								\
+		(_link->_prev != NULL) && (_link->_next != NULL ) &&				\
+		(_link->_prev->_next == _link) &&						\
+		(_link->_next->_prev == _link);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_link_ok (const PREFIX##_list_link  *_link UNUSED_ARG)				\
+{												\
+	BUG_ON(!PREFIX##_list_link_invariant (_link));						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_object_ok (const ITEM_TYPE           *item)					\
+{												\
+	PREFIX##_list_link_ok (&item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_init (PREFIX##_list_head  *head)							\
+{												\
+	head->_next = (PREFIX##_list_link*) head;						\
+	head->_prev = (PREFIX##_list_link*) head;						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_clean (ITEM_TYPE           *item)							\
+{												\
+	PREFIX##_list_link *_link = &item->LINK_NAME;						\
+												\
+	_link->_next = _link;									\
+	_link->_prev = _link;									\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_is_clean (const ITEM_TYPE           *item)					\
+{												\
+	const PREFIX##_list_link *_link = &item->LINK_NAME;					\
+												\
+	PREFIX##_list_link_ok (_link);								\
+	return (_link == _link->_next) && (_link == _link->_prev);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_int (PREFIX##_list_link  *next,						\
+			  PREFIX##_list_link  *item)						\
+{												\
+	PREFIX##_list_link *prev = next->_prev;							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = item;									\
+	item->_next = next;									\
+	item->_prev = prev;									\
+	prev->_next = item;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	PREFIX##_list_link_ok (item);								\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_front (PREFIX##_list_head  *head,						\
+			  ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (head->_next, & item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_push_back (PREFIX##_list_head  *head,						\
+			 ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int ((PREFIX##_list_link *) head, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_before (ITEM_TYPE         *reference,					\
+			     ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (& reference->LINK_NAME, & item->LINK_NAME);			\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_insert_after (ITEM_TYPE         *reference,					\
+			    ITEM_TYPE           *item)						\
+{												\
+	PREFIX##_list_insert_int (reference->LINK_NAME._next, & item->LINK_NAME);		\
+}												\
+												\
+static __inline__ PREFIX##_list_link*								\
+PREFIX##_list_remove_int (PREFIX##_list_link *list_link)					\
+{												\
+	PREFIX##_list_link *next = list_link->_next;						\
+	PREFIX##_list_link *prev = list_link->_prev;						\
+	PREFIX##_list_link_ok (list_link);							\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	next->_prev = prev;									\
+	prev->_next = next;									\
+	PREFIX##_list_link_ok (next);								\
+	PREFIX##_list_link_ok (prev);								\
+	return list_link;									\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove (ITEM_TYPE  *item)								\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_remove_clean (ITEM_TYPE  *item)							\
+{												\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	PREFIX##_list_clean (item);								\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_next (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *next = item->LINK_NAME._next;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,next);					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_remove_get_prev (ITEM_TYPE  *item)						\
+{												\
+	PREFIX##_list_link *prev = item->LINK_NAME._prev;					\
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,prev);					\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_empty (const PREFIX##_list_head  *head)						\
+{												\
+	return head == (PREFIX##_list_head*) head->_next;					\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_front (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head));							\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_next));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_pop_back (PREFIX##_list_head  *head)						\
+{												\
+	BUG_ON(PREFIX##_list_empty (head)); /* WWI started */					\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_prev));	\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_front (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_next);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_back (const PREFIX##_list_head  *head)						\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_prev);				\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_next (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._next);			\
+}												\
+												\
+static __inline__ ITEM_TYPE*									\
+PREFIX##_list_prev (const ITEM_TYPE *item)							\
+{												\
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._prev);			\
+}												\
+												\
+static __inline__ int										\
+PREFIX##_list_end (const PREFIX##_list_head  *head,						\
+ 		   const ITEM_TYPE           *item)						\
+{												\
+	return ((PREFIX##_list_link *) head) == (& item->LINK_NAME);				\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_splice (PREFIX##_list_head  *head_join,						\
+ 		      PREFIX##_list_head  *head_empty)						\
+{												\
+	if (PREFIX##_list_empty (head_empty)) {							\
+		return;										\
+	}											\
+												\
+	head_empty->_prev->_next = (PREFIX##_list_link*) head_join;				\
+	head_empty->_next->_prev = head_join->_prev;						\
+												\
+	head_join->_prev->_next  = head_empty->_next;						\
+	head_join->_prev         = head_empty->_prev;						\
+												\
+	PREFIX##_list_link_ok ((PREFIX##_list_link*) head_join);				\
+	PREFIX##_list_link_ok (head_join->_prev);						\
+	PREFIX##_list_link_ok (head_join->_next);						\
+												\
+	PREFIX##_list_init (head_empty);							\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_split(PREFIX##_list_head  *head_split,						\
+		    PREFIX##_list_head  *head_new,						\
+		    ITEM_TYPE  *item)								\
+{												\
+	BUG_ON(!PREFIX##_list_empty(head_new));							\
+												\
+	/* attach to new list */								\
+	head_new->_next = (& item->LINK_NAME);							\
+	head_new->_prev = head_split->_prev;							\
+												\
+	/* cut from old list */									\
+	item->LINK_NAME._prev->_next = (PREFIX##_list_link*)head_split;				\
+	head_split->_prev = item->LINK_NAME._prev;						\
+												\
+	/* link new list */									\
+	head_new->_next->_prev = (PREFIX##_list_link*)head_new;					\
+	head_new->_prev->_next = (PREFIX##_list_link*)head_new;					\
+}												\
+												\
+static __inline__ void										\
+PREFIX##_list_check (const PREFIX##_list_head  *head)						\
+{												\
+	const PREFIX##_list_link *link;								\
+												\
+	for (link = head->_next ; link != ((PREFIX##_list_link *) head) ; link = link->_next)	\
+		PREFIX##_list_link_ok (link);							\
+}												\
+												\
+typedef struct { int foo; } PREFIX##_list_dummy_decl

WARNING:INLINE: plain inline is preferred over __inline__
#233: FILE: include/linux/type_safe_list.h:168:
+static __inline__ int										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#234: FILE: include/linux/type_safe_list.h:169:
+PREFIX##_list_link_invariant (const PREFIX##_list_link  *_link)					\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#234: FILE: include/linux/type_safe_list.h:169:
+PREFIX##_list_link_invariant (const PREFIX##_list_link  *_link)					\
                                                         ^

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "_link"
#236: FILE: include/linux/type_safe_list.h:171:
+	return (_link != NULL) &&								\

Comparisons to NULL in the form (foo == NULL) or (foo != NULL)
are better written as (!foo) and (foo).

ERROR:SPACING: space prohibited before that close parenthesis ')'
#237: FILE: include/linux/type_safe_list.h:172:
+		(_link->_prev != NULL) && (_link->_next != NULL ) &&				\

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "_link->_prev"
#237: FILE: include/linux/type_safe_list.h:172:
+		(_link->_prev != NULL) && (_link->_next != NULL ) &&				\

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "_link->_next"
#237: FILE: include/linux/type_safe_list.h:172:
+		(_link->_prev != NULL) && (_link->_next != NULL ) &&				\

WARNING:INLINE: plain inline is preferred over __inline__
#242: FILE: include/linux/type_safe_list.h:177:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#243: FILE: include/linux/type_safe_list.h:178:
+PREFIX##_list_link_ok (const PREFIX##_list_link  *_link UNUSED_ARG)				\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#243: FILE: include/linux/type_safe_list.h:178:
+PREFIX##_list_link_ok (const PREFIX##_list_link  *_link UNUSED_ARG)				\
                                                  ^

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#245: FILE: include/linux/type_safe_list.h:180:
+	BUG_ON(!PREFIX##_list_link_invariant (_link));						\

BUG() or BUG_ON() should be avoided totally.
Use WARN() and WARN_ON() instead, and handle the "impossible"
error condition as gracefully as possible.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#bug-and-bug-on

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#245: FILE: include/linux/type_safe_list.h:180:
+	BUG_ON(!PREFIX##_list_link_invariant (_link));						\

WARNING:INLINE: plain inline is preferred over __inline__
#248: FILE: include/linux/type_safe_list.h:183:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#249: FILE: include/linux/type_safe_list.h:184:
+PREFIX##_list_object_ok (const ITEM_TYPE           *item)					\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#251: FILE: include/linux/type_safe_list.h:186:
+	PREFIX##_list_link_ok (&item->LINK_NAME);						\

WARNING:INLINE: plain inline is preferred over __inline__
#254: FILE: include/linux/type_safe_list.h:189:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#255: FILE: include/linux/type_safe_list.h:190:
+PREFIX##_list_init (PREFIX##_list_head  *head)							\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#255: FILE: include/linux/type_safe_list.h:190:
+PREFIX##_list_init (PREFIX##_list_head  *head)							\
                                         ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#257: FILE: include/linux/type_safe_list.h:192:
+	head->_next = (PREFIX##_list_link*) head;						\
 	                                 ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#258: FILE: include/linux/type_safe_list.h:193:
+	head->_prev = (PREFIX##_list_link*) head;						\
 	                                 ^

WARNING:INLINE: plain inline is preferred over __inline__
#261: FILE: include/linux/type_safe_list.h:196:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#262: FILE: include/linux/type_safe_list.h:197:
+PREFIX##_list_clean (ITEM_TYPE           *item)							\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#264: FILE: include/linux/type_safe_list.h:199:
+	PREFIX##_list_link *_link = &item->LINK_NAME;						\
 	                   ^

WARNING:INLINE: plain inline is preferred over __inline__
#270: FILE: include/linux/type_safe_list.h:205:
+static __inline__ int										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#271: FILE: include/linux/type_safe_list.h:206:
+PREFIX##_list_is_clean (const ITEM_TYPE           *item)					\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#273: FILE: include/linux/type_safe_list.h:208:
+	const PREFIX##_list_link *_link = &item->LINK_NAME;					\
 	                         ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#275: FILE: include/linux/type_safe_list.h:210:
+	PREFIX##_list_link_ok (_link);								\

WARNING:INLINE: plain inline is preferred over __inline__
#279: FILE: include/linux/type_safe_list.h:214:
+static __inline__ void										\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#280: FILE: include/linux/type_safe_list.h:215:
+PREFIX##_list_insert_int (PREFIX##_list_link  *next,						\
                                               ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#281: FILE: include/linux/type_safe_list.h:216:
+			  PREFIX##_list_link  *item)						\
 			                      ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#283: FILE: include/linux/type_safe_list.h:218:
+	PREFIX##_list_link *prev = next->_prev;							\
 	                   ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#284: FILE: include/linux/type_safe_list.h:219:
+	PREFIX##_list_link_ok (next);								\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#285: FILE: include/linux/type_safe_list.h:220:
+	PREFIX##_list_link_ok (prev);								\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#290: FILE: include/linux/type_safe_list.h:225:
+	PREFIX##_list_link_ok (next);								\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#291: FILE: include/linux/type_safe_list.h:226:
+	PREFIX##_list_link_ok (prev);								\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#292: FILE: include/linux/type_safe_list.h:227:
+	PREFIX##_list_link_ok (item);								\

WARNING:INLINE: plain inline is preferred over __inline__
#295: FILE: include/linux/type_safe_list.h:230:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#296: FILE: include/linux/type_safe_list.h:231:
+PREFIX##_list_push_front (PREFIX##_list_head  *head,						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#296: FILE: include/linux/type_safe_list.h:231:
+PREFIX##_list_push_front (PREFIX##_list_head  *head,						\
                                               ^

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#299: FILE: include/linux/type_safe_list.h:234:
+	PREFIX##_list_insert_int (head->_next, & item->LINK_NAME);				\
 	                                       ^

WARNING:INLINE: plain inline is preferred over __inline__
#302: FILE: include/linux/type_safe_list.h:237:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#303: FILE: include/linux/type_safe_list.h:238:
+PREFIX##_list_push_back (PREFIX##_list_head  *head,						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#303: FILE: include/linux/type_safe_list.h:238:
+PREFIX##_list_push_back (PREFIX##_list_head  *head,						\
                                              ^

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#306: FILE: include/linux/type_safe_list.h:241:
+	PREFIX##_list_insert_int ((PREFIX##_list_link *) head, & item->LINK_NAME);		\
 	                                                       ^

WARNING:INLINE: plain inline is preferred over __inline__
#309: FILE: include/linux/type_safe_list.h:244:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#310: FILE: include/linux/type_safe_list.h:245:
+PREFIX##_list_insert_before (ITEM_TYPE         *reference,					\

ERROR:SPACING: space prohibited after that '&' (ctx:BxW)
#313: FILE: include/linux/type_safe_list.h:248:
+	PREFIX##_list_insert_int (& reference->LINK_NAME, & item->LINK_NAME);			\
 	                          ^

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#313: FILE: include/linux/type_safe_list.h:248:
+	PREFIX##_list_insert_int (& reference->LINK_NAME, & item->LINK_NAME);			\
 	                                                  ^

WARNING:INLINE: plain inline is preferred over __inline__
#316: FILE: include/linux/type_safe_list.h:251:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#317: FILE: include/linux/type_safe_list.h:252:
+PREFIX##_list_insert_after (ITEM_TYPE         *reference,					\

ERROR:SPACING: space prohibited after that '&' (ctx:WxW)
#320: FILE: include/linux/type_safe_list.h:255:
+	PREFIX##_list_insert_int (reference->LINK_NAME._next, & item->LINK_NAME);		\
 	                                                      ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#323: FILE: include/linux/type_safe_list.h:258:
+static __inline__ PREFIX##_list_link*								\
                                     ^

WARNING:INLINE: plain inline is preferred over __inline__
#323: FILE: include/linux/type_safe_list.h:258:
+static __inline__ PREFIX##_list_link*								\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#324: FILE: include/linux/type_safe_list.h:259:
+PREFIX##_list_remove_int (PREFIX##_list_link *list_link)					\
                                              ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#326: FILE: include/linux/type_safe_list.h:261:
+	PREFIX##_list_link *next = list_link->_next;						\
 	                   ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#327: FILE: include/linux/type_safe_list.h:262:
+	PREFIX##_list_link *prev = list_link->_prev;						\
 	                   ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#328: FILE: include/linux/type_safe_list.h:263:
+	PREFIX##_list_link_ok (list_link);							\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#329: FILE: include/linux/type_safe_list.h:264:
+	PREFIX##_list_link_ok (next);								\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#330: FILE: include/linux/type_safe_list.h:265:
+	PREFIX##_list_link_ok (prev);								\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#333: FILE: include/linux/type_safe_list.h:268:
+	PREFIX##_list_link_ok (next);								\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#334: FILE: include/linux/type_safe_list.h:269:
+	PREFIX##_list_link_ok (prev);								\

WARNING:INLINE: plain inline is preferred over __inline__
#338: FILE: include/linux/type_safe_list.h:273:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#339: FILE: include/linux/type_safe_list.h:274:
+PREFIX##_list_remove (ITEM_TYPE  *item)								\

ERROR:SPACING: space prohibited after that '&' (ctx:BxW)
#341: FILE: include/linux/type_safe_list.h:276:
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
 	                          ^

WARNING:INLINE: plain inline is preferred over __inline__
#344: FILE: include/linux/type_safe_list.h:279:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#345: FILE: include/linux/type_safe_list.h:280:
+PREFIX##_list_remove_clean (ITEM_TYPE  *item)							\

ERROR:SPACING: space prohibited after that '&' (ctx:BxW)
#347: FILE: include/linux/type_safe_list.h:282:
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
 	                          ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#348: FILE: include/linux/type_safe_list.h:283:
+	PREFIX##_list_clean (item);								\

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#351: FILE: include/linux/type_safe_list.h:286:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#351: FILE: include/linux/type_safe_list.h:286:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#352: FILE: include/linux/type_safe_list.h:287:
+PREFIX##_list_remove_get_next (ITEM_TYPE  *item)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#354: FILE: include/linux/type_safe_list.h:289:
+	PREFIX##_list_link *next = item->LINK_NAME._next;					\
 	                   ^

ERROR:SPACING: space prohibited after that '&' (ctx:BxW)
#355: FILE: include/linux/type_safe_list.h:290:
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
 	                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#356: FILE: include/linux/type_safe_list.h:291:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,next);					\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#356: FILE: include/linux/type_safe_list.h:291:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,next);					\
 	                                          ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#359: FILE: include/linux/type_safe_list.h:294:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#359: FILE: include/linux/type_safe_list.h:294:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#360: FILE: include/linux/type_safe_list.h:295:
+PREFIX##_list_remove_get_prev (ITEM_TYPE  *item)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#362: FILE: include/linux/type_safe_list.h:297:
+	PREFIX##_list_link *prev = item->LINK_NAME._prev;					\
 	                   ^

ERROR:SPACING: space prohibited after that '&' (ctx:BxW)
#363: FILE: include/linux/type_safe_list.h:298:
+	PREFIX##_list_remove_int (& item->LINK_NAME);						\
 	                          ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#364: FILE: include/linux/type_safe_list.h:299:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,prev);					\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#364: FILE: include/linux/type_safe_list.h:299:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,prev);					\
 	                                          ^

WARNING:INLINE: plain inline is preferred over __inline__
#367: FILE: include/linux/type_safe_list.h:302:
+static __inline__ int										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#368: FILE: include/linux/type_safe_list.h:303:
+PREFIX##_list_empty (const PREFIX##_list_head  *head)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#368: FILE: include/linux/type_safe_list.h:303:
+PREFIX##_list_empty (const PREFIX##_list_head  *head)						\
                                                ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#370: FILE: include/linux/type_safe_list.h:305:
+	return head == (PREFIX##_list_head*) head->_next;					\
 	                                  ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#373: FILE: include/linux/type_safe_list.h:308:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#373: FILE: include/linux/type_safe_list.h:308:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#374: FILE: include/linux/type_safe_list.h:309:
+PREFIX##_list_pop_front (PREFIX##_list_head  *head)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#374: FILE: include/linux/type_safe_list.h:309:
+PREFIX##_list_pop_front (PREFIX##_list_head  *head)						\
                                              ^

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#376: FILE: include/linux/type_safe_list.h:311:
+	BUG_ON(PREFIX##_list_empty (head));							\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#376: FILE: include/linux/type_safe_list.h:311:
+	BUG_ON(PREFIX##_list_empty (head));							\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#377: FILE: include/linux/type_safe_list.h:312:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_next));	\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#377: FILE: include/linux/type_safe_list.h:312:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_next));	\
 	                                          ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#380: FILE: include/linux/type_safe_list.h:315:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#380: FILE: include/linux/type_safe_list.h:315:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#381: FILE: include/linux/type_safe_list.h:316:
+PREFIX##_list_pop_back (PREFIX##_list_head  *head)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#381: FILE: include/linux/type_safe_list.h:316:
+PREFIX##_list_pop_back (PREFIX##_list_head  *head)						\
                                             ^

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#383: FILE: include/linux/type_safe_list.h:318:
+	BUG_ON(PREFIX##_list_empty (head)); /* WWI started */					\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#383: FILE: include/linux/type_safe_list.h:318:
+	BUG_ON(PREFIX##_list_empty (head)); /* WWI started */					\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#384: FILE: include/linux/type_safe_list.h:319:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_prev));	\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#384: FILE: include/linux/type_safe_list.h:319:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,PREFIX##_list_remove_int (head->_prev));	\
 	                                          ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#387: FILE: include/linux/type_safe_list.h:322:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#387: FILE: include/linux/type_safe_list.h:322:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#388: FILE: include/linux/type_safe_list.h:323:
+PREFIX##_list_front (const PREFIX##_list_head  *head)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#388: FILE: include/linux/type_safe_list.h:323:
+PREFIX##_list_front (const PREFIX##_list_head  *head)						\
                                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#390: FILE: include/linux/type_safe_list.h:325:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_next);				\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#390: FILE: include/linux/type_safe_list.h:325:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_next);				\
 	                                          ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#393: FILE: include/linux/type_safe_list.h:328:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#393: FILE: include/linux/type_safe_list.h:328:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#394: FILE: include/linux/type_safe_list.h:329:
+PREFIX##_list_back (const PREFIX##_list_head  *head)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#394: FILE: include/linux/type_safe_list.h:329:
+PREFIX##_list_back (const PREFIX##_list_head  *head)						\
                                               ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#396: FILE: include/linux/type_safe_list.h:331:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_prev);				\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#396: FILE: include/linux/type_safe_list.h:331:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,head->_prev);				\
 	                                          ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#399: FILE: include/linux/type_safe_list.h:334:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#399: FILE: include/linux/type_safe_list.h:334:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#400: FILE: include/linux/type_safe_list.h:335:
+PREFIX##_list_next (const ITEM_TYPE *item)							\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#402: FILE: include/linux/type_safe_list.h:337:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._next);			\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#402: FILE: include/linux/type_safe_list.h:337:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._next);			\
 	                                          ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxE)
#405: FILE: include/linux/type_safe_list.h:340:
+static __inline__ ITEM_TYPE*									\
                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#405: FILE: include/linux/type_safe_list.h:340:
+static __inline__ ITEM_TYPE*									\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#406: FILE: include/linux/type_safe_list.h:341:
+PREFIX##_list_prev (const ITEM_TYPE *item)							\

ERROR:SPACING: space required after that ',' (ctx:VxV)
#408: FILE: include/linux/type_safe_list.h:343:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._prev);			\
 	                                ^

ERROR:SPACING: space required after that ',' (ctx:VxV)
#408: FILE: include/linux/type_safe_list.h:343:
+	return TS_LINK_TO_ITEM(ITEM_TYPE,LINK_NAME,item->LINK_NAME._prev);			\
 	                                          ^

WARNING:INLINE: plain inline is preferred over __inline__
#411: FILE: include/linux/type_safe_list.h:346:
+static __inline__ int										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#412: FILE: include/linux/type_safe_list.h:347:
+PREFIX##_list_end (const PREFIX##_list_head  *head,						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#412: FILE: include/linux/type_safe_list.h:347:
+PREFIX##_list_end (const PREFIX##_list_head  *head,						\
                                              ^

ERROR:CODE_INDENT: code indent should use tabs where possible
#413: FILE: include/linux/type_safe_list.h:348:
+ ^I^I   const ITEM_TYPE           *item)^I^I^I^I^I^I\$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#413: FILE: include/linux/type_safe_list.h:348:
+ ^I^I   const ITEM_TYPE           *item)^I^I^I^I^I^I\$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#413: FILE: include/linux/type_safe_list.h:348:
+ ^I^I   const ITEM_TYPE           *item)^I^I^I^I^I^I\$

ERROR:SPACING: space prohibited after that '&' (ctx:BxW)
#415: FILE: include/linux/type_safe_list.h:350:
+	return ((PREFIX##_list_link *) head) == (& item->LINK_NAME);				\
 	                                         ^

WARNING:INLINE: plain inline is preferred over __inline__
#418: FILE: include/linux/type_safe_list.h:353:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#419: FILE: include/linux/type_safe_list.h:354:
+PREFIX##_list_splice (PREFIX##_list_head  *head_join,						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#419: FILE: include/linux/type_safe_list.h:354:
+PREFIX##_list_splice (PREFIX##_list_head  *head_join,						\
                                           ^

ERROR:CODE_INDENT: code indent should use tabs where possible
#420: FILE: include/linux/type_safe_list.h:355:
+ ^I^I      PREFIX##_list_head  *head_empty)^I^I^I^I^I^I\$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#420: FILE: include/linux/type_safe_list.h:355:
+ ^I^I      PREFIX##_list_head  *head_empty)^I^I^I^I^I^I\$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#420: FILE: include/linux/type_safe_list.h:355:
+ ^I^I      PREFIX##_list_head  *head_empty)^I^I^I^I^I^I\$

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#420: FILE: include/linux/type_safe_list.h:355:
+ 		      PREFIX##_list_head  *head_empty)						\
  		                          ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#422: FILE: include/linux/type_safe_list.h:357:
+	if (PREFIX##_list_empty (head_empty)) {							\

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#426: FILE: include/linux/type_safe_list.h:361:
+	head_empty->_prev->_next = (PREFIX##_list_link*) head_join;				\
 	                                              ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#432: FILE: include/linux/type_safe_list.h:367:
+	PREFIX##_list_link_ok ((PREFIX##_list_link*) head_join);				\

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#432: FILE: include/linux/type_safe_list.h:367:
+	PREFIX##_list_link_ok ((PREFIX##_list_link*) head_join);				\
 	                                          ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#433: FILE: include/linux/type_safe_list.h:368:
+	PREFIX##_list_link_ok (head_join->_prev);						\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#434: FILE: include/linux/type_safe_list.h:369:
+	PREFIX##_list_link_ok (head_join->_next);						\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#436: FILE: include/linux/type_safe_list.h:371:
+	PREFIX##_list_init (head_empty);							\

WARNING:INLINE: plain inline is preferred over __inline__
#439: FILE: include/linux/type_safe_list.h:374:
+static __inline__ void										\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#440: FILE: include/linux/type_safe_list.h:375:
+PREFIX##_list_split(PREFIX##_list_head  *head_split,						\
                                         ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#441: FILE: include/linux/type_safe_list.h:376:
+		    PREFIX##_list_head  *head_new,						\
 		                        ^

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#444: FILE: include/linux/type_safe_list.h:379:
+	BUG_ON(!PREFIX##_list_empty(head_new));							\

ERROR:SPACING: space prohibited after that '&' (ctx:BxW)
#447: FILE: include/linux/type_safe_list.h:382:
+	head_new->_next = (& item->LINK_NAME);							\
 	                   ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#451: FILE: include/linux/type_safe_list.h:386:
+	item->LINK_NAME._prev->_next = (PREFIX##_list_link*)head_split;				\
 	                                                  ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#455: FILE: include/linux/type_safe_list.h:390:
+	head_new->_next->_prev = (PREFIX##_list_link*)head_new;					\
 	                                            ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxB)
#456: FILE: include/linux/type_safe_list.h:391:
+	head_new->_prev->_next = (PREFIX##_list_link*)head_new;					\
 	                                            ^

WARNING:INLINE: plain inline is preferred over __inline__
#459: FILE: include/linux/type_safe_list.h:394:
+static __inline__ void										\

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#460: FILE: include/linux/type_safe_list.h:395:
+PREFIX##_list_check (const PREFIX##_list_head  *head)						\

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#460: FILE: include/linux/type_safe_list.h:395:
+PREFIX##_list_check (const PREFIX##_list_head  *head)						\
                                                ^

CHECK:SPACING: spaces preferred around that '*' (ctx:WxV)
#462: FILE: include/linux/type_safe_list.h:397:
+	const PREFIX##_list_link *link;								\
 	                         ^

WARNING:SPACING: space prohibited between function name and open parenthesis '('
#465: FILE: include/linux/type_safe_list.h:400:
+		PREFIX##_list_link_ok (link);							\

WARNING:NEW_TYPEDEFS: do not add new typedefs
#468: FILE: include/linux/type_safe_list.h:403:
+typedef struct { int foo; } PREFIX##_list_dummy_decl

WARNING:BLOCK_COMMENT_STYLE: Block comments use a trailing */ on a separate line
#471: FILE: include/linux/type_safe_list.h:406:
+ * TYPE_SAFE_LIST_DEFINE(); */

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'head' - possible side-effects?
#473: FILE: include/linux/type_safe_list.h:408:
+#define for_all_type_safe_list(prefix, head, item)		\
+	for(item = prefix ## _list_front(head),			\
+                   prefetch(prefix ## _list_next(item));	\
+	    !prefix ## _list_end(head, item) ;			\
+	    item = prefix ## _list_next(item),			\
+		    prefetch(prefix ## _list_next(item)))

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'item' - possible side-effects?
#473: FILE: include/linux/type_safe_list.h:408:
+#define for_all_type_safe_list(prefix, head, item)		\
+	for(item = prefix ## _list_front(head),			\
+                   prefetch(prefix ## _list_next(item));	\
+	    !prefix ## _list_end(head, item) ;			\
+	    item = prefix ## _list_next(item),			\
+		    prefetch(prefix ## _list_next(item)))

ERROR:SPACING: space required before the open parenthesis '('
#474: FILE: include/linux/type_safe_list.h:409:
+	for(item = prefix ## _list_front(head),			\

ERROR:CODE_INDENT: code indent should use tabs where possible
#475: FILE: include/linux/type_safe_list.h:410:
+                   prefetch(prefix ## _list_next(item));^I\$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#475: FILE: include/linux/type_safe_list.h:410:
+                   prefetch(prefix ## _list_next(item));^I\$

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'head' - possible side-effects?
#480: FILE: include/linux/type_safe_list.h:415:
+#define for_all_type_safe_list_safe(prefix, head, item, next)	\
+	for(item = prefix ## _list_front(head),			\
+            next = prefix ## _list_next(item);			\
+	    !prefix ## _list_end(head, item) ;			\
+	    item = next,					\
+	    next = prefix ## _list_next(item))

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'item' - possible side-effects?
#480: FILE: include/linux/type_safe_list.h:415:
+#define for_all_type_safe_list_safe(prefix, head, item, next)	\
+	for(item = prefix ## _list_front(head),			\
+            next = prefix ## _list_next(item);			\
+	    !prefix ## _list_end(head, item) ;			\
+	    item = next,					\
+	    next = prefix ## _list_next(item))

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'next' - possible side-effects?
#480: FILE: include/linux/type_safe_list.h:415:
+#define for_all_type_safe_list_safe(prefix, head, item, next)	\
+	for(item = prefix ## _list_front(head),			\
+            next = prefix ## _list_next(item);			\
+	    !prefix ## _list_end(head, item) ;			\
+	    item = next,					\
+	    next = prefix ## _list_next(item))

ERROR:SPACING: space required before the open parenthesis '('
#481: FILE: include/linux/type_safe_list.h:416:
+	for(item = prefix ## _list_front(head),			\

ERROR:CODE_INDENT: code indent should use tabs where possible
#482: FILE: include/linux/type_safe_list.h:417:
+            next = prefix ## _list_next(item);^I^I^I\$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#482: FILE: include/linux/type_safe_list.h:417:
+            next = prefix ## _list_next(item);^I^I^I\$

WARNING:BLOCK_COMMENT_STYLE: Block comments use * on subsequent lines
#491: FILE: include/linux/type_safe_list.h:426:
+/*
+   Local variables:

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000166260.commit.8e73d15569f5a0577a8fa73f87817b476f68864f total: 41 errors, 98 warnings, 66 checks, 433 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000166260.commit.8e73d15569f5a0577a8fa73f87817b476f68864f has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
