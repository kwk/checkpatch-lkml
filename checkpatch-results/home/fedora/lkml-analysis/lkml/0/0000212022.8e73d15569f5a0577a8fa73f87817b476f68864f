WARNING:COMMIT_LOG_LONG_LINE: Possible unwrapped commit description (prefer a maximum 75 chars per line)
#30: 
1) strdup() the interesting fields from modinfo section before it is discarded.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct module *' should also have an identifier name
#71: FILE: include/linux/module.h:54:
+	void (*setup)(struct module *, const char *);

This warning is emitted due to any of the following reasons:

  1. Arguments for the function declaration do not follow
     the identifier name.  Example::

       void foo
       (int bar, int baz)

     This should be corrected to::

       void foo(int bar, int baz)

  2. Some arguments for the function definition do not
     have an identifier name.  Example::

       void foo(int)

     All arguments should have identifier names.

WARNING:FUNCTION_ARGUMENTS: function definition argument 'const char *' should also have an identifier name
#71: FILE: include/linux/module.h:54:
+	void (*setup)(struct module *, const char *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct module *' should also have an identifier name
#72: FILE: include/linux/module.h:55:
+	int (*test)(struct module *);

WARNING:FUNCTION_ARGUMENTS: function definition argument 'struct module *' should also have an identifier name
#73: FILE: include/linux/module.h:56:
+	void (*free)(struct module *);

CHECK:SPACING: spaces preferred around that '+' (ctx:VxV)
#99: FILE: kernel/module.c:672:
+	s = kmalloc(strlen(str)+1, GFP_KERNEL);
 	                       ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'field' - possible side-effects?
#106: FILE: kernel/module.c:679:
+#define MODINFO_ATTR(field)	\
+static void setup_modinfo_##field(struct module *mod, const char *s)  \
+{                                                                     \
+	mod->field = strdup(s);                                       \
+}                                                                     \
+static ssize_t show_modinfo_##field(struct module_attribute *mattr,   \
+	                struct module *mod, char *buffer)             \
+{                                                                     \
+	return sprintf(buffer, "%s\n", mod->field);                   \
+}                                                                     \
+static int modinfo_##field##_exists(struct module *mod)               \
+{                                                                     \
+	return mod->field != NULL;                                    \
+}                                                                     \
+static void free_modinfo_##field(struct module *mod)                  \
+{                                                                     \
+        kfree(mod->field);                                            \
+        mod->field = NULL;                                            \
+}                                                                     \
+static struct module_attribute modinfo_##field = {                    \
+	.attr = { .name = __stringify(field), .mode = 0444,           \
+		  .owner = THIS_MODULE },                             \
+	.show = show_modinfo_##field,                                 \
+	.setup = setup_modinfo_##field,                               \
+	.test = modinfo_##field##_exists,                             \
+	.free = free_modinfo_##field,                                 \
+};

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'field' may be better as '(field)' to avoid precedence issues
#106: FILE: kernel/module.c:679:
+#define MODINFO_ATTR(field)	\
+static void setup_modinfo_##field(struct module *mod, const char *s)  \
+{                                                                     \
+	mod->field = strdup(s);                                       \
+}                                                                     \
+static ssize_t show_modinfo_##field(struct module_attribute *mattr,   \
+	                struct module *mod, char *buffer)             \
+{                                                                     \
+	return sprintf(buffer, "%s\n", mod->field);                   \
+}                                                                     \
+static int modinfo_##field##_exists(struct module *mod)               \
+{                                                                     \
+	return mod->field != NULL;                                    \
+}                                                                     \
+static void free_modinfo_##field(struct module *mod)                  \
+{                                                                     \
+        kfree(mod->field);                                            \
+        mod->field = NULL;                                            \
+}                                                                     \
+static struct module_attribute modinfo_##field = {                    \
+	.attr = { .name = __stringify(field), .mode = 0444,           \
+		  .owner = THIS_MODULE },                             \
+	.show = show_modinfo_##field,                                 \
+	.setup = setup_modinfo_##field,                               \
+	.test = modinfo_##field##_exists,                             \
+	.free = free_modinfo_##field,                                 \
+};

WARNING:TRAILING_SEMICOLON: macros should not use a trailing semicolon
#106: FILE: kernel/module.c:679:
+#define MODINFO_ATTR(field)	\
+static void setup_modinfo_##field(struct module *mod, const char *s)  \
+{                                                                     \
+	mod->field = strdup(s);                                       \
+}                                                                     \
+static ssize_t show_modinfo_##field(struct module_attribute *mattr,   \
+	                struct module *mod, char *buffer)             \
+{                                                                     \
+	return sprintf(buffer, "%s\n", mod->field);                   \
+}                                                                     \
+static int modinfo_##field##_exists(struct module *mod)               \
+{                                                                     \
+	return mod->field != NULL;                                    \
+}                                                                     \
+static void free_modinfo_##field(struct module *mod)                  \
+{                                                                     \
+        kfree(mod->field);                                            \
+        mod->field = NULL;                                            \
+}                                                                     \
+static struct module_attribute modinfo_##field = {                    \
+	.attr = { .name = __stringify(field), .mode = 0444,           \
+		  .owner = THIS_MODULE },                             \
+	.show = show_modinfo_##field,                                 \
+	.setup = setup_modinfo_##field,                               \
+	.test = modinfo_##field##_exists,                             \
+	.free = free_modinfo_##field,                                 \
+};

Macro definition should not end with a semicolon. The macro
invocation style should be consistent with function calls.
This can prevent any unexpected code paths::

  #define MAC do_something;

If this macro is used within a if else statement, like::

  if (some_condition)
          MAC;

  else
          do_something;

Then there would be a compilation error, because when the macro is
expanded there are two trailing semicolons, so the else branch gets
orphaned.

See: https://lore.kernel.org/lkml/1399671106.2912.21.camel@joe-AO725/

ERROR:CODE_INDENT: code indent should use tabs where possible
#112: FILE: kernel/module.c:685:
+^I                struct module *mod, char *buffer)             \$

Code indent should use tabs instead of spaces.
Outside of comments, documentation and Kconfig,
spaces are never used for indentation.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "mod->field"
#118: FILE: kernel/module.c:691:
+	return mod->field != NULL;                                    \

Comparisons to NULL in the form (foo == NULL) or (foo != NULL)
are better written as (!foo) and (foo).

ERROR:CODE_INDENT: code indent should use tabs where possible
#122: FILE: kernel/module.c:695:
+        kfree(mod->field);                                            \$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#122: FILE: kernel/module.c:695:
+        kfree(mod->field);                                            \$

ERROR:CODE_INDENT: code indent should use tabs where possible
#123: FILE: kernel/module.c:696:
+        mod->field = NULL;                                            \$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#123: FILE: kernel/module.c:696:
+        mod->field = NULL;                                            \$

CHECK:LINE_SPACING: Please don't use multiple blank lines
#134: FILE: kernel/module.c:707:
+
+

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#153: FILE: kernel/module.c:1087:
+	struct module_attribute * attr;

When using pointer data or a function that returns a pointer type,
the preferred use of * is adjacent to the data name or function name
and not adjacent to the type name.
Examples::

  char *linux_banner;
  unsigned long long memparse(char *ptr, char **retptr);
  char *match_strdup(substring_t *s);

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

ERROR:SPACING: space required after that ',' (ctx:VxO)
#160: FILE: kernel/module.c:1094:
+			error = sysfs_create_file(&mod->mkobj.kobj,&attr->attr);
 			                                          ^

ERROR:SPACING: space required before that '&' (ctx:OxV)
#160: FILE: kernel/module.c:1094:
+			error = sysfs_create_file(&mod->mkobj.kobj,&attr->attr);
 			                                           ^

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#166: FILE: kernel/module.c:1100:
+	struct module_attribute * attr;

ERROR:SPACING: space required after that ',' (ctx:VxO)
#170: FILE: kernel/module.c:1104:
+		sysfs_remove_file(&mod->mkobj.kobj,&attr->attr);
 		                                  ^

ERROR:SPACING: space required before that '&' (ctx:OxV)
#170: FILE: kernel/module.c:1104:
+		sysfs_remove_file(&mod->mkobj.kobj,&attr->attr);
 		                                   ^

CHECK:CAMELCASE: Avoid CamelCase: <Elf_Shdr>
#200: FILE: kernel/module.c:1385:
+static void setup_modinfo(struct module *mod, Elf_Shdr *sechdrs,

Avoid CamelCase Identifiers.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#naming

ERROR:POINTER_LOCATION: "foo * bar" should be "foo *bar"
#203: FILE: kernel/module.c:1388:
+	struct module_attribute * attr;

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000212022.commit.8e73d15569f5a0577a8fa73f87817b476f68864f total: 10 errors, 8 warnings, 6 checks, 150 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000212022.commit.8e73d15569f5a0577a8fa73f87817b476f68864f has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
