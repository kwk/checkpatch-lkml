WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#72: FILE: include/linux/wait.h:166:
+ * ^I- no lock needs to be grabbed/released;$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#73: FILE: include/linux/wait.h:167:
+ * ^I- a timeout is not requested, i.e. only @condition being true$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#74: FILE: include/linux/wait.h:168:
+ * ^I^Iwill cause the macro to return; and$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#75: FILE: include/linux/wait.h:169:
+ * ^I- the sleep will be in TASK_UNINTERRUPTIBLE, i.e. signals will$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#76: FILE: include/linux/wait.h:170:
+ * ^I^Ibe ignored.$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#78: FILE: include/linux/wait.h:172:
+ * ^Ilock, then @lock should be held before calling wait_event*().$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#79: FILE: include/linux/wait.h:173:
+ * ^I^IIt is released before sleeping and grabbed after$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#80: FILE: include/linux/wait.h:174:
+ * ^I^Iwaking, saving the current IRQ mask in @flags. This lock$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#81: FILE: include/linux/wait.h:175:
+ * ^I^Ishould also be held when changing any variables$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#82: FILE: include/linux/wait.h:176:
+ * ^I^Iaffecting the condition and when waking up the process.$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#83: FILE: include/linux/wait.h:177:
+ * ^Itimeout, then even if @condition is not true, but @timeout$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#84: FILE: include/linux/wait.h:178:
+ * ^I^Ijiffies have passed, the macro will return. The number$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#85: FILE: include/linux/wait.h:179:
+ * ^I^Iof jiffies remaining in the delay will be returned$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#86: FILE: include/linux/wait.h:180:
+ * ^Iinterruptible, then signals will cause the macro to return$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#87: FILE: include/linux/wait.h:181:
+ * ^I^Iearly with a return code of -ERESTARTSYS$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#88: FILE: include/linux/wait.h:182:
+ * ^Iexclusive, then current is an exclusive process and must be$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#89: FILE: include/linux/wait.h:183:
+ *^I ^Iselectively woken.$

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'wq' - possible side-effects?
#98: FILE: include/linux/wait.h:205:
+#define __wait_event_lock(wq, condition, lock, flags)			\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		schedule();						\
+		spin_lock_irqsave(lock, flags);				\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'wq' may be better as '(wq)' to avoid precedence issues
#98: FILE: include/linux/wait.h:205:
+#define __wait_event_lock(wq, condition, lock, flags)			\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		schedule();						\
+		spin_lock_irqsave(lock, flags);				\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'lock' - possible side-effects?
#98: FILE: include/linux/wait.h:205:
+#define __wait_event_lock(wq, condition, lock, flags)			\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		schedule();						\
+		spin_lock_irqsave(lock, flags);				\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'flags' - possible side-effects?
#98: FILE: include/linux/wait.h:205:
+#define __wait_event_lock(wq, condition, lock, flags)			\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		schedule();						\
+		spin_lock_irqsave(lock, flags);				\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'condition' - possible side-effects?
#113: FILE: include/linux/wait.h:220:
+#define wait_event_lock(wq, condition, lock, flags)			\
+do {									\
+	if (condition)							\
+		break;							\
+	__wait_event_lock(wq, condition, lock, flags);			\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'wq' - possible side-effects?
#127: FILE: include/linux/wait.h:250:
+#define __wait_event_timeout_lock(wq, condition, lock, flags, ret)	\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		ret = schedule_timeout(ret);				\
+		spin_lock_irqsave(lock, flags);				\
+		if (!ret)						\
+			break;						\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'wq' may be better as '(wq)' to avoid precedence issues
#127: FILE: include/linux/wait.h:250:
+#define __wait_event_timeout_lock(wq, condition, lock, flags, ret)	\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		ret = schedule_timeout(ret);				\
+		spin_lock_irqsave(lock, flags);				\
+		if (!ret)						\
+			break;						\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'lock' - possible side-effects?
#127: FILE: include/linux/wait.h:250:
+#define __wait_event_timeout_lock(wq, condition, lock, flags, ret)	\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		ret = schedule_timeout(ret);				\
+		spin_lock_irqsave(lock, flags);				\
+		if (!ret)						\
+			break;						\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'flags' - possible side-effects?
#127: FILE: include/linux/wait.h:250:
+#define __wait_event_timeout_lock(wq, condition, lock, flags, ret)	\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		ret = schedule_timeout(ret);				\
+		spin_lock_irqsave(lock, flags);				\
+		if (!ret)						\
+			break;						\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'ret' - possible side-effects?
#127: FILE: include/linux/wait.h:250:
+#define __wait_event_timeout_lock(wq, condition, lock, flags, ret)	\
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		spin_unlock_irqrestore(lock, flags);			\
+		ret = schedule_timeout(ret);				\
+		spin_lock_irqsave(lock, flags);				\
+		if (!ret)						\
+			break;						\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'condition' - possible side-effects?
#144: FILE: include/linux/wait.h:267:
+#define wait_event_timeout_lock(wq, condition, lock, flags, timeout)	\
+({									\
+	long __ret = timeout;						\
+	if (!(condition)) 						\
+		__wait_event_timeout_lock(wq, condition, lock, flags, __ret); \
+	__ret;								\
+})

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#147: FILE: include/linux/wait.h:270:
+^Iif (!(condition)) ^I^I^I^I^I^I\$

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'wq' - possible side-effects?
#159: FILE: include/linux/wait.h:301:
+#define __wait_event_interruptible_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags)		\
+			schedule();					\
+			spin_lock_irqsave(lock, flags)			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'wq' may be better as '(wq)' to avoid precedence issues
#159: FILE: include/linux/wait.h:301:
+#define __wait_event_interruptible_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags)		\
+			schedule();					\
+			spin_lock_irqsave(lock, flags)			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'lock' - possible side-effects?
#159: FILE: include/linux/wait.h:301:
+#define __wait_event_interruptible_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags)		\
+			schedule();					\
+			spin_lock_irqsave(lock, flags)			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'flags' - possible side-effects?
#159: FILE: include/linux/wait.h:301:
+#define __wait_event_interruptible_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags)		\
+			schedule();					\
+			spin_lock_irqsave(lock, flags)			\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'condition' - possible side-effects?
#179: FILE: include/linux/wait.h:321:
+#define wait_event_interruptible_lock(wq, condition, lock, flags)	\
+({									\
+	int __ret = 0;							\
+	if (!(condition))						\
+		__wait_event_interruptible_lock(wq, condition, lock, flags, __ret); \
+	__ret;								\
+})

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'wq' - possible side-effects?
#194: FILE: include/linux/wait.h:357:
+#define __wait_event_interruptible_timeout_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			ret = schedule_timeout(ret);			\
+			spin_lock_irqsave(lock, flags);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'wq' may be better as '(wq)' to avoid precedence issues
#194: FILE: include/linux/wait.h:357:
+#define __wait_event_interruptible_timeout_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			ret = schedule_timeout(ret);			\
+			spin_lock_irqsave(lock, flags);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'lock' - possible side-effects?
#194: FILE: include/linux/wait.h:357:
+#define __wait_event_interruptible_timeout_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			ret = schedule_timeout(ret);			\
+			spin_lock_irqsave(lock, flags);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'flags' - possible side-effects?
#194: FILE: include/linux/wait.h:357:
+#define __wait_event_interruptible_timeout_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			ret = schedule_timeout(ret);			\
+			spin_lock_irqsave(lock, flags);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'ret' - possible side-effects?
#194: FILE: include/linux/wait.h:357:
+#define __wait_event_interruptible_timeout_lock(wq, condition, lock, flags, ret) \
+do {									\
+	DEFINE_WAIT(__wait);						\
+									\
+	for (;;) {							\
+		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			spin_unlock_irqrestore(lock, flags);		\
+			ret = schedule_timeout(ret);			\
+			spin_lock_irqsave(lock, flags);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	finish_wait(&wq, &__wait);					\
+} while (0)

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'condition' - possible side-effects?
#216: FILE: include/linux/wait.h:379:
+#define wait_event_interruptible_timeout_lock(wq, condition, lock, flags, timeout) \
+({									\
+	long __ret = timeout;						\
+	if (!(condition))						\
+		__wait_event_interruptible_timeout_lock(wq, condition, lock, flags, __ret); \
+	__ret;								\
+})

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000207504.commit.8e73d15569f5a0577a8fa73f87817b476f68864f total: 0 errors, 18 warnings, 22 checks, 161 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

./tmp.EfiDkiSq0Q//home/fedora/lkml-analysis/lkml/0/patch.offset.0000207504.commit.8e73d15569f5a0577a8fa73f87817b476f68864f has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
