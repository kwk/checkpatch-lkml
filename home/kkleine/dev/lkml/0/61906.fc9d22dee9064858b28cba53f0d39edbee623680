WARNING:COMMIT_LOG_LONG_LINE: Possible unwrapped commit description (prefer a maximum 75 chars per line)
#62: 
Content-Disposition: attachment; filename="adaptive-readahead-2.6.17-rc5.patch"

WARNING:TYPO_SPELLING: 'dynamicly' may be misspelled - perhaps 'dynamically'?
#85: FILE: Documentation/sysctl/vm.txt:189:
+The thrashing threshold is dynamicly estimated from the _history_ read
                            ^^^^^^^^^

Some words may have been misspelled.  Consider reviewing them.

WARNING:SYMBOLIC_PERMS: Symbolic permissions 'S_IRUGO | S_IWUSR' are not preferred. Consider using octal permissions '0644'.
#169: FILE: block/ll_rw_blk.c:3846:
+	.attr = {.name = "initial_ra_kb", .mode = S_IRUGO | S_IWUSR },

Permission bits in the octal form are more readable and easier to
understand than their symbolic counterparts because many command-line
tools use this notation. Experienced kernel developers have been using
these traditional Unix permission bits for decades and so they find it
easier to understand the octal notation than the symbolic macros.
For example, it is harder to read S_IWUSR|S_IRUGO than 0644, which
obscures the developer's intent rather than clarifying it.

See: https://lore.kernel.org/lkml/CA+55aFw5v23T-zvDZp-MmD_EYxF8WbafwwB59934FV7g21uMGQ@mail.gmail.com/

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#312: FILE: include/linux/fs.h:651:
+^I^I^I * ^Ii.e. # of distinct read-ahead pages accessed.$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#315: FILE: include/linux/fs.h:654:
+^I^I^I * ^IA collection of sequential read-ahead requests.$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#317: FILE: include/linux/fs.h:656:
+^I^I^I * ^INormally a seek starts a new sequence.$

WARNING:TYPO_SPELLING: 'occured' may be misspelled - perhaps 'occurred'?
#343: FILE: include/linux/fs.h:680:
+#define RA_FLAG_MISS	(1UL<<31) /* a cache miss occured against this file */
                     	                          ^^^^^^^

CHECK:LINE_SPACING: Please use a blank line after function/struct/union/enum declarations
#343: FILE: include/linux/fs.h:680:
 };
+#define RA_FLAG_MISS	(1UL<<31) /* a cache miss occured against this file */

Vertical space is wasted given the limited number of lines an
editor window can display when multiple blank lines are used.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxV)
#343: FILE: include/linux/fs.h:680:
+#define RA_FLAG_MISS	(1UL<<31) /* a cache miss occured against this file */
                     	    ^

Whitespace style used in the kernel sources is described in kernel docs.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#spaces

CHECK:BIT_MACRO: Prefer using the BIT macro
#343: FILE: include/linux/fs.h:680:
+#define RA_FLAG_MISS	(1UL<<31) /* a cache miss occured against this file */

Defines like: 1 << <digit> could be BIT(digit).
The BIT() macro is defined via include/linux/bits.h::

  #define BIT(nr)         (1UL << (nr))

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxV)
#344: FILE: include/linux/fs.h:681:
+#define RA_FLAG_INCACHE	(1UL<<30) /* file is already in cache */
                        	    ^

CHECK:BIT_MACRO: Prefer using the BIT macro
#344: FILE: include/linux/fs.h:681:
+#define RA_FLAG_INCACHE	(1UL<<30) /* file is already in cache */

WARNING:TYPO_SPELLING: 'mmaped' may be misspelled - perhaps 'mapped'?
#345: FILE: include/linux/fs.h:682:
+#define RA_FLAG_MMAP		(1UL<<29) /* mmaped page access */
                     		             ^^^^^^

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxV)
#345: FILE: include/linux/fs.h:682:
+#define RA_FLAG_MMAP		(1UL<<29) /* mmaped page access */
                     		    ^

CHECK:BIT_MACRO: Prefer using the BIT macro
#345: FILE: include/linux/fs.h:682:
+#define RA_FLAG_MMAP		(1UL<<29) /* mmaped page access */

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxV)
#346: FILE: include/linux/fs.h:683:
+#define RA_FLAG_NO_LOOKAHEAD	(1UL<<28) /* disable look-ahead */
                             	    ^

CHECK:BIT_MACRO: Prefer using the BIT macro
#346: FILE: include/linux/fs.h:683:
+#define RA_FLAG_NO_LOOKAHEAD	(1UL<<28) /* disable look-ahead */

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxV)
#347: FILE: include/linux/fs.h:684:
+#define RA_FLAG_EOF		(1UL<<27) /* readahead hits EOF */
                    		    ^

CHECK:BIT_MACRO: Prefer using the BIT macro
#347: FILE: include/linux/fs.h:684:
+#define RA_FLAG_EOF		(1UL<<27) /* readahead hits EOF */

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#372: FILE: include/linux/mm.h:982:
+			struct file_ra_state *ra, struct file *filp,
 			                                       ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#372: FILE: include/linux/mm.h:982:
+page_cache_readahead_adaptive(struct address_space *mapping,
+			struct file_ra_state *ra, struct file *filp,

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#408: FILE: include/linux/mmzone.h:168:
+^Iunsigned long ^I^Iaging_total;$

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#448: FILE: include/linux/pagemap.h:71:
+extern int __probe_page(struct address_space *mapping, pgoff_t offset);

Function prototypes don't need to be declared extern in .h
files.  It's assumed by the compiler and is unnecessary.

CHECK:AVOID_EXTERNS: extern prototypes should be avoided in .h files
#449: FILE: include/linux/pagemap.h:72:
+extern int probe_page(struct address_space *mapping, pgoff_t offset);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#460: FILE: include/linux/radix-tree.h:58:
+unsigned long radix_tree_scan_hole_backward(struct radix_tree_root *root,
+				unsigned long index, unsigned long max_scan);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#462: FILE: include/linux/radix-tree.h:60:
+unsigned long radix_tree_scan_hole(struct radix_tree_root *root,
+				unsigned long index, unsigned long max_scan);

ERROR:SPACING: spaces required around that '=' (ctx:VxV)
#472: FILE: include/linux/sysctl.h:189:
+	VM_READAHEAD_RATIO=33,	/* percent of read-ahead size to thrashing-threshold */
 	                  ^

ERROR:SPACING: spaces required around that '=' (ctx:VxV)
#473: FILE: include/linux/sysctl.h:190:
+	VM_READAHEAD_HIT_RATE=34, /* one accessed page legitimizes so many read-ahead pages */
 	                     ^

WARNING:AVOID_EXTERNS: externs should be avoided in .c files
#500: FILE: kernel/sysctl.c:78:
+extern int readahead_hit_rate;

WARNING:DUPLICATED_SYSCTL_CONST: duplicated sysctl range checking value 'zero', consider using the shared one in include/linux/sysctl.h
#520: FILE: kernel/sysctl.c:933:
+		.extra1		= &zero,

Commit d91bff3011cf ("proc/sysctl: add shared variables for range
check") added some shared const variables to be used instead of a local
copy in each source file.

Consider replacing the sysctl range checking value with the shared
one in include/linux/sysctl.h.  The following conversion scheme may
be used::

  &zero     ->  SYSCTL_ZERO
  &one      ->  SYSCTL_ONE
  &int_max  ->  SYSCTL_INT_MAX

See:

  1. https://lore.kernel.org/lkml/20190430180111.10688-1-mcroce@redhat.com/
  2. https://lore.kernel.org/lkml/20190531131422.14970-1-mcroce@redhat.com/

WARNING:DUPLICATED_SYSCTL_CONST: duplicated sysctl range checking value 'one', consider using the shared one in include/linux/sysctl.h
#530: FILE: kernel/sysctl.c:943:
+		.extra1		= &one,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#543: FILE: lib/radix-tree.c:508:
+static unsigned long radix_tree_scan_hole_dumb(struct radix_tree_root *root,
+				unsigned long index, unsigned long max_scan)

CHECK:OPEN_ENDED_LINE: Lines should not end with a '('
#557: FILE: lib/radix-tree.c:522:
+static unsigned long radix_tree_scan_hole_backward_dumb(

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#587: FILE: lib/radix-tree.c:552:
+unsigned long radix_tree_scan_hole(struct radix_tree_root *root,
+				unsigned long index, unsigned long max_scan)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#607: FILE: lib/radix-tree.c:572:
+unsigned long radix_tree_scan_hole_backward(struct radix_tree_root *root,
+				unsigned long index, unsigned long max_scan)

ERROR:SPACING: space prohibited after that '!' (ctx:OxW)
#707: FILE: mm/filemap.c:558:
+	return !! radix_tree_lookup(&mapping->page_tree, offset);
 	        ^

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#746: FILE: mm/filemap.c:857:
+		printk(KERN_DEBUG "read-file(ino=%lu, req=%lu+%lu)\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#747: FILE: mm/filemap.c:858:
+		printk(KERN_DEBUG "read-file(ino=%lu, req=%lu+%lu)\n",
+			inode->i_ino, index, last_index - index);

CHECK:COMPARISON_TO_NULL: Comparison to NULL could be written "!page"
#765: FILE: mm/filemap.c:886:
+			if (unlikely(page == NULL)) {

Comparisons to NULL in the form (foo == NULL) or (foo != NULL)
are better written as (!foo) and (foo).

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#768: FILE: mm/filemap.c:889:
+						filp, prev_page, NULL,
 						^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#768: FILE: mm/filemap.c:889:
+				page_cache_readahead_adaptive(mapping, &ra,
+						filp, prev_page, NULL,

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#775: FILE: mm/filemap.c:896:
+						filp, prev_page, page,
 						^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#775: FILE: mm/filemap.c:896:
+				page_cache_readahead_adaptive(mapping, &ra,
+						filp, prev_page, page,

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#795: FILE: mm/filemap.c:915:
+			printk(KERN_DEBUG "read-page(ino=%lu, idx=%lu, io=%s)\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#796: FILE: mm/filemap.c:916:
+			printk(KERN_DEBUG "read-page(ino=%lu, idx=%lu, io=%s)\n",
+				inode->i_ino, index,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#897: FILE: mm/filemap.c:1377:
+			page_cache_readahead_adaptive(mapping, ra,
+						file, NULL, NULL,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#902: FILE: mm/filemap.c:1382:
+			page_cache_readahead_adaptive(mapping, ra,
+						file, NULL, page,

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#924: FILE: mm/filemap.c:1432:
+		printk(KERN_DEBUG "read-mmap(ino=%lu, idx=%lu, hint=%s, io=%s)\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#925: FILE: mm/filemap.c:1433:
+		printk(KERN_DEBUG "read-mmap(ino=%lu, idx=%lu, hint=%s, io=%s)\n",
+			inode->i_ino, pgoff,

ERROR:SPACING: space required after that ',' (ctx:VxV)
#1010: FILE: mm/readahead.c:27:
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
                       ^

CHECK:MACRO_ARG_REUSE: Macro argument reuse 'd' - possible side-effects?
#1010: FILE: mm/readahead.c:27:
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))

CHECK:SPACING: spaces preferred around that '*' (ctx:VxV)
#1011: FILE: mm/readahead.c:28:
+#define MAX_RA_PAGES	(VM_MAX_READAHEAD*1024 / PAGE_CACHE_SIZE)
                     	                 ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxV)
#1012: FILE: mm/readahead.c:29:
+#define MIN_RA_PAGES	DIV_ROUND_UP(VM_MIN_READAHEAD*1024, PAGE_CACHE_SIZE)
                     	                             ^

CHECK:SPACING: spaces preferred around that '*' (ctx:VxV)
#1019: FILE: mm/readahead.c:36:
+#define INITIAL_RA_PAGES  DIV_ROUND_UP(128*1024, PAGE_CACHE_SIZE)
                                           ^

ERROR:GLOBAL_INITIALISERS: do not initialise globals to 0
#1090: FILE: mm/readahead.c:107:
+u32 disable_stateful_method = 0;

Global variables should not be initialized explicitly to
0 (or NULL, false, etc.).  Your compiler (or rather your
loader, which is responsible for zeroing out the relevant
sections) automatically does it for you.

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'var' may be better as '(var)' to avoid precedence issues
#1093: FILE: mm/readahead.c:110:
+#  define debug_inc(var)		do { var++; } while (0)

WARNING:SINGLE_STATEMENT_DO_WHILE_MACRO: Single statement macros should not use a do {} while (0) loop
#1093: FILE: mm/readahead.c:110:
+#  define debug_inc(var)		do { var++; } while (0)

For the multi-statement macros, it is necessary to use the do-while
loop to avoid unpredictable code paths. The do-while loop helps to
group the multiple statements into a single one so that a
function-like macro can be used as a function only.

But for the single statement macros, it is unnecessary to use the
do-while loop. Although the code is syntactically correct but using
the do-while loop is redundant. So remove the do-while loop for single
statement macros.

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1099: FILE: mm/readahead.c:116:
+#  define debug_level ^I^I^I(0)$

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#1103: FILE: mm/readahead.c:120:
+	do { if (debug_level >= 2) printk(KERN_DEBUG args); } while(0)

ERROR:SPACING: space required before the open parenthesis '('
#1103: FILE: mm/readahead.c:120:
+	do { if (debug_level >= 2) printk(KERN_DEBUG args); } while(0)

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_dbg([subsystem]dev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
#1105: FILE: mm/readahead.c:122:
+	do { if (debug_level >= 3) printk(KERN_DEBUG args); } while(0)

ERROR:SPACING: space required before the open parenthesis '('
#1105: FILE: mm/readahead.c:122:
+	do { if (debug_level >= 3) printk(KERN_DEBUG args); } while(0)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1218: FILE: mm/readahead.c:512:
+	ret = __do_page_cache_readahead(mapping, filp, offset, nr_to_read, 0);
 	                                         ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1231: FILE: mm/readahead.c:536:
+	actual = __do_page_cache_readahead(mapping, filp, offset, nr_to_read, 0);
 	                                            ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1235: FILE: mm/readahead.c:540:
+	dprintk("blockable-readahead(ino=%lu, ra=%lu+%lu) = %d\n",
+			mapping->host->i_ino, offset, nr_to_read, actual);

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'rescue_pages', this function's name, in a string
#1294: FILE: mm/readahead.c:762:
+	dprintk("rescue_pages(ino=%lu, index=%lu nr=%lu)\n",

Embedded function names are less appropriate to use as
refactoring can cause function renaming.  Prefer the use of
"%s", __func__ to embedded function names.

Note that this does not work with -f (--file) checkpatch option
as it depends on patch context providing the function name.

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1295: FILE: mm/readahead.c:763:
+	dprintk("rescue_pages(ino=%lu, index=%lu nr=%lu)\n",
+			mapping->host->i_ino, index, nr_pages);

ERROR:SPACING: space required before the open parenthesis '('
#1297: FILE: mm/readahead.c:765:
+	for(;;) {

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1305: FILE: mm/readahead.c:773:
+		while (page_mapping(page) == mapping &&
+				page_index(page) == index) {

WARNING:LINE_SPACING: Missing a blank line after declarations
#1307: FILE: mm/readahead.c:775:
+			struct page *the_page = page;
+			page = list_entry((page)->lru.prev, struct page, lru);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1309: FILE: mm/readahead.c:777:
+			if (!PageActive(the_page) &&
+					!PageLocked(the_page) &&

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#1324: FILE: mm/readahead.c:792:
+		grabbed_page = page = find_get_page(mapping, index);

Multiple assignments on a single line makes the code unnecessarily
complicated. So on a single line assign value to a single variable
only, this makes the code more readable and helps avoid typos.

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1343: FILE: mm/readahead.c:811:
+static int renew_lookahead(struct address_space *mapping,
+				struct file_ra_state *ra,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1349: FILE: mm/readahead.c:817:
+	if (index == ra->lookahead_index &&
+			new_index >= ra->readahead_index)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1371: FILE: mm/readahead.c:839:
+static inline void update_ra_thrash_bytes(struct backing_dev_info *bdi,
+						unsigned long ra_size)

ERROR:SPACING: spaces required around that ':' (ctx:VxE)
#1375: FILE: mm/readahead.c:843:
+				(ra_size + bdi->ra_thrash_bytes * 1023) / 1024:
 				                                              ^

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1384: FILE: mm/readahead.c:852:
+       unsigned long sum = 0;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1387: FILE: mm/readahead.c:855:
+       unsigned long cpu;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1388: FILE: mm/readahead.c:856:
+       cpumask_t mask = node_to_cpumask(numa_node_id());$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1390: FILE: mm/readahead.c:858:
+       for_each_cpu_mask(cpu, mask)$

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (7, 15)
#1390: FILE: mm/readahead.c:858:
+       for_each_cpu_mask(cpu, mask)
+	       sum += per_cpu(readahead_aging, cpu);

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1393: FILE: mm/readahead.c:861:
+       unsigned int i;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1394: FILE: mm/readahead.c:862:
+       struct zone *zones = NODE_DATA(numa_node_id())->node_zones;$

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1396: FILE: mm/readahead.c:864:
+       for (i = 0; i < MAX_NR_ZONES; i++)$

WARNING:SUSPECT_CODE_INDENT: suspect code indent for conditional statements (7, 15)
#1396: FILE: mm/readahead.c:864:
+       for (i = 0; i < MAX_NR_ZONES; i++)
+	       sum += zones[i].aging_total;

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1400: FILE: mm/readahead.c:868:
+       return sum;$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1468: FILE: mm/readahead.c:936:
+static void ra_set_class(struct file_ra_state *ra,
+				enum ra_class ra_class)

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1489: FILE: mm/readahead.c:957:
+^I * ^I- the stateful method continues any existing sequence;$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1490: FILE: mm/readahead.c:958:
+^I * ^I- all other methods starts a new one.$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1503: FILE: mm/readahead.c:971:
+static void ra_set_index(struct file_ra_state *ra,
+				pgoff_t la_index, pgoff_t ra_index)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1513: FILE: mm/readahead.c:981:
+static void ra_set_size(struct file_ra_state *ra,
+				unsigned long ra_size, unsigned long la_size)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1523: FILE: mm/readahead.c:991:
+			struct address_space *mapping, struct file *filp)
 			                                            ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1523: FILE: mm/readahead.c:991:
+static int ra_dispatch(struct file_ra_state *ra,
+			struct address_space *mapping, struct file *filp)

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1538: FILE: mm/readahead.c:1006:
+^I * ^I- crossed the EOF boundary;$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1539: FILE: mm/readahead.c:1007:
+^I * ^I- is close to EOF(explained below).$

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1549: FILE: mm/readahead.c:1017:
+	if (ra->readahead_index + ra_readahead_size(ra)/4 > eof_index) {
 	                                               ^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1566: FILE: mm/readahead.c:1034:
+	actual = __do_page_cache_readahead(mapping, filp,
 	                                            ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1567: FILE: mm/readahead.c:1035:
+	actual = __do_page_cache_readahead(mapping, filp,
+					ra->ra_index, ra_size, la_size);

CHECK:SPACING: spaces preferred around that '+' (ctx:VxV)
#1585: FILE: mm/readahead.c:1053:
+		size = (i_size_read(filp->f_dentry->d_inode)+1023)/1024;
 		                                            ^

CHECK:SPACING: spaces preferred around that '/' (ctx:VxV)
#1585: FILE: mm/readahead.c:1053:
+		size = (i_size_read(filp->f_dentry->d_inode)+1023)/1024;
 		                                                  ^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1589: FILE: mm/readahead.c:1057:
+			ddprintk("ino %lu is %s size %luK by %s(%d)\n",
+					filp->f_dentry->d_inode->i_ino,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1595: FILE: mm/readahead.c:1063:
+	dprintk("readahead-%s(ino=%lu, index=%lu, ra=%lu+%lu-%lu) = %d\n",
+			ra_class_name[ra_class_new(ra)],

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1611: FILE: mm/readahead.c:1079:
+static int adjust_rala(unsigned long ra_max,
+			unsigned long *ra_size, unsigned long *la_size)

WARNING:TYPO_SPELLING: 'Substract' may be misspelled - perhaps 'Subtract'?
#1614: FILE: mm/readahead.c:1082:
+	 * Substract the old look-ahead to get real safe size for the next
 	   ^^^^^^^^^

CHECK:BRACES: braces {} should be used on all arms of this statement
#1617: FILE: mm/readahead.c:1085:
+	if (*ra_size > *la_size)
[...]
+	else {
[...]

The placement of braces is stylistically incorrect.
The preferred way is to put the opening brace last on the line,
and put the closing brace first::

  if (x is true) {
          we do y
  }

This applies for all non-functional blocks.
However, there is one special case, namely functions: they have the
opening brace at the beginning of the next line, thus::

  int function(int x)
  {
          body of function
  }

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#placing-braces-and-spaces

CHECK:BRACES: Unbalanced braces around else statement
#1619: FILE: mm/readahead.c:1087:
+	else {

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1633: FILE: mm/readahead.c:1101:
+static void limit_rala(unsigned long ra_max, unsigned long la_old,
+			unsigned long *ra_size, unsigned long *la_size)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1679: FILE: mm/readahead.c:1147:
+static unsigned long compute_thrashing_threshold(struct file_ra_state *ra,
+							unsigned long *remain)

CHECK:PREFER_KERNEL_TYPES: Prefer kernel type 'u64' over 'uint64_t'
#1685: FILE: mm/readahead.c:1153:
+	uint64_t ll;

CHECK:SPACING: No space is necessary after a cast
#1693: FILE: mm/readahead.c:1161:
+	ll = (uint64_t) stream_shift * (global_size >> 9) * readahead_ratio * 5;

CHECK:BRACES: braces {} should be used on all arms of this statement
#1698: FILE: mm/readahead.c:1166:
+	if (global_size > global_shift) {
[...]
+	} else
[...]

CHECK:SPACING: No space is necessary after a cast
#1699: FILE: mm/readahead.c:1167:
+		ll = (uint64_t) stream_shift * (global_size - global_shift);

CHECK:BRACES: Unbalanced braces around else statement
#1702: FILE: mm/readahead.c:1170:
+	} else

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'compute_thrashing_threshold', this function's name, in a string
#1705: FILE: mm/readahead.c:1173:
+	ddprintk("compute_thrashing_threshold: "

WARNING:SPLIT_STRING: quoted string split across lines
#1706: FILE: mm/readahead.c:1174:
+	ddprintk("compute_thrashing_threshold: "
+			"at %lu ra %lu=%lu*%lu/%lu, remain %lu for %lu\n",

Quoted strings that appear as messages in userspace and can be
grepped, should not be split across multiple lines.

See: https://lore.kernel.org/lkml/20120203052727.GA15035@leaf/

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1718: FILE: mm/readahead.c:1186:
+state_based_readahead(struct address_space *mapping, struct file *filp,
                                                                   ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1719: FILE: mm/readahead.c:1187:
+state_based_readahead(struct address_space *mapping, struct file *filp,
+			struct file_ra_state *ra,

CHECK:MULTIPLE_ASSIGNMENTS: multiple assignments should be avoided
#1728: FILE: mm/readahead.c:1196:
+	la_old = la_size = ra->readahead_index - index;

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#1756: FILE: mm/readahead.c:1224:
+	return ra_dispatch(ra, mapping, filp);
 	                                ^^^^

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1779: FILE: mm/readahead.c:1247:
+ * ^Il: the number of pages read by the stream$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1781: FILE: mm/readahead.c:1249:
+ * ^IL: the number of pages pushed into inactive_list in the mean time$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1783: FILE: mm/readahead.c:1251:
+ * ^If(l01) <= L0$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1784: FILE: mm/readahead.c:1252:
+ * ^If(l11 + l12) = L1$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1785: FILE: mm/readahead.c:1253:
+ * ^If(l21 + l22) = L2$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1786: FILE: mm/readahead.c:1254:
+ * ^I...$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1787: FILE: mm/readahead.c:1255:
+ * ^If(l01 + l11 + ...) <= Sum(L0 + L1 + ...)$

CHECK:BIT_MACRO: Prefer using the BIT macro
#1799: FILE: mm/readahead.c:1267:
+#define PAGE_REFCNT_1           (1 << PG_referenced)

CHECK:BIT_MACRO: Prefer using the BIT macro
#1800: FILE: mm/readahead.c:1268:
+#define PAGE_REFCNT_2           (1 << PG_active)

ERROR:CODE_INDENT: code indent should use tabs where possible
#1815: FILE: mm/readahead.c:1283:
+        return page->flags & PAGE_REFCNT_MASK;$

Code indent should use tabs instead of spaces.
Outside of comments, documentation and Kconfig,
spaces are never used for indentation.

See: https://www.kernel.org/doc/html/latest/process/coding-style.html#indentation

WARNING:LEADING_SPACE: please, no spaces at the start of a line
#1815: FILE: mm/readahead.c:1283:
+        return page->flags & PAGE_REFCNT_MASK;$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#1822: FILE: mm/readahead.c:1290:
+ * ^I^Ilen(inactive_list) / speed(leader)$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1849: FILE: mm/readahead.c:1317:
+static pgoff_t find_segtail(struct address_space *mapping,
+					pgoff_t index, unsigned long max_scan)

WARNING:AVOID_BUG: Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()
#1857: FILE: mm/readahead.c:1325:
+	BUG_ON(!__probe_page(mapping, index));

BUG() or BUG_ON() should be avoided totally.
Use WARN() and WARN_ON() instead, and handle the "impossible"
error condition as gracefully as possible.

See: https://www.kernel.org/doc/html/latest/process/deprecated.html#bug-and-bug-on

WARNING:PREFER_PR_LEVEL: Prefer [subsystem eg: netdev]_err([subsystem]dev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
#1860: FILE: mm/readahead.c:1328:
+		printk(KERN_ERR "radix_tree_scan_hole(index=%lu ra_index=%lu "

WARNING:SPLIT_STRING: quoted string split across lines
#1861: FILE: mm/readahead.c:1329:
+		printk(KERN_ERR "radix_tree_scan_hole(index=%lu ra_index=%lu "
+				"max_scan=%lu nrpages=%lu) fooled!\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1878: FILE: mm/readahead.c:1346:
+static pgoff_t find_segtail_backward(struct address_space *mapping,
+					pgoff_t index, unsigned long max_scan)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1906: FILE: mm/readahead.c:1374:
+static int count_cache_hit(struct address_space *mapping,
+				pgoff_t first_index, pgoff_t last_index)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1933: FILE: mm/readahead.c:1401:
+static unsigned long query_page_cache_segment(struct address_space *mapping,
+				struct file_ra_state *ra,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#1948: FILE: mm/readahead.c:1416:
+	index = radix_tree_scan_hole_backward(&mapping->page_tree,
+							offset - 1, ra_max);

WARNING:EMBEDDED_FUNCTION_NAME: Prefer using '"%s...", __func__' to using 'query_page_cache_segment', this function's name, in a string
#2000: FILE: mm/readahead.c:1468:
+	ddprintk("query_page_cache_segment: "

WARNING:SPLIT_STRING: quoted string split across lines
#2001: FILE: mm/readahead.c:1469:
+	ddprintk("query_page_cache_segment: "
+			"ino=%lu, idx=%lu, count=%lu, remain=%lu\n",

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2019: FILE: mm/readahead.c:1487:
+static int adjust_rala_aggressive(unsigned long ra_max,
+				unsigned long *ra_size, unsigned long *la_size)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2041: FILE: mm/readahead.c:1509:
+try_context_based_readahead(struct address_space *mapping,
+			struct file_ra_state *ra, struct page *prev_page,

CHECK:BRACES: braces {} should be used on all arms of this statement
#2055: FILE: mm/readahead.c:1523:
+	if (page) {
[...]
+	} else if (prev_page || probe_page(mapping, index - 1)) {
[...]
+	} else if (readahead_hit_rate > 1) {
[...]
+	} else
[...]

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2063: FILE: mm/readahead.c:1531:
+		ra_index = find_segtail_backward(mapping, index,
+						readahead_hit_rate + ra_min);

CHECK:BRACES: Unbalanced braces around else statement
#2068: FILE: mm/readahead.c:1536:
+	} else

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2072: FILE: mm/readahead.c:1540:
+	ra_size = query_page_cache_segment(mapping, ra, &remain_pages,
+							index, ra_min, ra_max);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2076: FILE: mm/readahead.c:1544:
+	if (page && remain_pages <= la_size &&
+			remain_pages < index && la_size > 1) {

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2103: FILE: mm/readahead.c:1571:
+ * ^I- do not ruin the hit rate for file-head-peekers$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2104: FILE: mm/readahead.c:1572:
+ * ^I- do not lead to thrashing for memory tight systems$

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2107: FILE: mm/readahead.c:1575:
+initial_readahead(struct address_space *mapping, struct file *filp,
                                                               ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2108: FILE: mm/readahead.c:1576:
+initial_readahead(struct address_space *mapping, struct file *filp,
+		struct file_ra_state *ra, unsigned long req_size)

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2133: FILE: mm/readahead.c:1601:
+	return ra_dispatch(ra, mapping, filp);
 	                                ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2145: FILE: mm/readahead.c:1613:
+try_read_backward(struct file_ra_state *ra, pgoff_t begin_index,
+			unsigned long ra_size, unsigned long ra_max)

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2154: FILE: mm/readahead.c:1622:
+	if ((ra->flags & RA_CLASS_MASK) == RA_CLASS_BACKWARD &&
+					ra_has_index(ra, ra->prev_page)) {

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2183: FILE: mm/readahead.c:1651:
+ * ^Iseek(), 5*read(); seek(), 6*read(); seek(), 4*read(); ...$

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2189: FILE: mm/readahead.c:1657:
+try_readahead_on_seek(struct file_ra_state *ra, pgoff_t index,
+			unsigned long ra_size, unsigned long ra_max)

WARNING:TYPO_SPELLING: 'similiar' may be misspelled - perhaps 'similar'?
#2200: FILE: mm/readahead.c:1668:
+	/* The previous read-ahead sequences have similiar sizes? */
 	                                          ^^^^^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2202: FILE: mm/readahead.c:1670:
+	if (!(ra_size < hit1 && hit1 > hit2 / 2 &&
+				hit2 > hit3 / 2 &&

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2226: FILE: mm/readahead.c:1694:
+				struct file *filp, struct file_ra_state *ra,
 				             ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2226: FILE: mm/readahead.c:1694:
+thrashing_recovery_readahead(struct address_space *mapping,
+				struct file *filp, struct file_ra_state *ra,

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2233: FILE: mm/readahead.c:1701:
+		ra_account(ra, RA_EVENT_READAHEAD_MUTILATE,
+						ra->readahead_index - index);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2235: FILE: mm/readahead.c:1703:
+	ra_account(ra, RA_EVENT_READAHEAD_THRASHING,
+						ra->readahead_index - index);

CHECK:BRACES: braces {} should be used on all arms of this statement
#2242: FILE: mm/readahead.c:1710:
+	if (index < ra->ra_index)
[...]
+	else {
[...]

CHECK:BRACES: Unbalanced braces around else statement
#2244: FILE: mm/readahead.c:1712:
+	else {

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2260: FILE: mm/readahead.c:1728:
+	return ra_dispatch(ra, mapping, filp);
 	                                ^^^^

CHECK:SPACING: spaces preferred around that '<<' (ctx:VxV)
#2276: FILE: mm/readahead.c:1744:
+	pages = max_sane_readahead((1<<30) / PAGE_CACHE_SIZE);
 	                             ^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2279: FILE: mm/readahead.c:1747:
+	*ra_min = min(min(MIN_RA_PAGES + (pages >> 13),
+				(128*1024) / PAGE_CACHE_SIZE), *ra_max / 2);

CHECK:SPACING: spaces preferred around that '*' (ctx:VxV)
#2279: FILE: mm/readahead.c:1747:
+				(128*1024) / PAGE_CACHE_SIZE), *ra_max / 2);
 				    ^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2284: FILE: mm/readahead.c:1752:
+ * @mapping, @ra, @filp: the same as page_cache_readahead()
                    ^^^^

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2288: FILE: mm/readahead.c:1756:
+ * ^I^I[@begin_index, @end_index) is the read the caller is performing$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2289: FILE: mm/readahead.c:1757:
+ *^I ^I@index indicates the page to be read now$

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2306: FILE: mm/readahead.c:1774:
+			struct file_ra_state *ra, struct file *filp,
 			                                       ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2306: FILE: mm/readahead.c:1774:
+page_cache_readahead_adaptive(struct address_space *mapping,
+			struct file_ra_state *ra, struct file *filp,

ERROR:SPACING: space required before the open parenthesis '('
#2318: FILE: mm/readahead.c:1786:
+		if(!TestClearPageReadahead(page))

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2322: FILE: mm/readahead.c:1790:
+			ra_account(ra, RA_EVENT_IO_CONGESTION,
+							end_index - index);

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2327: FILE: mm/readahead.c:1795:
+			if (!renew_lookahead(mapping, ra, index,
+						index + LAPTOP_POLL_INTERVAL))

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2334: FILE: mm/readahead.c:1802:
+		ra_account(ra, RA_EVENT_LOOKAHEAD_HIT,
+				ra->readahead_index - ra->lookahead_index);

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2351: FILE: mm/readahead.c:1819:
+		return initial_readahead(mapping, filp, ra, size);
 		                                  ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2357: FILE: mm/readahead.c:1825:
+	if (!debug_option(disable_stateful_method) &&
+			index == ra->lookahead_index && ra_cache_hit_ok(ra))

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2358: FILE: mm/readahead.c:1826:
+		return state_based_readahead(mapping, filp, ra, page,
 		                                      ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2365: FILE: mm/readahead.c:1833:
+		return thrashing_recovery_readahead(mapping, filp, ra,
 		                                             ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2372: FILE: mm/readahead.c:1840:
+	if (!page && begin_index == index &&
+				try_read_backward(ra, index, size, ra_max))

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2373: FILE: mm/readahead.c:1841:
+		return ra_dispatch(ra, mapping, filp);
 		                                ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2379: FILE: mm/readahead.c:1847:
+	ret = try_context_based_readahead(mapping, ra, prev_page, page,
+							index, ra_min, ra_max);

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2381: FILE: mm/readahead.c:1849:
+		return ra_dispatch(ra, mapping, filp);
 		                                ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2388: FILE: mm/readahead.c:1856:
+		ra_account(ra, RA_EVENT_LOOKAHEAD_NOACTION,
+						ra->readahead_index - index);

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2396: FILE: mm/readahead.c:1864:
+		return ra_dispatch(ra, mapping, filp);
 		                                ^^^^

WARNING:TYPO_SPELLING: 'filp' may be misspelled - perhaps 'flip'?
#2405: FILE: mm/readahead.c:1873:
+	size = __do_page_cache_readahead(mapping, filp, index, size, 0);
 	                                          ^^^^

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2409: FILE: mm/readahead.c:1877:
+	dprintk("random_read(ino=%lu, pages=%lu, index=%lu-%lu-%lu) = %lu\n",
+			mapping->host->i_ino, mapping->nrpages,

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2444: FILE: mm/readahead.c:1912:
+ * ^I- on cache hit:  increase `backing_dev_info.ra_expect_bytes' slowly;$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2445: FILE: mm/readahead.c:1913:
+ * ^I- on cache miss: decrease it rapidly.$

WARNING:SPACE_BEFORE_TAB: please, no space before tabs
#2448: FILE: mm/readahead.c:1916:
+ * ^IHow many pages are expected to be read on start-of-file?$

WARNING:SPLIT_STRING: quoted string split across lines
#2473: FILE: mm/readahead.c:1941:
+		dprintk("initial_ra_hit on file %s size %lluK "
+				"pos %lu by %s(%d)\n",

WARNING:SPLIT_STRING: quoted string split across lines
#2487: FILE: mm/readahead.c:1955:
+		dprintk("initial_ra_miss on file %s "
+				"size %lluK cached %luK hit %luK "

WARNING:SPLIT_STRING: quoted string split across lines
#2488: FILE: mm/readahead.c:1956:
+				"size %lluK cached %luK hit %luK "
+				"pos %lu by %s(%d)\n",

WARNING:TYPO_SPELLING: 'contexta' may be misspelled - perhaps 'context'?
#2515: FILE: mm/readahead.c:1983:
+	"contexta",
 	 ^^^^^^^^

CHECK:BRACES: braces {} should be used on all arms of this statement
#2550: FILE: mm/readahead.c:2018:
+	if (e == RA_EVENT_READAHEAD_HIT && pages < 0) {
[...]
+	} else if (ra)
[...]
+	else
[...]

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#2615: FILE: mm/readahead.c:2083:
+	seq_printf(s, event_fmt, "random_rate");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2618: FILE: mm/readahead.c:2086:
+		seq_printf(s, percent_format,
+			(ra_events[c][RA_EVENT_RANDOM_READ][0] * 100) /

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#2623: FILE: mm/readahead.c:2091:
+	seq_printf(s, event_fmt, "ra_hit_rate");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2626: FILE: mm/readahead.c:2094:
+		seq_printf(s, percent_format,
+			(ra_events[c][RA_EVENT_READAHEAD_HIT][1] * 100) /

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#2630: FILE: mm/readahead.c:2098:
+	seq_printf(s, event_fmt, "la_hit_rate");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2633: FILE: mm/readahead.c:2101:
+		seq_printf(s, percent_format,
+			(ra_events[c][RA_EVENT_LOOKAHEAD_HIT][0] * 100) /

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#2637: FILE: mm/readahead.c:2105:
+	seq_printf(s, event_fmt, "var_ra_size");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2640: FILE: mm/readahead.c:2108:
+		seq_printf(s, item_fmt,
+			(ra_events[c][RA_EVENT_READAHEAD_CUBE][1] -

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#2647: FILE: mm/readahead.c:2115:
+	seq_printf(s, event_fmt, "avg_ra_size");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2650: FILE: mm/readahead.c:2118:
+		seq_printf(s, item_fmt,
+			(ra_events[c][RA_EVENT_READAHEAD][1] +

WARNING:PREFER_SEQ_PUTS: Prefer seq_puts to seq_printf
#2655: FILE: mm/readahead.c:2123:
+	seq_printf(s, event_fmt, "avg_la_size");

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2658: FILE: mm/readahead.c:2126:
+		seq_printf(s, item_fmt,
+			(ra_events[c][RA_EVENT_LOOKAHEAD][1] +

CHECK:PARENTHESIS_ALIGNMENT: Alignment should match open parenthesis
#2672: FILE: mm/readahead.c:2140:
+static ssize_t ra_events_write(struct file *file, const char __user *buf,
+						size_t size, loff_t *offset)

WARNING:CONST_STRUCT: struct file_operations should normally be const
#2678: FILE: mm/readahead.c:2146:
+struct file_operations ra_events_fops = {

Using const is generally a good idea.  Checkpatch reads
a list of frequently used structs that are always or
almost always constant.

The existing structs list can be viewed from
`scripts/const_structs.checkpatch`.

See: https://lore.kernel.org/lkml/alpine.DEB.2.10.1608281509480.3321@hadrien/

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'var' may be better as '(var)' to avoid precedence issues
#2687: FILE: mm/readahead.c:2155:
+#define READAHEAD_DEBUGFS_ENTRY_U32(var) \
+	debugfs_create_u32(__stringify(var), 0644, root, &var)

CHECK:MACRO_ARG_PRECEDENCE: Macro argument 'var' may be better as '(var)' to avoid precedence issues
#2690: FILE: mm/readahead.c:2158:
+#define READAHEAD_DEBUGFS_ENTRY_BOOL(var) \
+	debugfs_create_bool(__stringify(var), 0644, root, &var)

/tmp/tmp.gGZ8aIRHtl//home/kkleine/dev/lkml/0/patch.offset.61906.commit.fc9d22dee9064858b28cba53f0d39edbee623680 total: 11 errors, 94 warnings, 109 checks, 2566 lines checked

NOTE: For some of the reported defects, checkpatch may be able to
      mechanically convert to the typical style using --fix or --fix-inplace.

NOTE: Whitespace errors detected.
      You may wish to use scripts/cleanpatch or scripts/cleanfile

/tmp/tmp.gGZ8aIRHtl//home/kkleine/dev/lkml/0/patch.offset.61906.commit.fc9d22dee9064858b28cba53f0d39edbee623680 has style problems, please review.

NOTE: If any of the errors are false positives, please report
      them to the maintainer, see CHECKPATCH in MAINTAINERS.
